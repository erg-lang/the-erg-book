<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Erg Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="01_literal.html"><strong aria-hidden="true">2.</strong> Literal</a></li><li class="chapter-item expanded "><a href="02_name.html"><strong aria-hidden="true">3.</strong> Name</a></li><li class="chapter-item expanded "><a href="03_declaration.html"><strong aria-hidden="true">4.</strong> Declaration</a></li><li class="chapter-item expanded "><a href="04_function.html"><strong aria-hidden="true">5.</strong> Function</a></li><li class="chapter-item expanded "><a href="05_builtin_funcs.html"><strong aria-hidden="true">6.</strong> Builtin Functions</a></li><li class="chapter-item expanded "><a href="06_operator.html"><strong aria-hidden="true">7.</strong> Operator</a></li><li class="chapter-item expanded "><a href="07_side_effect.html"><strong aria-hidden="true">8.</strong> Side Effect</a></li><li class="chapter-item expanded "><a href="08_procedure.html"><strong aria-hidden="true">9.</strong> Procedure</a></li><li class="chapter-item expanded "><a href="09_builtin_procs.html"><strong aria-hidden="true">10.</strong> Builtin Procedures</a></li><li class="chapter-item expanded "><a href="10_array.html"><strong aria-hidden="true">11.</strong> Array</a></li><li class="chapter-item expanded "><a href="11_tuple.html"><strong aria-hidden="true">12.</strong> Tuple</a></li><li class="chapter-item expanded "><a href="12_dict.html"><strong aria-hidden="true">13.</strong> Dict</a></li><li class="chapter-item expanded "><a href="13_record.html"><strong aria-hidden="true">14.</strong> Record</a></li><li class="chapter-item expanded "><a href="14_set.html"><strong aria-hidden="true">15.</strong> Set</a></li><li class="chapter-item expanded "><a href="15_type.html"><strong aria-hidden="true">16.</strong> Type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/01_type_system.html"><strong aria-hidden="true">16.1.</strong> Type System</a></li><li class="chapter-item expanded "><a href="type/02_basic.html"><strong aria-hidden="true">16.2.</strong> Basics</a></li><li class="chapter-item expanded "><a href="type/03_trait.html"><strong aria-hidden="true">16.3.</strong> Trait</a></li><li class="chapter-item expanded "><a href="type/04_class.html"><strong aria-hidden="true">16.4.</strong> Class</a></li><li class="chapter-item expanded "><a href="type/05_inheritance.html"><strong aria-hidden="true">16.5.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="type/06_nst_vs_sst.html"><strong aria-hidden="true">16.6.</strong> NST vs SST</a></li><li class="chapter-item expanded "><a href="type/07_patch.html"><strong aria-hidden="true">16.7.</strong> Patch</a></li><li class="chapter-item expanded "><a href="type/08_value.html"><strong aria-hidden="true">16.8.</strong> Value Type</a></li><li class="chapter-item expanded "><a href="type/09_attributive.html"><strong aria-hidden="true">16.9.</strong> Attributive Type</a></li><li class="chapter-item expanded "><a href="type/10_interval.html"><strong aria-hidden="true">16.10.</strong> Interval Type</a></li><li class="chapter-item expanded "><a href="type/11_enum.html"><strong aria-hidden="true">16.11.</strong> Enum Type</a></li><li class="chapter-item expanded "><a href="type/12_refinement.html"><strong aria-hidden="true">16.12.</strong> Refinement Type</a></li><li class="chapter-item expanded "><a href="type/13_algebraic.html"><strong aria-hidden="true">16.13.</strong> Algebraic Type</a></li><li class="chapter-item expanded "><a href="type/14_dependent.html"><strong aria-hidden="true">16.14.</strong> Dependent Type</a></li><li class="chapter-item expanded "><a href="type/15_quantified.html"><strong aria-hidden="true">16.15.</strong> Quantified Type</a></li><li class="chapter-item expanded "><a href="type/16_subtyping.html"><strong aria-hidden="true">16.16.</strong> Subtyping</a></li><li class="chapter-item expanded "><a href="type/17_type_casting.html"><strong aria-hidden="true">16.17.</strong> Type Casting</a></li><li class="chapter-item expanded "><a href="type/18_mut.html"><strong aria-hidden="true">16.18.</strong> Mutable Type</a></li><li class="chapter-item expanded "><a href="type/advanced.html"><strong aria-hidden="true">16.19.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/advanced/default_param.html"><strong aria-hidden="true">16.19.1.</strong> Default Parameter</a></li><li class="chapter-item expanded "><a href="type/advanced/erasure.html"><strong aria-hidden="true">16.19.2.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="type/advanced/existential.html"><strong aria-hidden="true">16.19.3.</strong> Existential</a></li><li class="chapter-item expanded "><a href="type/advanced/GADTs.html"><strong aria-hidden="true">16.19.4.</strong> GADTs</a></li><li class="chapter-item expanded "><a href="type/advanced/keyword_param.html"><strong aria-hidden="true">16.19.5.</strong> Keyword Parameters</a></li><li class="chapter-item expanded "><a href="type/advanced/kind.html"><strong aria-hidden="true">16.19.6.</strong> Kind</a></li><li class="chapter-item expanded "><a href="type/advanced/marker_trait.html"><strong aria-hidden="true">16.19.7.</strong> Marker Trait</a></li><li class="chapter-item expanded "><a href="type/advanced/mut_struct.html"><strong aria-hidden="true">16.19.8.</strong> Mutable Struct</a></li><li class="chapter-item expanded "><a href="type/advanced/phantom.html"><strong aria-hidden="true">16.19.9.</strong> Phantom Type</a></li><li class="chapter-item expanded "><a href="type/advanced/projection.html"><strong aria-hidden="true">16.19.10.</strong> Projection Type</a></li><li class="chapter-item expanded "><a href="type/advanced/quantified_dependent.html"><strong aria-hidden="true">16.19.11.</strong> Quantified Dependent Type</a></li><li class="chapter-item expanded "><a href="type/advanced/shared.html"><strong aria-hidden="true">16.19.12.</strong> Shared</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="16_iterator.html"><strong aria-hidden="true">17.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="17_mutability.html"><strong aria-hidden="true">18.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="18_ownership.html"><strong aria-hidden="true">19.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="19_visibility.html"><strong aria-hidden="true">20.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="20_naming_rule.html"><strong aria-hidden="true">21.</strong> Naming Rule</a></li><li class="chapter-item expanded "><a href="21_lambda.html"><strong aria-hidden="true">22.</strong> Lambda</a></li><li class="chapter-item expanded "><a href="22_subroutine.html"><strong aria-hidden="true">23.</strong> Subroutine</a></li><li class="chapter-item expanded "><a href="23_closure.html"><strong aria-hidden="true">24.</strong> Closure</a></li><li class="chapter-item expanded "><a href="24_module.html"><strong aria-hidden="true">25.</strong> Module</a></li><li class="chapter-item expanded "><a href="25_object_system.html"><strong aria-hidden="true">26.</strong> Object System</a></li><li class="chapter-item expanded "><a href="26_pattern_matching.html"><strong aria-hidden="true">27.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="27_comprehension.html"><strong aria-hidden="true">28.</strong> Comprehension</a></li><li class="chapter-item expanded "><a href="28_spread_syntax.html"><strong aria-hidden="true">29.</strong> Spread Syntax</a></li><li class="chapter-item expanded "><a href="29_decorator.html"><strong aria-hidden="true">30.</strong> Decorator</a></li><li class="chapter-item expanded "><a href="30_error_handling.html"><strong aria-hidden="true">31.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="31_pipeline.html"><strong aria-hidden="true">32.</strong> Pipeline</a></li><li class="chapter-item expanded "><a href="32_integration_with_python.html"><strong aria-hidden="true">33.</strong> Integration With Python</a></li><li class="chapter-item expanded "><a href="33_package_system.html"><strong aria-hidden="true">34.</strong> Package System</a></li><li class="chapter-item expanded "><a href="34_generator.html"><strong aria-hidden="true">35.</strong> Generator</a></li><li class="chapter-item expanded "><a href="indexes.html"><strong aria-hidden="true">36.</strong> Index</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Erg Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<blockquote>
<p><strong>Warning</strong>: This document is incomplete. It has not been proofread (style, correct links, mistranslation, etc.). Also, Erg's syntax may be change destructively during version 0.*, and the documentation may not have been updated accordingly. Please be aware of this beforehand.
If you find any errors in this document, please report then to <a href="https://forms.gle/HtLYRfYzWCAaeTGb6">here form</a> or <a href="https://github.com/mtshiba/TheErgBook/issues/new">GitHub repo</a>. We would appreciate your suggestions.</p>
<p><a href="https://erg-lang.org/the-erg-book/JA/">Erg Book 日本語訳</a></p>
<p><a href="https://erg-lang.org/the-erg-book/zh_TW/">Erg Book 繁體中文翻譯</a></p>
<p><a href="https://erg-lang.org/the-erg-book/zh_CN/">Erg Book 简体中文翻译</a></p>
</blockquote>
<p>This document describes the basic syntax of Erg.
If you already have experience with languages such as Python, please refer to the <a href="quick_tour.html">quick tour</a> for an overview.
There is also a separate <a href="../API/index.html">Standard API</a> and <a href="../dev_guide/index.html">Internal Documentation for Erg Contributors</a>. If you need a detailed explanation of the syntax or Erg itself, please refer to those documents.</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>First, let's do &quot;Hello World&quot;.</p>
<pre><code class="language-python">print!(&quot;Hello, World!&quot;)
</code></pre>
<p>This is almost identical to Python and other languages in the same family. The most striking feature is the <code>!</code>, the meaning of which will be explained later.
In Erg, parentheses <code>()</code> can be omitted unless there is some confusion in interpretation.
The omission of parentheses is similar to Ruby, but it is not possible to omit parentheses that can be interpreted in more than one way.</p>
<pre><code class="language-python">print! &quot;Hello, World!&quot; # OK
print! &quot;Hello,&quot;, &quot;World!&quot; # OK
print!() # OK
print! # OK, but this does not mean to call, simply to get `print!` as a callable object

print! f x # OK, interpreted as `print!(f(x))`
print!(f(x, y)) # OK
print! f(x, y) # OK
print! f(x, g y) # OK
print! f x, y # NG, can be taken to mean either `print!(f(x), y)` or `print!(f(x, y))` print!
print!(f x, y) # NG, can be taken to mean either `print!(f(x), y)` or `print!(f(x, y))`
print! f(x, g y, z) # NG, can be taken to mean either `print!(x, g(y), z)` or `print!(x, g(y, z))`
</code></pre>
<h2 id="scripts"><a class="header" href="#scripts">Scripts</a></h2>
<p>Erg code is called a script. Scripts can be saved and executed in file format (.er).</p>
<h2 id="replfile-execution"><a class="header" href="#replfile-execution">REPL/File Execution</a></h2>
<p>To start REPL, simply type:</p>
<pre><code class="language-sh">&gt; erg
</code></pre>
<p><code>&gt;</code> mark is a prompt, just type <code>erg</code>.
Then the REPL should start.</p>
<pre><code class="language-sh">&gt; erg
Starting the REPL server...
Connecting to the REPL server...
Erg interpreter 0.2.4 (tags/?:, 2022/08/17  0:55:12.95) on x86_64/windows
&gt;&gt;&gt;
</code></pre>
<p>Or you can compile from a file.</p>
<pre><code class="language-sh">&gt; 'print! &quot;hello, world!&quot;' &gt;&gt; hello.er

&gt; erg hello.er
hello, world!
</code></pre>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>The code after <code>#</code> is ignored as a comment. Use this to explain the intent of the code or to temporarily disable the code.</p>
<pre><code class="language-python"># Comment
# `#` and after are ignored until a new line is inserted
#[
Multi-line comment
Treated as a comment all the way up to the corresponding `]#`
]#
</code></pre>
<h2 id="expressions-separators"><a class="header" href="#expressions-separators">Expressions, separators</a></h2>
<p>A script is a series of expressions. An expression is something that can be calculated or evaluated, and in Erg almost everything is an expression.
Each expression is separated by a separator - either a new line or a semicolon <code>;</code>-.
Erg scripts are basically evaluated from left to right, top to bottom.</p>
<pre><code class="language-python">n = 1 # assignment expression
f(1, 2) # function-call expression
1 + 1 # operator-call expression
f(1, 2); 1 + 1
</code></pre>
<p>As shown below, there is a syntax called instant block that takes the last expression evaluated in the block as the value of the variable.
This differs from a function with no arguments, which does not add <code>()</code>. Note that instant blocks are evaluated only once on the fly.</p>
<pre><code class="language-python">i =
    x = 1
    x + 1
assert i == 2
</code></pre>
<p>This cannot be accomplished with a semicolon (<code>;</code>).</p>
<pre><code class="language-python">i = (x = 1; x + 1) # SyntaxError: cannot use `;` in parentheses
</code></pre>
<h2 id="indentation"><a class="header" href="#indentation">Indentation</a></h2>
<p>Erg, like Python, uses indentation to represent blocks. There are five operators (special forms) that trigger the start of a block: <code>=</code>, <code>-&gt;</code>, <code>=&gt;</code>, <code>do</code>, and <code>do!</code> (In addition, <code>:</code> and <code>|</code>, although not operators, also produce indentation). The meanings of each are described later.</p>
<pre><code class="language-python">f x, y =
    x + y

for! 0..9, i =&gt;
    print!

for! 0..9, i =&gt;
    print! i; print! i

ans = match x:
    0 -&gt; &quot;zero&quot;
    _: 0..9 -&gt; &quot;1 dight&quot;
    _: 10..99 -&gt; &quot;2 dights&quot;
    _ -&gt; &quot;unknown&quot;
</code></pre>
<p>If a line is too long, it can be broken using <code>\</code>.</p>
<pre><code class="language-python"># this does not means `x + y + z` but means `x; +y; +z`
x
+ y
+ z

# this means `x + y + z`
x \
+ y \
+ z
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="literal"><a class="header" href="#literal">Literal</a></h1>
<h2 id="basic-literals"><a class="header" href="#basic-literals">Basic Literals</a></h2>
<h3 id="int-literal"><a class="header" href="#int-literal">Int Literal</a></h3>
<pre><code class="language-python">0, -0, 1, -1, 2, -2, 3, -3, ...
</code></pre>
<h3 id="ratio-literal"><a class="header" href="#ratio-literal">Ratio Literal</a></h3>
<pre><code class="language-python">0.00, -0.0, 0.1, 400.104, ...
</code></pre>
<p>If a <code>Ratio</code> literal has an integer or decimal part of <code>0</code>, you can omit the <code>0</code>.</p>
<pre><code class="language-python">assert 1.0 == 1.
assert 0.5 == .5
</code></pre>
<blockquote>
<p><strong>Note</strong>: This function <code>assert</code> was used to show that <code>1.0</code> and <code>1.</code> are equal.
Subsequent documents may use <code>assert</code> to indicate that the results are equal.</p>
</blockquote>
<h3 id="str-literal"><a class="header" href="#str-literal">Str Literal</a></h3>
<p>Any Unicode-representable string can be used.
Unlike Python, quotation marks cannot be enclosed in <code>'</code>. If you want to use <code>&quot;</code> in a string, use <code>\&quot;</code>.</p>
<pre><code class="language-python">&quot;&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;111&quot;, &quot;1# 3f2-3*8$&quot;, &quot;こんにちは&quot;, &quot;السَّلَامُ عَلَيْكُمْ&quot;, ...
</code></pre>
<p><code>{}</code> allows you to embed expressions in strings. This is called string interpolation.
If you want to output <code>{</code>, <code>}</code> itself, use <code>\{</code>, <code>\}</code>.</p>
<pre><code class="language-python">assert &quot;1 + 1 is 2&quot; == &quot;{1} + {1} is {1+1}&quot;
s = &quot;1+1&quot;
assert &quot;\{1+1}\&quot; == &quot;\{{s}\}&quot;
</code></pre>
<h3 id="exponential-literal"><a class="header" href="#exponential-literal">Exponential Literal</a></h3>
<p>This is a literal representing exponential notation often used in academic calculations. It is an instance of type <code>Ratio</code>.
The notation is the same as in Python.</p>
<pre><code class="language-python">1e-34, 0.4e-10, 2.455+e5, 245e5, 25E5, ...
</code></pre>
<pre><code class="language-python">assert 1e-10 == 0.0000000001
</code></pre>
<h2 id="compound-literals"><a class="header" href="#compound-literals">Compound Literals</a></h2>
<p>Each of these literals has its own documentation describing them separately, so please refer to that documentation for details.</p>
<h3 id="a-href10_arrayhtmlarray-literala"><a class="header" href="#a-href10_arrayhtmlarray-literala"><a href="./10_array.html">Array Literal</a></a></h3>
<pre><code class="language-python">[], [1], [1, 2, 3], [&quot;1&quot;, &quot;2&quot;,], [1, &quot;1&quot;, True, [1]], ...
</code></pre>
<h3 id="a-href11_tuplehtmltuple-literala"><a class="header" href="#a-href11_tuplehtmltuple-literala"><a href="./11_tuple.html">Tuple Literal</a></a></h3>
<pre><code class="language-python">(), (1, 2, 3), (1, &quot;hello&quot;, True), ...
</code></pre>
<h3 id="a-href12_dicthtmldict-literala"><a class="header" href="#a-href12_dicthtmldict-literala"><a href="./12_dict.html">Dict Literal</a></a></h3>
<pre><code class="language-python">{:}, {&quot;one&quot;: 1}, {&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;1&quot;: 1, &quot;2&quot;: 2}, {1: &quot;1&quot;, 2: True, &quot;three&quot;: [1]}, ...
</code></pre>
<h3 id="a-href13_recordhtmlrecord-literala"><a class="header" href="#a-href13_recordhtmlrecord-literala"><a href="./13_record.html">Record Literal</a></a></h3>
<pre><code class="language-python">{=}, {one = 1}, {one = 1; two = 2}, {.name = &quot;John&quot;; .age = 12}, {.name = Str; .age = Nat}, ...
</code></pre>
<h3 id="a-href14_sethtmlset-literala"><a class="header" href="#a-href14_sethtmlset-literala"><a href="./14_set.html">Set Literal</a></a></h3>
<pre><code class="language-python">{}, {1}, {1, 2, 3}, {&quot;1&quot;, &quot;2&quot;, &quot;1&quot;}, {1, &quot;1&quot;, True, [1]} ...
</code></pre>
<p>As a difference from <code>Array</code> literals, duplicate elements are removed in <code>Set</code>.</p>
<pre><code class="language-python">assert {1, 2, 1} == {1, 2}
</code></pre>
<h3 id="what-looks-like-a-literal-but-isnt"><a class="header" href="#what-looks-like-a-literal-but-isnt">What looks like a literal but isn't</a></h3>
<h2 id="boolean-object"><a class="header" href="#boolean-object">Boolean Object</a></h2>
<pre><code class="language-python">True, False
</code></pre>
<h3 id="none-object"><a class="header" href="#none-object">None Object</a></h3>
<pre><code class="language-python">None
</code></pre>
<h2 id="range-object"><a class="header" href="#range-object">Range Object</a></h2>
<pre><code class="language-python">assert 0..5 == {1, 2, 3, 4, 5}
assert 0..10 in 5
assert 0..&lt;10 notin 10
assert 0..9 == 0..&lt;10
</code></pre>
<h2 id="float-object"><a class="header" href="#float-object">Float Object</a></h2>
<pre><code class="language-python">assert 0.0f64 == 0
assert 0.0f32 == 0.0f64
</code></pre>
<p>Float objects are constructed by multiplying a <code>Ratio</code> object by <code>f64</code>, which is a <code>Float 64</code> unit object.</p>
<h2 id="complex-object"><a class="header" href="#complex-object">Complex Object</a></h2>
<pre><code class="language-python">1+2im, 0.4-1.2im, 0im, im
</code></pre>
<p>A <code>Complex</code> object is simply an arithmetic combination of an imaginary unit object, <code>im</code>.</p>
<h2 id="-less-multiplication"><a class="header" href="#-less-multiplication">*-less multiplication</a></h2>
<p>In Erg, you can omit the <code>*</code> to indicate multiplication as long as there is no confusion in interpretation. However, the combined strength of the operators is set stronger than <code>*</code>.</p>
<pre><code class="language-python"># same as `assert (1*m) / (1*s) == 1*(m/s)`
assert 1m / 1s == 1 (m/s)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="variable"><a class="header" href="#variable">Variable</a></h1>
<p>Variables are a type of algebra; algebra in Erg - sometimes simply referred to as variable if there is no confusion - refers to the feature to name objects and make them referable from elsewhere in the code.</p>
<p>A variable is defined as follows.
The <code>n</code> part is called the variable name (or identifier), <code>=</code> is the assignment operator, and the <code>1</code> part is the assigned value.</p>
<pre><code class="language-python">n = 1
</code></pre>
<p>The <code>n</code> defined in this way can thereafter be used as a variable to denote the integer object <code>1</code>. This system is called assignment (or binding).
We have just said that <code>1</code> is an object. We will discuss what an object is later, but for now we will assume that it is something that can be assigned to, i.e., on the right side of the assignment operator (<code>=</code>, etc.).</p>
<p>If you want to specify the &quot;type&quot; of a variable, do the following. The type is roughly the set to which an object belongs, as will be explained later.
Here we specify that <code>n</code> is a natural number (<code>Nat</code>) type.</p>
<pre><code class="language-python">n: Nat = 1
</code></pre>
<p>Note that, unlike other languages, multiple assignments are not allowed.</p>
<pre><code class="language-python"># NG
l1 = l2 = [1, 2, 3] # SyntaxError: multiple assignment not allowed
# OK
l1 = [1, 2, 3]
l2 = l1.clone()
</code></pre>
<p>It is also not possible to reassign to a variable. The syntax that can be used instead, to hold mutable states, are described later.</p>
<pre><code class="language-python">i = 1
i = i + 1 # AssignError: cannot assign twice
</code></pre>
<p>You can define a variable with the same name in the inner scope, but you are only covering it over, not destructively rewriting its value. If you go back to the outer scope, the value will return as well.
Note that this is a different behavior than the Python &quot;statement&quot; scope.
This kind of functionality is generally referred to as shadowing. However, unlike shadowing in other languages, you cannot shadow in the same scope.</p>
<pre><code class="language-python">x = 0
# x = 1 # AssignError: cannot assign twice
if x.is_zero(), do:
    x = 1 # different from outer x with same name
    assert x == 1
assert x == 0
</code></pre>
<p>The following may seem possible at first glance, but it is still not possible. This is a design decision, not a technical constraint.</p>
<pre><code class="language-python">x = 0
if x.is_zero(), do:
    x = x + 1 # NameError: cannot define variables refer to variables with the same name
    assert x == 1
assert x == 0
</code></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Constants are also a type of algebra. If you start an identifier with a capital letter, it is treated as a constant. They are called constants because once defined, they do not change.
The <code>N</code> part is called the constant name (or identifier). Otherwise, it is the same as a variable.</p>
<pre><code class="language-python">N = 0
if True, do:
    N = 1 # AssignError: constants cannot be shadowed
    pass()
</code></pre>
<p>Constants are immutable beyond the defined scope. They cannot be shadowed. Because of this property, constants can be used in pattern matching. Pattern matching is explained later.</p>
<p>For example, constants are used for mathematical constants, information about external resources, and other immutable values.</p>
<p>It is common practice to use all-caps (style in which all letters are capitalized) for identifiers of objects other than <a href="./type/01_type_system.html">types</a>.</p>
<pre><code class="language-python">PI = 3.141592653589793
URL = &quot;https://example.com&quot;
CHOICES = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<pre><code class="language-python">PI = 3.141592653589793
match! x:
    PI =&gt; print! &quot;π&quot;
    other =&gt; print! &quot;other&quot;
</code></pre>
<p>The above code prints <code>π</code> when <code>x</code> is <code>3.141592653589793</code>. If <code>x</code> is changed to any other number, it prints <code>other</code>.</p>
<p>Some objects cannot be bound as constants. Mutable objects, for example. Mutable objects are objects whose states can be changed, as described in detail later.
This is because of the rule that only constant expressions can be assigned to constants. Constant expressions are also discussed later.</p>
<pre><code class="language-python">X = 1 # OK
X = !1 # TypeError: cannot define Int! object as a constant
</code></pre>
<h2 id="delete-an-variable"><a class="header" href="#delete-an-variable">Delete an Variable</a></h2>
<p>You can delete an variable by using the <code>Del</code> function. All other variables that depend on the variable (that is, that refer directly to the value of the variable) are also removed.</p>
<pre><code class="language-python">x = 1
y = 2
Z = 3
f a = x + a

assert f(2) == 3
Del x
Del y, Z

f(2) # NameError: f is not defined (deleted in line 6)
</code></pre>
<p>Note that <code>Del</code> can only delete variables defined in the user-defined module. Built-in constants such as <code>True</code> cannot be deleted.</p>
<pre><code class="language-python">Del True # TypeError: cannot delete built-in constants
Del print! # TypeError: cannot delete built-in variables
</code></pre>
<h2 id="appendix-assignment-and-equivalence"><a class="header" href="#appendix-assignment-and-equivalence">Appendix: Assignment and Equivalence</a></h2>
<p>Note that <code>x == a</code> is not necessarily true when <code>x = a</code>. An example is <code>Float.NaN</code>. This is the formal specification of floating-point numbers as defined by IEEE 754.</p>
<pre><code class="language-python">x = Float.NaN
assert x ! = NaN
assert x ! = x
</code></pre>
<p>There are other objects for which no equivalence relation is defined in the first place.</p>
<pre><code class="language-python">f = x -&gt; x**2 + 2x + 1
g = x -&gt; (x + 1)**2
f == g # TypeError: cannot compare function objects

C = Class {i: Int}
D = Class {i: Int}
C == D # TypeError: cannot compare class objects
</code></pre>
<p>Strictly speaking, <code>=</code> does not assign the right-hand side value directly to the left-hand side identifier.
In the case of function and class objects, &quot;modification&quot; such as giving variable name information to the object is performed. However, this is not the case for structural types.</p>
<pre><code class="language-python">f x = x
print! f # &lt;function f&gt;
g x = x + 1
print! g # &lt;function g&gt;

C = Class {i: Int}
print! C # &lt;class C&gt;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="declaration"><a class="header" href="#declaration">Declaration</a></h1>
<p>Declaration is the syntax for specifying the type of variable to be used.
Declarations can be made anywhere in the code, but declarations alone do not refer to the variables. They must be initialized.
After the assignment, the declaration can be checked to ensure that the type is compatible with the object to which it is assigned.</p>
<pre><code class="language-python">i: Int
# Can be declared at the same time as the assignment, like i: Int = 2
i = 2
i: Num
i: Nat
i: -2..2
i: {2}
</code></pre>
<p>Declaration after assignment is similar to type checking by <code>assert</code>, but has the feature that it is checked at compile time.
Type checking by <code>assert</code> at runtime can be checked for &quot;may be type Foo&quot;, but type checking by <code>:</code> at compile time is strict: if the type is not determined to be &quot;type Foo&quot;, it will not pass the check and an error will occur.</p>
<pre><code class="language-python">i = (-1..10).sample!
assert i in Nat # this may pass
i: Int # this will pass
i: Nat # this will not pass (-1 is not an element of Nat)
</code></pre>
<p>Functions can be declared in 2 different ways.</p>
<pre><code class="language-python">f: (x: Int, y: Int) -&gt; Int
f: (Int, Int) -&gt; Int
</code></pre>
<p>If you declare the argument names explicitly, a type error will result if the names are different at definition time. If you want to give the argument names arbitrary names, you can declare them in the second way. In that case, only the method name and its type will be seen by type checking.</p>
<pre><code class="language-python">T = Trait {
    .f = (x: Int, y: Int): Int
}

C = Class(U, Impl := T)
C.f(a: Int, b: Int): Int = ... # TypeError: `.f` must be type of `(x: Int, y: Int) -&gt; Int`, not `(a: Int, b: Int) -&gt; Int`
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="function"><a class="header" href="#function">Function</a></h1>
<p>A function is a block that takes an &quot;argument&quot;, processes it, and returns it as a &quot;return value&quot;. It is defined as follows.</p>
<pre><code class="language-python">add x, y = x + y
# or
add(x, y) = x + y
</code></pre>
<p>The names specified after a function name are called parameters.
In contrast, the objects passed to a function are called arguments.
The function <code>add</code> is a function that takes <code>x</code> and <code>y</code> as parameters and returns the sum of them, <code>x + y</code>.
The defined function can be called (applied/invoked) as follows.</p>
<pre><code class="language-python">add 1, 2
# or
add(1, 2)
</code></pre>
<h2 id="colon-application-style"><a class="header" href="#colon-application-style">Colon application style</a></h2>
<p>Functions are invoked like <code>f x, y, ...</code>, but if there are too many arguments for a single line, they can be applied using <code>:</code> (colon).</p>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2, some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2:
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<p>Codes above mean the same thing. This style is also useful when using <code>if</code> functions, for example.</p>
<pre><code class="language-python">result = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
</code></pre>
<p>After <code>:</code>, no code other than comments may be written, and must always be on a new line.
Also, you cannot use <code>:</code> immediately after a function. Only <code>do</code> and <code>do!</code> can do this.</p>
<pre><code class="language-python"># NG
f:
    x
    y
</code></pre>
<h2 id="keyword-arguments"><a class="header" href="#keyword-arguments">Keyword Arguments</a></h2>
<p>If a function is defined with a large number of parameters, there is a danger of passing the arguments in the wrong order.
In such cases, it is safe to call the function using keyword arguments.</p>
<pre><code class="language-python">f x, y, z, w, v, u: Int = ...
</code></pre>
<p>The functions defined above have many arguments and are arranged in a confusing order. You should not create such a function, but you may encounter such code when using code written by others. Therefore, we use keyword arguments. If you use keyword arguments, the values are passed from the name to the correct argument, even if they are in the wrong order.</p>
<pre><code class="language-python">f u: 6, v: 5, w: 4, x: 1, y: 2, z: 3
</code></pre>
<p>Note that keyword arguments and a new line immediately after the <code>:</code> are considered a colon-call style.</p>
<pre><code class="language-python"># means `f(x: y)`
f x: y

# means `f(x, y)`
f x:
    y
</code></pre>
<h2 id="default-parameters"><a class="header" href="#default-parameters">Default parameters</a></h2>
<p>Default parameters are used when some parameters are mostly fixed and you want to be able to omit them.</p>
<p>Default parameters are specified by <code>:=</code>(walrus operator). If <code>base</code> is not specified, assign <code>math.E</code> to <code>base</code>.</p>
<pre><code class="language-python">math_log x: Ratio, base := math.E = ...

assert math_log(100, 10) == 2
assert math_log(100) == math_log(100, math.E)
</code></pre>
<p>Note that there is a distinction between specifying no argument and assigning <code>None</code>.</p>
<pre><code class="language-python">p! x := 0 = print!
p!(2) # 2
p!() # 0
p!(None) # None
</code></pre>
<p>Can also be used with type specification and patterns.</p>
<pre><code class="language-python">math_log x, base: Ratio := math.E = ...
f [x, y] := [1, 2] = ...
</code></pre>
<p>However, within the default arguments, it is not possible to call the procedures (described later) or assign mutable objects.</p>
<pre><code class="language-python">f x := p! 1 = ... # NG
</code></pre>
<p>Also, the argument just defined cannot be used as the value passed to the default argument.</p>
<pre><code class="language-python">f x := 1, y := x = ... # NG
</code></pre>
<h2 id="variable-length-arguments"><a class="header" href="#variable-length-arguments">Variable-length arguments</a></h2>
<p>The <code>log</code> function, which outputs a log (record) of its arguments, can take any number of arguments.</p>
<pre><code class="language-python">log &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot; # Hello World !
</code></pre>
<p>To define such a function, add <code>...</code> to a parameter. This way, the function receives arguments as a variable-length array.</p>
<pre><code class="language-python">f ...x =
    for x, i -&gt;
        log i

# x == [1, 2, 3, 4, 5]
f 1, 2, 3, 4, 5
</code></pre>
<h2 id="function-definition-with-multiple-patterns"><a class="header" href="#function-definition-with-multiple-patterns">Function definition with multiple patterns</a></h2>
<pre><code class="language-python">fib n: Nat =
    match n:
        0 -&gt; 0
        1 -&gt; 1
        n -&gt; fib(n - 1) + fib(n - 2)
</code></pre>
<p>Functions like the one above, where <code>match</code> appears directly under the definition, can be rewritten as follows.</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
fib(n: Nat): Nat = fib(n - 1) + fib(n - 2)
</code></pre>
<p>Note that a function definition with multiple patterns is not so-called overloading (multiple definition); a function has only a single definition. In the example above, <code>n</code> must be of the same type as <code>0</code> or <code>1</code>. Also, as with <code>match</code>, pattern matching is done from top to bottom.</p>
<p>If instances of different classes are mixed, the last definition must specify that the function argument is of type <code>Or</code>.</p>
<pre><code class="language-python">f &quot;aa&quot; = ...
f 1 = ...
# `f x = ... ` is invalid
f x: Int or Str = ...
</code></pre>
<p>Also, like <code>match</code>, it must also be exhaustive.</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
# PatternError: pattern of fib's parameter is not exhaustive
</code></pre>
<p>However, it can be made exhaustive by explicitly specifying the type using the <a href="./type/12_refinement.html">refinement type</a> described later.</p>
<pre><code class="language-python">fib: 0..1 -&gt; 0..1
fib 0 = 0
fib 1 = 1
# OK
</code></pre>
<h2 id="recursive-functions"><a class="header" href="#recursive-functions">Recursive functions</a></h2>
<p>A recursive function is a function that includes itself in its definition.</p>
<p>As a simple example, let us define a function <code>factorial</code> that performs a factorial calculation. Factorial is a computation that &quot;multiplies all positive numbers less than or equal to&quot;.
The factorial of 5 is <code>5*4*3*2*1 == 120</code>.</p>
<pre><code class="language-python">factorial 0 = 1
factorial 1 = 1
factorial(n: Nat): Nat = n * factorial(n - 1)
</code></pre>
<p>First, from the definition of factorial, the factorial of 0 and 1 are both 1.
In turn, the factorial of 2 is <code>2*1 == 2</code>, the factorial of 3 is <code>3*2*1 == 6</code>, and the factorial of 4 is <code>4*3*2*1 == 24</code>.
If we look closely, we can see that the factorial of a number n is the factorial of the preceding number n-1 multiplied by n.
Putting this into code, we get <code>n * factorial(n - 1)</code>.
Since the definition of <code>factorial</code> contains itself, <code>factorial</code> is a recursive function.</p>
<p>As a reminder, if you do not add a type specification, it is inferred like this.</p>
<pre><code class="language-python">factorial: |T &lt;: Sub(Int, T) and Mul(Int, Int) and Eq(Int)| T -&gt; Int
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial(n - 1)
</code></pre>
<p>However, even if you can reason about it, you should explicitly specify the type of the recursive function. In the example above, a code like <code>factorial(-1)</code> would work, but</p>
<pre><code class="language-python">factorial(-1) == -1 * factorial(-2) == -1 * -2 * factorial(-3) == ...
</code></pre>
<p>and this computation does not stop. Recursive functions must carefully define the range of values or you may end up in an infinite loop.
So the type specification also helps to avoid accepting unexpected values.</p>
<h2 id="compile-time-functions"><a class="header" href="#compile-time-functions">Compile-time functions</a></h2>
<p>A function name begins with an uppercase letter to indicate a compile-time function. User-defined compile-time functions must have all arguments as constants and must specify their types.
Compile-time functions are limited in what they can do. Only constant expressions can be used in compile-time functions, i.e., only some operators (such as quadrature, comparison, and type construction operations) and compile-time functions. Arguments to be passed must also be constant expressions.
In return, the advantage is that the computation can be done at compile time.</p>
<pre><code class="language-python">Add(X, Y: Nat): Nat = X + Y
assert Add(1, 2) == 3

Factorial 0 = 1
Factorial(X: Nat): Nat = X * Factorial(X - 1)
assert Factorial(10) == 3628800

math = import &quot;math&quot;
Sin X = math.sin X # ConstantError: this function is not computable at compile time
</code></pre>
<p>Compile-time functions are also used in polymorphic type definitions.</p>
<pre><code class="language-python">Option T: Type = T or NoneType
Option: Type -&gt; Type
</code></pre>
<h2 id="appendix-function-comparison"><a class="header" href="#appendix-function-comparison">Appendix: Function Comparison</a></h2>
<p>Erg does not define <code>==</code> for functions. This is because there is no structural equivalence algorithm for functions in general.</p>
<pre><code class="language-python">f = x: Int -&gt; (x + 1)**2
g = x: Int -&gt; x**2 + 2x + 1

assert f == g # TypeError: cannot compare functions
</code></pre>
<p>Although <code>f</code> and <code>g</code> always return the same result, it is extremely difficult to make that determination. We have to teach algebra to the compiler.
So Erg gives up on function comparisons entirely, and <code>(x -&gt; x) == (x -&gt; x)</code> also results in a compile error. This is a different specification from Python and should be noted.</p>
<pre><code class="language-python"># Python, weird example
f = lambda x: x
assert f == f
assert (lambda x: x) ! = (lambda x: x)
</code></pre>
<h2 id="appendix2--completion"><a class="header" href="#appendix2--completion">Appendix2: ()-completion</a></h2>
<pre><code class="language-python">f x: Object = ...
# will be completed to
f(x: Object) = ...

f a
# will be completed to
f(a)

f a, b # TypeError: f() takes 1 positional argument but 2 were given
f(a, b) # TypeError: f() takes 1 positional argument but 2 were given
f((a, b)) # OK
</code></pre>
<p>The function type <code>T -&gt; U</code> is actually the syntax sugar of <code>(T,) -&gt; U</code>.</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-functions"><a class="header" href="#built-in-functions">Built-in functions</a></h1>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p><code>if</code> is a function that changes processing depending on a condition.</p>
<pre><code class="language-python">result: Option Int = if! Bool.sample!(), do:
    log &quot;True was chosen&quot;
    1
print! result # None (or 1)
</code></pre>
<p><code>.sample!()</code> returns a random set of values. If the return value is true, <code>print! &quot;True&quot;</code> is executed.
You can also specify what to do if the condition is false; the second do block is called the else block.</p>
<pre><code class="language-python">result: Nat = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
print! result # 1 (or 0)
</code></pre>
<p>If the process is a single line, you can omit indentation.</p>
<pre><code class="language-python">result = if Bool.sample!():
    do 1
    do 0
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>You can use <code>for</code> to write a repeating process.</p>
<pre><code class="language-python">match_s(ss: Iterator(Str), pat: Pattern): Option Str =
    for ss, s -&gt;
        if pat.match(s).is_some():
            break s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="operator"><a class="header" href="#operator">operator</a></h1>
<p>Operators are symbols that represent operations. Operands are things to the (left) right of an operator.</p>
<p>Operators are a kind of function, and thus are themselves first-class objects that can be bound to variables. When binding, it is necessary to enclose it with ``.
For <code>+</code> (and <code>-</code>), there are both unary and binary operators, so <code>_+_</code>(binary operation)/<code>+_</code>(unary operation ) must be specified.</p>
<pre><code class="language-python">add = `+` # SyntaxError: specify `_+_` or `+_`
add=`_+_`
assert f(1, 2) == 3
assert f(&quot;a&quot;, &quot;b&quot;) == &quot;ab&quot;

g = `*` # OK, this is binary only
assert g(1, 2) == 2
</code></pre>
<p>Some fundamental operators, called special forms, cannot be bound.</p>
<pre><code class="language-python">def = `=` # SyntaxError: cannot bind `=` operator, this is a special form
# NG: def x, 1
function = `-&gt;` # SyntaxError: cannot bind `-&gt;` operator, this is a special form
# NG: function x, x + 1
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="side-effects-and-procedures"><a class="header" href="#side-effects-and-procedures">Side effects and procedures</a></h1>
<p>We have been neglecting to explain the meaning of the <code>!</code>, but now its meaning will finally be revealed. This <code>!</code> indicates that this object is a &quot;procedure&quot; with a &quot;side-effect&quot;. A procedure is a function with a side-effect.</p>
<pre><code class="language-python">f x = print! x # EffectError: functions cannot be assigned objects with side effects
# hint: change the name to 'f!'
</code></pre>
<p>The above code will result in a compile error. This is because you are using a procedure in a function. In such a case, you must define it as a procedure.</p>
<pre><code class="language-python">p! x = print! x
</code></pre>
<p><code>p!</code>, <code>q!</code>, ... are typical variable names for procedures.
Procedures defined in this way also cannot be used within a function, so side-effects are completely isolated.</p>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Functions and procedures each can be methods. Functional methods can only take immutable references to <code>self</code>, while procedural methods can take mutable references to <code>self</code>.
The <code>self</code> is a special parameter, which in the context of a method refers to the calling object itself. The reference <code>self</code> cannot be assigned to any other variable.</p>
<pre><code class="language-python">C!.
    method ref self =
        x = self # OwnershipError: cannot move out 'self'
        x
</code></pre>
<p>Procedural methods can also take <a href="./18_ownership.html">ownership</a> of <code>self</code>. Remove <code>ref</code> or <code>ref!</code> from the method definition.</p>
<pre><code class="language-python">n = 1
s = n.into(Str) # '1'
n # ValueError: n was moved by .into (line 2)
</code></pre>
<p>Only one procedural methods can have a mutable reference at any given time. In addition, while a mutable reference is taken, no more mutable reference can be taken from the original object. In this sense, <code>ref!</code> causes a side-effect on <code>self</code>.</p>
<p>Note, however, that it is possible to create (immutable/mutable) references from mutable references. This allows recursion and <code>print!</code> of <code>self</code> in procedural methods.</p>
<pre><code class="language-python">T -&gt; T # OK (move)
T -&gt; Ref T # OK (move)
T =&gt; Ref! T # OK (only once)
Ref T -&gt; T # NG
Ref T -&gt; Ref T # OK
Ref T =&gt; Ref!
T -&gt; Ref T # NG
T -&gt; Ref T # OK
T =&gt; Ref!
</code></pre>
<h2 id="appendix-strict-definition-of-side-effects"><a class="header" href="#appendix-strict-definition-of-side-effects">Appendix: Strict definition of side-effects</a></h2>
<p>The rules for whether a code has a side-effect or not are not immediately understandable.
Until you can understand them, we recommend that you leave it to the compiler to define them as functions for the time being, and if an error occurs, add <code>!</code> to treat them as procedures.
However, for those who want to understand the exact specifications of the language, the following is a more detailed explanation of side-effects.</p>
<p>First, it must be stated that the equivalence of return values is irrelevant with respect to side effects in Erg.
There are procedures that for any given <code>x</code> will result in <code>p!(x) == p!(x)</code> (e.g. always return <code>None</code>), and there are functions that will result in <code>f(x) ! = f(x)</code>.</p>
<p>An example of the former is <code>print!</code>, and an example of the latter is the following function.</p>
<pre><code class="language-python">nan _ = Float.NaN
assert nan(1) ! = nan(1)
</code></pre>
<p>There are also objects, such as classes, for which equivalence determination itself is not possible.</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}
assert T == U

C = Class {i = Int}
D = Class {i = Int}
assert C == D # TypeError: cannot compare classes
</code></pre>
<p>Back to the point: the precise definition of &quot;side-effect&quot; in Erg is</p>
<ul>
<li>Accessing mutable external information.</li>
</ul>
<p>&quot;External&quot; generally refers to the outer scope; computer resources that Erg cannot touch and pre-/post-execution information are not included in &quot;external&quot;. &quot;Access&quot; includes reading as well as writing.</p>
<p>As an example, consider the <code>print!</code> procedure. At first glance, <code>print!</code> does not seem to rewrite any variables. But if it were a function, it could rewrite outer variables, for example, with code like this:</p>
<pre><code class="language-python">camera = import &quot;some_camera_module&quot;
ocr = import &quot;some_ocr_module&quot;

n = 0
_ =
    f x = print x # Suppose we could use print as a function
    f(3.141592)
cam = camera.new() # camera faces PC display
image = cam.shot!()
n = ocr.read_num(image) # n = 3.141592
</code></pre>
<p>Think of the <code>camera</code> module as an external library providing an API for a certain camera product, and <code>ocr</code> as a library for OCR (optical character recognition).
The direct side-effect is caused by <code>cam.shot!()</code>, but obviously that information is leaked from <code>f</code>. Therefore, <code>print!</code> cannot be a function by nature.</p>
<p>Nevertheless, there may be cases where you want to temporarily check a value in a function and do not want to add <code>!</code> in the related function just for that purpose. In such cases, the <code>log</code> function can be used.
<code>log</code> prints the value after the entire code has been executed. In this way, side-effects are not propagated.</p>
<pre><code class="language-python">log &quot;this will be printed after execution&quot;
print! &quot;this will be printed immediately&quot;
# this will be printed immediately
# this will be printed after execution
</code></pre>
<p>If there is no feedback to the program, or in other words, if no external object can use the internal information, then the &quot;leakage&quot; of the information may be allowed. It is only necessary that the information not be &quot;propagated&quot;.</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="procedures"><a class="header" href="#procedures">Procedures</a></h1>
<p>Procedures are necessary when dealing with mutable objects, but having a mutable object as an argument does not necessarily make it a procedure.
Here is a function takes a mutable object (not procedure).</p>
<pre><code class="language-python">peek_str s: Str! = log s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="built-in-procedure"><a class="header" href="#built-in-procedure">Built-in procedure</a></h1>
<h2 id="id"><a class="header" href="#id">id!</a></h2>
<p>Returns the unique identification number of the object.
Although in pure Erg semantics no difference can be found between objects with the same structure, in practice objects have different locations in memory.
<code>id!</code> returns a number representing this position.</p>
<pre><code class="language-python"></code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>Arrays are the most basic <strong>collection (aggregate)</strong>.
A collection is an object that can hold multiple objects inside it.</p>
<pre><code class="language-python">a = [1, 2, 3]
a: [Int; 3] # Type specification: number after semicolon is the number of elements
# Can be omitted if the number of elements is not known
a: [Int]

mut_a = [!1, !2, !3]
mut_a[0].inc!()
assert mut_a == [2, 2, 3]
</code></pre>
<p>As a rule, arrays cannot contain objects of different types.</p>
<pre><code class="language-python.">[1, &quot;a&quot;] # TypeError: 1st element is Int, but 2nd element is Str
</code></pre>
<p>However, you can bypass the restriction by explicitly specifying the type like this.</p>
<pre><code class="language-python">[1, &quot;a&quot;]: [Int or Str].
</code></pre>
<h2 id="slice"><a class="header" href="#slice">Slice</a></h2>
<p>An array can also have multiple values taken out at once. This is called slicing.</p>
<pre><code class="language-python">l = [1, 2, 3, 4]
# Same as l[1:3] in Python
assert l[1.. &lt;3] == [2, 3]
assert l[1..2] == [2, 3]
# Same as l[1]
assert l[1..1] == [2]
# Same as l[::2] in Python
assert l[..].step(2) == [2, 4]
</code></pre>
<p>The object obtained by slicing is an (immutable) copy to an array.</p>
<pre><code class="language-python">print! Typeof l[1..2] # [Int; 4]
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<p>Tuples are similar to arrays, but can hold objects of different types.
Such a collection is called an unequal collection. In contrast, homogeneous collections include arrays, sets, etc.</p>
<pre><code class="language-python">t = (1, True, &quot;a&quot;)
(i, b, s) = t
assert(i == 1 and b == True and s == &quot;a&quot;)
</code></pre>
<p>The tuple <code>t</code> can retrieve the nth element in the form <code>t.n</code>; note that unlike Python, it is not <code>t[n]</code>.
This is because accessing tuple elements is more like an attribute (the existence of the element is checked at compile time, and the type can change depending on <code>n</code>) than a method (an array's <code>[]</code> is a method).</p>
<pre><code class="language-python">assert t.0 == 1
assert t.1 == True
assert t.2 == &quot;a&quot;
</code></pre>
<p>Parentheses <code>()</code> are optional when not nested.</p>
<pre><code class="language-python">t = 1, True, &quot;a&quot;
i, b, s = t
</code></pre>
<p>Tuples can hold objects of different types, so they cannot be iterated like arrays.</p>
<pre><code class="language-python">t: ({1}, {2}, {3}) = (1, 2, 3)
(1, 2, 3).iter().map(x -&gt; x + 1) # TypeError: type ({1}, {2}, {3}) has no method `.iter()`
# If all types are the same, they can be represented by `(T; n)` like arrays, but this still does not allow iteration
t: (Int; 3) = (1, 2, 3)
assert (Int; 3) == (Int, Int, Int)
</code></pre>
<p>However, nonhomogeneous collections (such as tuples) can be converted to homogeneous collections (such as arrays) by upcasting, intersecting, and so on.
This is called equalization.</p>
<pre><code class="language-python">(Int, Bool, Str) can be [T; 3] where T :&gt; Int, T :&gt; Bool, T :&gt; Str
</code></pre>
<pre><code class="language-python">t: (Int, Bool, Str) = (1, True, &quot;a&quot;) # non-homogenous
a: [Int or Bool or Str; 3] = [1, True, &quot;a&quot;] # homogenous
_a: [Show; 3] = [1, True, &quot;a&quot;] # homogenous
_a.iter().map(x -&gt; log x) # OK
t.try_into([Show; 3])? .iter().map(x -&gt; log x) # OK
</code></pre>
<h2 id="unit"><a class="header" href="#unit">Unit</a></h2>
<p>A tuple with zero elements is called a <strong>unit</strong>. A unit is a value, but also refers to its own type.</p>
<pre><code class="language-python">unit = ()
(): ()
</code></pre>
<p>Unit is a superclass of all element 0 tuples.</p>
<pre><code class="language-python">() &gt; (Int; 0)
() &gt; (Str; 0)
</code></pre>
<p>The use of this object is for procedures with no arguments and no return value, etc. Erg subroutines must have arguments and a return value. However, in some cases, such as a procedure, there may be no meaningful arguments or return value, only side effects. In such cases, we use units as &quot;meaningless, formal values.</p>
<pre><code class="language-python"># ↓ Actually, this parenthesis is a unit
p!() =.
    # `print!` does not return a meaningful value
    print! &quot;Hello, world!&quot;
p!: () =&gt; ()
</code></pre>
<p>However, Python tends to use <code>None</code> instead of units in such cases.
In Erg, you should use <code>()</code> when you are sure from the beginning that the operation will not return a meaningful value, such as in a procedure, and return <code>None</code> when there is a possibility that the operation will fail and you will get nothing, such as when retrieving an element.</p>
<h2 id="arguments-and-tuple"><a class="header" href="#arguments-and-tuple">Arguments and Tuple</a></h2>
<p>Actually, all of Erg's <code>Callable</code> objects are one argument and one return value; a subroutine that takes N arguments was just receiving &quot;one tuple with N elements&quot; as an argument.</p>
<pre><code class="language-python"># f x = ... is implicitly assumed to be f(x) = ... is considered to be
f x = x
assert f(1) == 1
f(1, 2, 3) # ArgumentError: f takes 1 positional argument but 3 were given
# ArgumentError: f takes 1 positional argument but 3 were given
g x: Int, . . y: Int = y
assert (2, 3) == g 1, 2, 3
</code></pre>
<p>This also explains the function type.</p>
<pre><code class="language-python">assert f in T: {(T,) -&gt; T | T}
assert g in {(Int, ... (Int; N)) -&gt; (Int; N) | N: Nat}
</code></pre>
<p>To be precise, the function's input is not a tuple but a &quot;Named tuple with default attributes&quot;. This is a special tuple that can only be used in function arguments, can be named like a record, and can have a default value.</p>
<pre><code class="language-python">f(x: Int, y=0) = x + y
f: (Int, y=Int) -&gt; Int

f(x=0, y=1)
f(y=1, x=0)
f(x=0)
f(0)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="dict"><a class="header" href="#dict">Dict</a></h1>
<p>Dict is a collection of key/value pairs.</p>
<pre><code class="language-python">ids = {&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301}
assert ids[&quot;Alice&quot;] == 145
</code></pre>
<p>The key does not have to be a string if it is a <code>Hash</code> object.</p>
<pre><code class="language-python"># deprecated to use a range object as a key (confused with slice)
r = {1..3: &quot;1~3&quot;, 4..6: &quot;4~6&quot;, 7..9: &quot;7~9&quot;}
assert r[1..3] == &quot;1~3&quot;
l = {[]: &quot;empty&quot;, [1]: &quot;1&quot;}
assert l[[]] == &quot;empty&quot;
</code></pre>
<p>Order does not matter for Dict. It also cannot have duplicate elements. In this respect, Dict is similar to Set.
You could say that a Dict is a Set with values.</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301} == {&quot;Alice&quot;: 145, &quot;Charlie&quot;: 301, &quot;Bob&quot;: 214}
</code></pre>
<p>When generating a dict from a dict literal, it is checked for duplicate keys.
Any duplicates will result in a compile error.</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Alice&quot;: 1} # KeyError: Duplicate key &quot;Alice&quot;
</code></pre>
<p>Empty Dict is created with <code>{:}</code>. Note that <code>{}</code> denotes an empty set.</p>
<pre><code class="language-python">mut_dict = !{:}
mut_dict.insert! &quot;Alice&quot;, 145
mut_dict.insert! &quot;Bob&quot;, 214
assert mut_dict[&quot;Alice&quot;] == 145
</code></pre>
<h2 id="heterogeneous-dict"><a class="header" href="#heterogeneous-dict">Heterogeneous Dict</a></h2>
<p>There need not be a single key/value type. Such a dictionary is called a _<em>heterogenous dict</em>.</p>
<pre><code class="language-python">d: {Str: Int, Int: Str} = {&quot;a&quot;: 1, 1: &quot;a&quot;}
assert d[&quot;a&quot;] == 1
assert d[1] == &quot;a&quot;
</code></pre>
<p>However, it is not possible to assign values of the same type to keys of different types, or values of different types to keys of the same type.
In such cases, use the type Or instead.</p>
<pre><code class="language-python">invalid1 = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
invalid2 = {1: &quot;a&quot;, 2: 2}

# Erg type inference does not infer Or type, so type specification is required
valid1: {Int or Str: Str} = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
valid2: {Int: Int or Str} = {1: &quot;a&quot;, 2: 2}
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="record"><a class="header" href="#record">Record</a></h1>
<p>A record is a collection that combines the properties of a Dict accessed by key and a tuple whose access is inspected at compile time.
If you know JavaScript, think of it as a (more enhanced) kind of object literal notation.</p>
<pre><code class="language-python">john = {.name = &quot;John&quot;; .age = 21}

assert john.name == &quot;John&quot;
assert john.age == 21
assert john in {.name = Str; .age = Nat}
john[&quot;name&quot;] # Error: john is not subscribable
</code></pre>
<p>The <code>.name</code> and <code>.age</code> parts are called attributes, and the <code>&quot;John&quot;</code> and <code>21</code> parts are called attribute values.</p>
<p>The difference from JavaScript object literals is that they are not accessible as strings. That is, attributes are not just strings.
This is because access to the value is determined at compile-time, and because dictionaries and records are different things. In other words, <code>{&quot;name&quot;: &quot;John&quot;}</code> is a Dict and <code>{name = &quot;John&quot;}</code> is a record.
So how should we use dictionaries and records?
In general, we recommend using records. Records have the advantages of being checked at compile-time for the existence of elements and of being able to specify _<em>visibility</em>.
Specifying visibility is equivalent to specifying public/private in Java and other languages. For details, see <a href="./19_visibility.html">visibility</a> for details.</p>
<pre><code class="language-python">a = {x = 1; .y = x + 1}
a.x # AttributeError: x is private
# Hint: declare as `.x`.
assert a.y == 2
</code></pre>
<p>The above example may seem strange to someone familiar with JavaScript, but simply declaring <code>x</code> makes it inaccessible from the outside. <code>. </code>. `.</p>
<p>You can also explicitly specify the type of an attribute.</p>
<pre><code class="language-python">anonymous = {
    .name: Option! Str = !
    .age = 20
}
anonymous.name.set! &quot;John&quot;
</code></pre>
<p>A record can also have the method.</p>
<pre><code class="language-python">o = {
    .i = !0
    .inc! ref! self = self.i.inc!()
}

assert o.i == 0
o.inc!()
assert o.i == 1
</code></pre>
<p>There is a notable syntax with respect to records. When all the attribute values of a record are classes (not structural types), the record itself behaves as a type with its own attributes as required attributes.
Such a type is called a record type. See the section [Record] for more details.</p>
<pre><code class="language-python"># record
john = {.name = &quot;John&quot;}
# record type
john: {.name = Str}
Named = {.name = Str}
john: Named

greet! n: Named =
    print! &quot;Hello, I am {n.name}&quot;
john # &quot;Hello, I am John&quot; print!

Named.name # Str
</code></pre>
<h2 id="deconstructing-a-record"><a class="header" href="#deconstructing-a-record">Deconstructing a record</a></h2>
<p>Records can be deconstructed as follows.</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x = a; y = b} = record
assert a == 1
assert b == 2

point = {x = 2; y = 3; z = 4}
match point:
    {x = 0; y = 0; z = 0} -&gt; &quot;origin&quot;
    {x = _; y = 0; z = 0} -&gt; &quot;on the x axis&quot;
    {x = 0; ...} -&gt; &quot;x = 0&quot;
    {x = x; y = y; z = z} -&gt; &quot;({x}, {y}, {z})&quot;
</code></pre>
<p><code>x = ...</code> can also be abbreviated to <code>x</code> when there is a variable with the same name as the attribute, for example, <code>x = x</code> or <code>x = .x</code> to <code>x</code>, and <code>.x = .x</code> or <code>.x = x</code> to <code>.x</code>.
However, when there is only one attribute, it must be followed by <code>;</code> to distinguish it from a set.</p>
<pre><code class="language-python">x = 1
y = 2
xy = {x; y}
a = 1
b = 2
ab = {.a; .b}
assert ab.a == 1
assert ab.b == 2

record = {x;}
tuple = {x}
assert tuple.1 == 1
</code></pre>
<p>This syntax can be used to deconstructed a record and assign it to a variable.</p>
<pre><code class="language-python"># same as `{x = x; y = y} = xy`
{x; y} = xy
assert x == 1
assert y == 2
# same as `{.a = a; .b = b} = ab`
{a; b} = ab
assert a == 1
assert b == 2
</code></pre>
<h2 id="empty-record"><a class="header" href="#empty-record">Empty Record</a></h2>
<p>An empty record is represented by <code>{=}</code>. An empty record is also its own class, like Unit.</p>
<pre><code class="language-python">empty_record = {=}
empty_record: {=}
# Object: Type = {=}
empty_record: Object
empty_record: Structural {=}
{x = 3; y = 5}: Structural {=}
</code></pre>
<p>An empty record is different from an empty Dict <code>{:}</code> or empty set <code>{}</code>. In particular, note that it is the opposite of <code>{}</code> in meaning (in Python, <code>{}</code> is an empty dictionary, while in Erg it is <code>!{:}</code> in Erg).
As an enumerated type, <code>{}</code> is an empty type that contains nothing in its elements. The <code>Never</code> type is a classification of this type.
Conversely, the record class <code>{=}</code> has no required instance attribute, so all objects are elements of it. An <code>Object</code> is an alias of this.
An <code>Object</code> (a patch of <code>Object</code>) is an element of <code>. __sizeof__</code> and other very basic provided methods.</p>
<pre><code class="language-python">AnyPatch = Patch Structural {=}
    . __sizeof__ self = ...
    .clone self = ...
    ...
Never = Class {}
</code></pre>
<p>Note that no other type or class can be structurally equivalent to the <code>{}</code>, <code>Never</code> type, and it is an error if the user defines a type with <code>{}</code>, <code>Class {}</code> on the right side.
This means that, for example, <code>1..10 or -10. -1</code>, but <code>1..10 and -10... -1</code>. <code>-1</code> when it should be <code>1..10 or -10...-1</code>, for example.
Also, if you define a type (such as <code>Int and Str</code>) that results in a composition <code>Object</code>, you will be warned to simply set it to <code>Object</code>.</p>
<h2 id="instant-block"><a class="header" href="#instant-block">Instant Block</a></h2>
<p>Erg has another syntax, instant block, which simply returns the last value evaluated. Attributes cannot be retained.</p>
<pre><code class="language-python">x =
    x = 1
    y = x + 1
    y ** 3
assert x == 8

y =
    .x = 1 # SyntaxError: cannot define an attribute in an entity block
</code></pre>
<h2 id="data-class"><a class="header" href="#data-class">Data Class</a></h2>
<p>A bare record (a record generated by a record literal) must be defined directly in the instance if you try to implement a method on its own.
This is inefficient, and as the number of attributes increases, error messages and the like become difficult to see and use.</p>
<pre><code class="language-python">john = {
    name = &quot;John Smith&quot;
    age = !20
    .greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    .inc_age! ref! self = self::age.update! x -&gt; x + 1
}
john + 1
# TypeError: + is not implemented for {name = Str; age = Int; .greet! = Ref(Self). () =&gt; None; inc_age! = Ref! () =&gt; None}, Int
</code></pre>
<p>So, in such a case, you can inherit a record class. Such a class is called a data class.
This is described in <a href="./type/04_class.html">class</a>.</p>
<pre><code class="language-python">Person = Inherit {name = Str; age = Nat}
Person.
    greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    inc_age! ref! self = self::age.update! x -&gt; x + 1

john = Person.new {name = &quot;John Smith&quot;; age = 20}
john + 1
# TypeError: + is not implemented for Person, Int
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p>A set represents a collection, which is structurally a duplicate, unordered array.</p>
<pre><code class="language-python">assert Set.from([1, 2, 3, 2, 1]) == {1, 2, 3}
assert {1, 2} == {1, 1, 2} # duplicates are automatically removed
assert {1, 2} == {2, 1}
</code></pre>
<p>Sets can be declared by specifying type and length.</p>
<pre><code class="language-python">a: {Int; 3} = {0, 1, 2} # OK
b: {Int; 3} = {0, 0, 0} # NG, Duplicates are deleted, and the length changes.
#[
TypeError: the type of b is mismatched
expected:  Set(Int, 3)
but found: Set({0, }, 1)
]#
</code></pre>
<p>In addition, only objects that implement the <code>Eq</code> trait can be elements of the Set.</p>
<p>Therefore, it is not possible to use the Set elements such as a Float.</p>
<pre><code class="language-python">d = {0.0, 1.0} # NG
#[
1│ d = {0.0, 1.0}
        ^^^^^^^^
TypeError: the type of _ is mismatched:
expected:  Eq(Float)
but found: {0.0, 1.0, }
]#
</code></pre>
<p>Sets can perform set operations.</p>
<pre><code class="language-python">assert 1 in {1, 2, 3}
assert not 1 in {}
assert {1} or {2} == {1, 2}
assert {1, 2} and {2, 3} == {2}
assert {1, 2} not {2} == {1}
</code></pre>
<p>A set is a homogeneous collection. In order for objects of different classes to coexist, they must be homogenized.</p>
<pre><code class="language-python">s: {Int or Str} = {&quot;a&quot;, 1, &quot;b&quot;, -1}
</code></pre>
<h2 id="sets-as-types"><a class="header" href="#sets-as-types">Sets as types</a></h2>
<p>Sets can also be treated as types. Such types are called <strong>Enum types</strong>.</p>
<pre><code class="language-python">i: {1, 2, 3} = 1
assert i in {1, 2, 3}
</code></pre>
<p>Elements of the set are directly elements of the type.
Note that the sets themselves are different.</p>
<pre><code class="language-python">mut_set = {1, 2, 3}.into {Int; !3}
mut_set.insert!(4)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">types</a></h1>
<p>Types are a very important feature in Erg, so we have a <a href="./type/01_type_system.html">dedicated section</a>. Please see there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ergs-type-system"><a class="header" href="#ergs-type-system">Erg's Type System</a></h1>
<p>The following is a brief description of Erg's type system. Details are explained in other sections.</p>
<h2 id="how-to-define"><a class="header" href="#how-to-define">How to define</a></h2>
<p>One of the unique features of Erg is that there is not much difference in syntax between (normal) variable, function (subroutine), and type (Kind) definitions. All are defined according to the syntax of normal variable and function definitions.</p>
<pre><code class="language-python">f i: Int = i + 1
f # &lt;function f&gt;
f(1) # 2
f.method self = ... # SyntaxError: cannot define a method to a subroutine

T I: Int = {...}
T # &lt;kind 'T'&gt;
T(1) # Type T(1)
T.method self = ...
D = Class {private = Int; .public = Int}
D # &lt;class 'D'&gt;
o1 = {private = 1; .public = 2} # o1 is an object that does not belong to any class
o2 = D.new {private = 1; .public = 2} # o2 is an instance of D
o2 = D.new {.public = 2} # InitializationError: class 'D' requires attribute 'private'(: Int) but not defined
</code></pre>
<h2 id="classification"><a class="header" href="#classification">Classification</a></h2>
<p>All objects in Erg are strongly typed.
The top-level type is <code>{=}</code>, which implements <code>__repr__</code>, <code>__hash__</code>, <code>clone</code>, etc. (not required methods, and these attributes cannot be overridden).
Erg's type system incorporates structural subtyping (SST). The types typed by this system are called Structural types.
There are three major types of structural types: Attributive (attribute type), Refinement (refinement type), and Algebraic (algebraic type).</p>
<table><thead><tr><th></th><th>Record</th><th>Enum</th><th>Interval</th><th>Union</th><th>Intersection</th><th>Diff</th></tr></thead><tbody>
<tr><td>kind</td><td>Attributive</td><td>Refinement</td><td>Refinement</td><td>Algebraic</td><td>Algebraic</td><td>Algebraic</td></tr>
<tr><td>generator</td><td>record</td><td>set</td><td>range operator</td><td>or operator</td><td>and operator</td><td>not operator</td></tr>
</tbody></table>
<p>Nominal subtyping (NST) can also be used, and the conversion of an SST type to an NST type is called nominalization of the type. The resulting type is called a nominal type.
In Erg, the nominal types are classes and traits. When we simply say class/trait, we often mean record class/trait.</p>
<table><thead><tr><th></th><th>Type</th><th>Abstraction</th><th>Subtyping procedure</th></tr></thead><tbody>
<tr><td>NST</td><td>NominalType</td><td>Trait</td><td>Inheritance</td></tr>
<tr><td>SST</td><td>StructuralType</td><td>Structural Trait</td><td>(Implicit)</td></tr>
</tbody></table>
<p>The type for the entire nominal type (<code>NominalType</code>) and the type for the entire structural type (<code>StructuralType</code>) are subtypes of the type for the entire type (<code>Type</code>).</p>
<p>Erg can pass arguments (type arguments) to the type definition. An <code>Option</code>, <code>Array</code>, etc. with type arguments are called a polynomial kind. These are not themselves types, but they become types by applying arguments. Types such as <code>Int</code>, <code>Str</code>, etc., which have no arguments, are called simple types (scalar types).</p>
<p>A type can be regarded as a set, and there is an inclusion relation. For example, <code>Num</code> contains <code>Add</code>, <code>Sub</code>, etc., and <code>Int</code> contains <code>Nat</code>.
The upper class of all classes is <code>Object == Class {:}</code> and the lower class of all types is <code>Never == Class {}</code>. This is described below.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>A type like <code>Array T</code> can be regarded as a function of type <code>Type -&gt; Type</code> that takes type <code>T</code> as an argument and returns type <code>Array T</code> (also called Kind in type theory). Types like <code>Array T</code> are specifically called polymorphic types, and <code>Array</code> itself is called unary Kind.</p>
<p>The type of a function whose argument and return types are known is denoted as <code>(T, U) -&gt; V</code>. If you want to specify an entire two-argument function of the same type, you can use <code>|T| (T, T) -&gt; T</code>, and if you want to specify an entire N-argument function, you can use <code>Func N</code>. However, the <code>Func N</code> type has no information about the number of arguments or their types, so all return values are of type <code>Obj</code> when called.</p>
<p>The <code>Proc</code> type is denoted as <code>() =&gt; Int</code> and so on. Also, the name of the <code>Proc</code> type instance must end with <code>!</code> at the end.</p>
<p>A <code>Method</code> type is a function/procedure whose first argument is the object <code>self</code> to which it belongs (by reference). For dependent types, you can also specify the type of yourself after the method is applied. This is <code>T!(!N)</code> type and <code>T!(N ~&gt; N-1). () =&gt; Int</code> and so on.</p>
<p>Erg's array (Array) is what Python calls a list. <code>[Int; 3]</code> is an array class that contains three objects of type <code>Int</code>.</p>
<blockquote>
<p><strong>Note</strong>: <code>(Type; N)</code> is both a type and a value, so it can be used like this.</p>
<pre><code class="language-python.">Types = (Int, Str, Bool)

for! Types, T =&gt;
    print! T
# Int Str Bool
a: Types = (1, &quot;aaa&quot;, True)
</code></pre>
</blockquote>
<pre><code class="language-python">pop|T, N|(l: [T; N]): ([T; N-1], T) =
    [...l, last] = l
    (l, last)

lpop|T, N|(l: [T; N]): (T, [T; N-1]) =
    [first, ...l] = l
    (first, l)
</code></pre>
<p>A type ends with <code>!</code> can be rewritten internal structure. For example, the <code>[T; !N]</code> class is a dynamic array.
To create an object of type <code>T!</code> from an object of type <code>T</code>, use the unary operator <code>!</code>.</p>
<pre><code class="language-python">i: Int! = !1
i.update! i -&gt; i + 1
assert i == 2
arr = [1, 2, 3]
arr.push! 4 # ImplError:
mut_arr = [1, 2, 3].into [Int; !3]
mut_arr.push4
assert mut_arr == [1, 2, 3, 4].
</code></pre>
<h2 id="type-definitions"><a class="header" href="#type-definitions">Type Definitions</a></h2>
<p>Types are defined as follows.</p>
<pre><code class="language-python">Point2D = {.x = Int; .y = Int}
</code></pre>
<p>Note that if <code>.</code> is omitted from a variable, it becomes a private variable used within the type. However, this is also a required attribute.
Since types are also objects, there are attributes on the types themselves. Such attributes are called type attributes. In the case of a class, they are also called class attributes.</p>
<h2 id="data-type"><a class="header" href="#data-type">Data type</a></h2>
<p>As mentioned earlier, a &quot;type&quot; in Erg roughly means a set of objects.</p>
<p>The following is a definition of the <code>Add</code> type, which requires <code>+</code> (the middle operator). <code>R, O</code> are the so-called type parameters, which can be a true type (class) such as <code>Int</code> or <code>Str</code>. In other languages, type parameters are given a special notation (generics, templates, etc.), but in Erg they can be defined just like normal parameters.
Type parameters can also be used for types other than type objects. For example, the array type <code>[Int; 3]</code> is a syntax sugar for <code>Array Int, 3</code>. If the type implementations overlap, the user must explicitly choose one.</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}
</code></pre>
<p>.<code>_+_</code> is an abbreviation for Add.<code>_+_</code>. The prefix operator .<code>+_</code> is a method of type <code>Num</code>.</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
NumImpl = Patch Num
NumImpl.
    `+_`(self): Self = self
    ...
</code></pre>
<p>Polymorphic types can be treated like functions. They can be monomorphic by specifying them as <code>Mul Int, Str</code>, etc. (in many cases, they are inferred with real arguments without specifying them).</p>
<pre><code class="language-python">1 + 1
`_+_` 1, 1
Nat.`_+_` 1, 1
Int.`_+_` 1, 1
</code></pre>
<p>The top four lines return the same result (to be exact, the bottom one returns <code>Int</code>), but it is common to use the top one.
<code>Ratio.`_+_`(1, 1)</code> will return <code>2.0</code> without error.
This is because <code>Int &lt;: Ratio</code>, so <code>1</code> is downcast to <code>Ratio</code>.
But this is not cast.</p>
<pre><code class="language-python">i = 1
if i: # TypeError: i: Int cannot be cast to Bool, use Int.is_zero() instead.
    log &quot;a&quot;
    log &quot;b&quot;
</code></pre>
<p>This is because <code>Bool &lt;: Int</code> (<code>True == 1</code>, <code>False == 0</code>). Casts to subtypes generally require validation.</p>
<h2 id="type-inference-system"><a class="header" href="#type-inference-system">Type Inference System</a></h2>
<p>Erg uses static duck typing, so there is little need to explicitly specify the type.</p>
<pre><code class="language-python">f x, y = x + y
</code></pre>
<p>In the case of the code above, the type with <code>+</code>, i.e., <code>Add</code> is automatically inferred; Erg first infers the smallest type. If <code>f 0, 1</code>, it will infer <code>f x: {0}, y: {1}</code>, if <code>n: Nat; f n, 1</code>, it will infer <code>f x: Nat, y: {1}</code>. After minimization, the type is increased until an implementation is found. In the case of <code>{0}, {1}</code>, <code>Nat</code> is monomorphic to <code>Nat</code> since <code>Nat</code> is the smallest type with a <code>+</code> implementation.
If <code>{0}, {-1}</code>, it is monomorphic to <code>Int</code> since it does not match <code>Nat</code>. If there is no relationship between subtypes and supertypes, the one with the lowest concentration (number of instances) (or even fewer arguments in the case of polymorphic types) is tried first.
<code>{0}</code> and <code>{1}</code> are enumerated types that are partial types such as <code>Int</code> and <code>Nat</code>.
Enumerated types, for example, can be given names and request/implementation methods. In namespaces that have access to that type, objects that satisfy the request can use the implementation method.</p>
<pre><code class="language-python">Binary = Patch {0, 1}
Binary.
    # self contains an instance. In this example, either 0 or 1.
    # If you want to rewrite self, you must append ! must be added to the type name and method name.
    is_zero(self) = match self:
        0 -&gt; True
        1 -&gt; False # You can also use _ -&gt; False
    is_one(self) = not self.is_zero()
    to_bool(self) = match self:
        0 -&gt; False
        1 -&gt; True
</code></pre>
<p>Thereafter, the code <code>0.to_bool()</code> is possible (although <code>0 as Bool == False</code> is defined built-in).
Here is an example of a type that can actually rewrite <code>self</code> as shown in the code.</p>
<pre><code class="language-python">Binary! = Patch {0, 1}!
Binary!
    switch! ref! self = match! self:
        0 =&gt; self = 1
        1 =&gt; self = 0

b = !1
b.switch!()
print! b # =&gt; 0
</code></pre>
<h2 id="structure-type-anonymous-type"><a class="header" href="#structure-type-anonymous-type">Structure type (anonymous type)</a></h2>
<pre><code class="language-python">Binary = {0, 1}
</code></pre>
<p><code>Binary</code> in the above code is a type whose elements are <code>0</code> and <code>1</code>. It is also a subtype of the <code>Int</code> type, which has both <code>0</code> and <code>1</code>.
An object like <code>{}</code> is itself a type and can be used with or without assignment to a variable as above.
Such types are called structural types. When we want to emphasize its use as the latter in contrast to a class (named type), it is also called an unnamed type. A structural type such as <code>{0, 1}</code> is called an enumerated type, and there are also interval types, record types, and so on.</p>
<h3 id="type-identity"><a class="header" href="#type-identity">Type Identity</a></h3>
<p>The following cannot be specified. For example, you cannot specify <code>Int</code> and <code>Int</code> and <code>Int</code> and <code>Int</code> and <code>Int</code> and <code>Int</code>.
For example, <code>Int</code> and <code>Str</code> are both <code>Add</code>, but <code>Int</code> and <code>Str</code> cannot be added.</p>
<pre><code class="language-python">add l: Add, r: Add =
    l + r # TypeError: there is no implementation of `_+_`: |T, U &lt;: Add| (T, U) -&gt; &lt;Failure&gt;
</code></pre>
<p>Also, the types <code>A</code> and <code>B</code> below are not considered the same type. However, the type <code>O</code> is considered to match.</p>
<pre><code class="language-python">... |R1; R2; O; A &lt;: Add(R1, O); B &lt;: Add(R2, O)|
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-syntax-for-types"><a class="header" href="#basic-syntax-for-types">Basic syntax for types</a></h1>
<h2 id="type-specification"><a class="header" href="#type-specification">Type specification</a></h2>
<p>In Erg, the type of a variable can be specified after <code>:</code> as follows. This can be done at the same time as an assignment.</p>
<pre><code class="language-python">i: Int # Declare the variable i to be of type Int
i: Int = 1
j = 1 # type specification can be omitted
</code></pre>
<p>You can also specify a type for ordinary expressions.</p>
<pre><code class="language-python">i = 1: Int
f([1, &quot;a&quot;]: [Int or Str])
</code></pre>
<p>For simple variable assignments, most type specifications can be omitted.
Type specifications are more useful when defining subroutines and types.</p>
<pre><code class="language-python"># Type specification for parameters
f x, y: Array Int = ...
T X, Y: Array Int = ...
</code></pre>
<p>Note that in the above case, <code>x, y</code> are both <code>Array Int</code>.</p>
<pre><code class="language-python"># The value of a capital variable must be a constant expression
f X: Int = X
</code></pre>
<p>Alternatively, if you don't need complete information about the type argument, you can omit it with <code>_</code>.</p>
<pre><code class="language-python">g v: [T; _] = ...
</code></pre>
<p>Note, however, <code>_</code> at a type specification implies <code>Object</code>.</p>
<pre><code class="language-python">f x: _, y: Int = x + y # TypeError: + is not implemented between Object and Int
</code></pre>
<h2 id="subtype-specification"><a class="header" href="#subtype-specification">Subtype specification</a></h2>
<p>In addition to the <code>:</code> (type declaration operator), Erg also allows you to specify the relationship between types by using <code>&lt;:</code> (partial type declaration operator).
The left side of <code>&lt;:</code> can only specify a class. Use <code>Subtypeof</code> or similar operators to compare structural types.</p>
<p>This is also often used when defining subroutines or types, rather than simply specifying variables.</p>
<pre><code class="language-python"># Subtype specification of an argument
f X &lt;: T = ...

# Subtype specification of the required attribute (.Iterator attribute is required to be a subtype of type Iterator)
Iterable T = Trait {
    .Iterator = {Iterator} # {Iterator} == {I: Type | I &lt;: Iterator}
    .iter = Self.() -&gt; Self.Iterator T
    ...
}
</code></pre>
<p>You can also use a subtype specification when defining a class to statically check whether the class is a subtype of the specified type.</p>
<pre><code class="language-python"># Class C is a subtype of Show
C = Class Object, Impl := Show
C.show self = ... # Show's required attributes.
</code></pre>
<p>You can also specify a subtype only in specific cases.</p>
<pre><code class="language-python">K T: Eq
K Int &lt;: Show and Eq
K T = Class Object
K(T).
    `==` self, other = ...
K(Int).
    show self = ...
</code></pre>
<p>Subtype specification is recommended when implementing structural types.
This is because, due to the nature of structural subtyping, typo or type specification errors will not cause errors when implementing required attributes.</p>
<pre><code class="language-python">C = Class Object
C.shoe self = ... # Show is not implemented due to Typo (it is considered just a unique method).
</code></pre>
<h2 id="attribute-definitions"><a class="header" href="#attribute-definitions">Attribute definitions</a></h2>
<p>Attributes can be defined for traits and classes only in modules.</p>
<pre><code class="language-python">C = Class()
C.pub_attr = &quot;this is public&quot;
C::private_attr = &quot;this is private&quot;

c = C.new()
assert c.pub_attr == &quot;this is public&quot;
</code></pre>
<p>The syntax for defining a batch definition is called a batch definition, in which a newline is added after <code>C.</code> or <code>C::</code> and the definitions are grouped together below the indentation.</p>
<pre><code class="language-python">C = Class()
C.pub1 = ...
C.pub2 = ...
C::priv1 = ...
C::priv2 = ...
# is equivalent to
C = Class()
C.
    pub1 = ...
    C. pub2 = ...
C::
    priv1 = ...
    priv2 = ...
</code></pre>
<h2 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h2>
<p>Types can be aliased. This allows long types, such as record types, to be shortened.</p>
<pre><code class="language-python">Id = Int
Point3D = {x = Int; y = Int; z = Int}
IorS = Int or Str
Vector = Array Int
</code></pre>
<p>Also, when displaying errors, the compiler will use aliases for composite types (in the above example, right-hand-side types other than the first) if they are defined.</p>
<p>However, only one alias of the same type is allowed per module, and multiple aliases will result in a warning.
This means that types with different purposes should be defined as separate types.
The purpose is also to prevent adding aliases on top of types that already have aliases.</p>
<pre><code class="language-python">Id = Int
UserId = Int # TypeWarning: duplicate aliases: Id and UserId

Ids = Array Id
Ints = Array Int # TypeWarning: duplicate aliases: Isd and Ints

IorS = Int or Str
IorSorB = IorS or Bool
IorSorB_ = Int or Str or Bool # TypeWarning: duplicate aliases: IorSorB and IorSorB_

Point2D = {x = Int; y = Int}
Point3D = {.... Point2D; z = Int}
Point = {x = Int; y = Int; z = Int} # TypeWarning: duplicate aliases: Point3D and Point
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">Trait</a></h1>
<p>Trait is a nominal type that adds a type attribute requirement to record types.
It is similar to the Abstract Base Class (ABC) in Python, but with the distinction of being able to perform algebraic operations.</p>
<pre><code class="language-python">Norm = Trait {.x = Int; .y = Int; .norm = Self.() -&gt; Int}
</code></pre>
<p>Trait does not distinguish between attributes and methods.</p>
<p>Note that traits can only be declared, not implemented (implementation is achieved by a feature called patching, which will be discussed later).
Traits can be checked for implementation in a class by specifying a partial type.</p>
<pre><code class="language-python">Point2D &lt;: Norm
Point2D = Class {.x = Int; .y = Int}
Point2D.norm self = self.x**2 + self.y**2
</code></pre>
<p>Error if the required attributes are not implemented.</p>
<pre><code class="language-python">Point2D &lt;: Norm # TypeError: Point2D is not a subtype of Norm
Point2D = Class {.x = Int; .y = Int}
</code></pre>
<p>Traits, like structural types, can apply operations such as composition, substitution, and elimination (e.g. <code>T and U</code>). The resulting trait is called an instant trait.</p>
<pre><code class="language-python">T = Trait {.x = Int}
U = Trait {.y = Int}
V = Trait {.x = Int; y: Int}
assert Structural(T and U) == Structural V
assert Structural(V not U) == Structural T
W = Trait {.x = Ratio}
assert Structural(W) ! = Structural(T)
assert Structural(W) == Structural(T.replace {.x = Ratio})
</code></pre>
<p>Trait is also a type, so it can be used for normal type specification.</p>
<pre><code class="language-python">points: [Norm; 2] = [Point2D::new(1, 2), Point2D::new(3, 4)]
assert points.iter().map(x -&gt; x.norm()).collect(Array) == [5, 25].
</code></pre>
<h2 id="trait-inclusion"><a class="header" href="#trait-inclusion">Trait inclusion</a></h2>
<p>The expansion operator <code>...</code> allows you to define a trait that contains a certain trait as a supertype. This is called the <strong>subsumption</strong> of a trait.
In the example below, <code>BinAddSub</code> subsumes <code>BinAdd</code> and <code>BinSub</code>.
This corresponds to Inheritance in a class, but unlike Inheritance, multiple base types can be combined using <code>and</code>. Traits that are partially excluded by <code>not</code> are also allowed.</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}

Sub R = Trait {
    .SubO = Type
    . `_-_` = Self.(R) -&gt; Self.SubO
}

BinAddSub = Subsume Add(Self) and Sub(Self)
</code></pre>
<h2 id="structural-traits"><a class="header" href="#structural-traits">Structural Traits</a></h2>
<p>Traits can be structured.</p>
<pre><code class="language-python">SAdd = Structural Trait {
    . `_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: SAdd| cannot be omitted
add|A &lt;: SAdd| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

assert add(C.new(1), C.new(2)) == C.new(3)
</code></pre>
<p>Nominal traits cannot be used simply by implementing a request method, but must be explicitly declared to have been implemented.
In the following example, <code>add</code> cannot be used with an argument of type <code>C</code> because there is no explicit declaration of implementation. It must be <code>C = Class {i = Int}, Impl := Add</code>.</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: Add| can be omitted
add|A &lt;: Add| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

add C.new(1), C.new(2) # TypeError: C is not a subclass of Add
# hint: inherit or patch 'Add'
</code></pre>
<p>Structural traits do not need to be declared for this implementation, but instead type inference does not work. Type specification is required for use.</p>
<h2 id="polymorphic-traits"><a class="header" href="#polymorphic-traits">Polymorphic Traits</a></h2>
<p>Traits can take parameters. This is the same as for polymorphic types.</p>
<pre><code class="language-python">Mapper T: Type = Trait {
    .mapIter = {Iterator}
    .map = (self: Self, T -&gt; U) -&gt; Self.MapIter U
}

# ArrayIterator &lt;: Mapper
# ArrayIterator.MapIter == ArrayMapper
# [1, 2, 3].iter(): ArrayIterator Int
# [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;): ArrayMapper Str
assert [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;).collect(Array) == [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="override-in-trait"><a class="header" href="#override-in-trait">Override in Trait</a></h2>
<p>Derived traits can override the type definitions of the base trait.
In this case, the type of the overriding method must be a subtype of the base method type.</p>
<pre><code class="language-python"># `Self.(R) -&gt; O` is a subtype of ``Self.(R) -&gt; O or Panic
Div R, O: Type = Trait {
    . `/` = Self.(R) -&gt; O or Panic
}
SafeDiv R, O = Subsume Div, {
    @Override
    . `/` = Self.(R) -&gt; O
}
</code></pre>
<h2 id="implementing-and-resolving-duplicate-traits-in-the-api"><a class="header" href="#implementing-and-resolving-duplicate-traits-in-the-api">Implementing and resolving duplicate traits in the API</a></h2>
<p>The actual definitions of <code>Add</code>, <code>Sub</code>, and <code>Mul</code> look like this.</p>
<pre><code class="language-python">Add R = Trait {
    .Output = Type
    . `_+_` = Self.(R) -&gt; .Output
}
Sub R = Trait {
    .Output = Type
    . `_-_` = Self.(R) -&gt; .Output
}
Mul R = Trait {
    .Output = Type
    . `*` = Self.(R) -&gt; .Output
}
</code></pre>
<p><code>.Output</code> is duplicated. If you want to implement these multiple traits at the same time, specify the following.</p>
<pre><code class="language-python">P = Class {.x = Int; .y = Int}
# P|Self &lt;: Add(P)| can be abbreviated to P|&lt;: Add(P)|
P|Self &lt;: Add(P)|.
    Output = P
    `_+_` self, other = P.new {.x = self.x + other.x; .y = self.y + other.y}
P|Self &lt;: Mul(Int)|.
    Output = P
    `*` self, other = P.new {.x = self.x * other; .y = self.y * other}
</code></pre>
<p>Duplicate APIs implemented in this way are almost always type inferred when used, but can also be resolved by explicitly specifying the type with <code>||</code>.</p>
<pre><code class="language-python">print! P.Output # TypeError: ambiguous type
print! P|&lt;: Mul(Int)|.Output # &lt;class 'P'&gt;
</code></pre>
<h2 id="appendix-differences-from-rust-traits"><a class="header" href="#appendix-differences-from-rust-traits">Appendix: Differences from Rust traits</a></h2>
<p>Erg's trait is faithful to the one proposed by <a href="https://www.ptidej.net/courses/ift6251/fall06/presentations/061122/061122.doc.pdf">Schärli et al.</a>.
In order to allow algebraic operations, traits are designed to be unable to have method implementations directory, but can be patched if necessary.</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="class"><a class="header" href="#class">Class</a></h1>
<p>A class in Erg is roughly a type that can create its own elements (instances).
Here is an example of a simple class.</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
# If `.new` is not defined, then Erg will create `Person.new = Person::__new__`
Person.
    new name, age = Self::__new__ {.name = name; .age = age}

john = Person.new &quot;John Smith&quot;, 25
print! john # &lt;Person object&gt;
print! classof(john) # Person
</code></pre>
<p>The type given to <code>Class</code> (normally a record type) is called the requirement type (in this case <code>{.name = Str; .age = Nat}</code>).
Instances can be created with <code>&lt;Class name&gt;::__new__ {&lt;attribute name&gt; = &lt;value&gt;; ...}</code> can be created with.
<code>{.name = &quot;John Smith&quot;; .age = 25}</code> is just a record, but it is converted to a <code>Person</code> instance by passing <code>Person.new</code>.
The subroutine that creates such an instance is called a constructor.
In the class above, the <code>.new</code> method is defined so that field names, etc. can be omitted.</p>
<p>Note that the following definition without line breaks will result in a syntax error.</p>
<pre><code class="language-python">Person.new name, age = ... # SyntaxError: cannot define attributes directly on an object
</code></pre>
<blockquote>
<p><strong>Warning</strong>: This is a recently added specification and may not be followed in subsequent documents. If you find it, please report it.</p>
</blockquote>
<h2 id="instance-and-class-attributes"><a class="header" href="#instance-and-class-attributes">Instance and class attributes</a></h2>
<p>In Python and other languages, instance attributes are often defined on the block side as follows, but note that such writing has a different meaning in Erg.</p>
<pre><code class="language-python"># Python
class Person:
    name: str
    age: int
</code></pre>
<pre><code class="language-python"># In Erg, this notation implies the declaration of a class attribute (not an instance attribute)
Person = Class()
Person.
    name: Str
    age: Int
</code></pre>
<pre><code class="language-python"># Erg code for the Python code above
Person = Class {
    .name = Str
    .age = Nat
}
</code></pre>
<p>Element attributes (attributes defined in a record) and type attributes (also called instance/class attributes, especially in the case of classes) are completely different things. Type attributes are attributes of the type itself. An element of a type refers to a type attribute when it does not have the desired attribute in itself. An element attribute is a unique attribute directly possessed by the element.
Why is this distinction made? If all attributes were element attributes, it would be inefficient to duplicate and initialize all attributes when the object is created.
In addition, dividing the attributes in this way clarifies roles such as &quot;this attribute is shared&quot; and &quot;this attribute is held separately&quot;.</p>
<p>The example below illustrates this. The attribute <code>species</code> is common to all instances, so it is more natural to use it as a class attribute. However, the attribute <code>name</code> should be an instance attribute because each instance should have it individually.</p>
<pre><code class="language-python">Person = Class {name = Str}
Person::
    species = &quot;human&quot;
Person.
    describe() =
        log &quot;species: {species}&quot;
    greet self =
        log &quot;Hello, My name is {self::name}.&quot;

Person.describe() # species: human
Person.greet() # TypeError: unbound method Person.greet needs an argument

john = Person.new {name = &quot;John&quot;}
john.describe() # species: human
john.greet() # Hello, My name is John.

alice = Person.new {name = &quot;Alice&quot;}
alice.describe() # species: human
alice.greet() # Hello, My name is Alice.
</code></pre>
<p>Incidentally, if an instance attribute and a type attribute have the same name and the same type, a compile error occurs. This is to avoid confusion.</p>
<pre><code class="language-python">C = Class {.i = Int}
C.i = 1 # AttributeError: `.i` is already defined in instance fields
</code></pre>
<h2 id="class-type"><a class="header" href="#class-type">Class, Type</a></h2>
<p>Note that the class and type of <code>1</code> are different.
There is only one class <code>Int</code> that is the generator of <code>1</code>. You can get the class to which an object belongs by <code>classof(obj)</code> or <code>obj.__class__</code>.
In contrast, there are countless types of <code>1</code>. For example, <code>{1}, {0, 1}, 0..12, Nat, Int, Num</code>.
However, the smallest type can be defined as a single type, in this case <code>{1}</code>. The type to which an object belongs can be obtained with <code>Typeof(obj)</code>. This is a compile-time function.
Objects can use patch methods as well as class methods.
Erg does not allow you to add class methods, but you can use <a href="type/./07_patch.html">patch</a> to extend a class.</p>
<p>You can also inherit from existing classes (<a href="type/../29_decorator.html#inheritable">Inheritable</a> class).
You can create an inherited class by using <code>Inherit</code>. The type on the left-hand side is called the derived class, and the argument type of <code>Inherit</code> on the right-hand side is called the base class (inherited class).</p>
<pre><code class="language-python">MyStr = Inherit Str
# other: You can use MyStr if you set ``other: Str''.
MyStr.
    `-` self, other: Str = self.replace other, &quot;&quot;

abc = MyStr.new(&quot;abc&quot;)
# Comparison here gets an upcast
assert abc - &quot;b&quot; == &quot;ac&quot;
</code></pre>
<p>Unlike Python, the defined Erg classes are <code>final</code> (non-inheritable) by default.
To make a class inheritable, an <code>Inheritable</code> decorator must be attached to the class.
Str` is one of the inheritable classes.</p>
<pre><code class="language-python">MyStr = Inherit Str # OK
MyStr2 = Inherit MyStr # NG

@Inheritable
InheritableMyStr = Inherit Str
MyStr3 = Inherit InheritableMyStr # OK
</code></pre>
<p><code>Inherit Object</code> and <code>Class()</code> are almost equivalent in practice. The latter is generally used.</p>
<p>Classes have a different equivalence checking mechanism than types.
Types are equivalence tested based on their structure.</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
Human = {.name = Str; .age = Nat}

assert Person == Human
</code></pre>
<p>class has no equivalence relation defined.</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
Human = Class {.name = Str; .age = Nat}

Person == Human # TypeError: cannot compare classes
</code></pre>
<h2 id="difference-from-structural-types"><a class="header" href="#difference-from-structural-types">Difference from structural types</a></h2>
<p>We said that a class is a type that can generate its own elements, but that is not a strict description. In fact, a record type + patch can do the same thing.</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    new name, age = {.name; .age}

john = Person.new(&quot;John Smith&quot;, 25)
</code></pre>
<p>There are four advantages to using classes.
The first is that the constructor is validity checked, the second is that it is more performant, the third is that you can use notational subtypes (NSTs), and the fourth is that you can inherit and override.</p>
<p>We saw earlier that record type + patch can also define a constructor (of sorts), but this is of course not a legitimate constructor. This is of course not a legitimate constructor, because it can return a completely unrelated object even if it calls itself <code>.new</code>. In the case of a class, <code>.new</code> is statically checked to see if it produces an object that satisfies the requirements.</p>
<p>~</p>
<p>Type checking for classes is simply a matter of checking the object's <code>. __class__</code> attribute of the object. So it is fast to check if an object belongs to a type.</p>
<p>~</p>
<p>Erg enables NSTs in classes; the advantages of NSTs include robustness.
When writing large programs, it is often the case that the structure of an object is coincidentally matched.</p>
<pre><code class="language-python">Dog = {.name = Str; .age = Nat}
DogImpl = Patch Dog
DogImpl.
    bark = log &quot;Yelp!&quot;
...
Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    greet self = log &quot;Hello, my name is {self.name}.&quot;

john = {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # &quot;Yelp!&quot;
</code></pre>
<p>The structure of <code>Dog</code> and <code>Person</code> is exactly the same, but it is obviously nonsense to allow animals to greet and humans to bark.
The former is impossible, so it is safer to make it inapplicable. In such cases, it is better to use classes.</p>
<pre><code class="language-python">Dog = Class {.name = Str; .age = Nat}
Dog.bark = log &quot;Yelp!&quot;
...
Person = Class {.name = Str; .age = Nat}
Person.greet self = log &quot;Hello, my name is {self.name}.&quot;

john = Person.new {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # TypeError: `Person` object has no method `.bark`.
</code></pre>
<p>Another feature is that the type attributes added by the patch are virtual and are not held as entities by the implementing class.
That is, <code>T.x</code>, <code>T.bar</code> are objects that can be accessed (compile-time bound) by types compatible with <code>{i = Int}</code>, and are not defined in <code>{i = Int}</code> or <code>C</code>.
In contrast, class attributes are held by the class itself. Therefore, they cannot be accessed by classes that are not in an inheritance relationship, even if they have the same structure.</p>
<pre><code class="language-python">C = Class {i = Int}
C.
    foo self = ...
print! dir(C) # [&quot;foo&quot;, ...].

T = Patch {i = Int}
T.
    x = 1
    bar self = ...
print! dir(T) # [&quot;bar&quot;, &quot;x&quot;, ...].
assert T.x == 1
assert {i = 1}.x == 1
print! T.bar # &lt;function bar&gt;
{i = Int}.bar # TypeError: Record({i = Int}) has no method `.bar`.
C.bar # TypeError: C has no method `.bar` print!
print! {i = 1}.bar # &lt;method bar&gt;
C.new({i = 1}).bar # &lt;method bar&gt;
</code></pre>
<h2 id="difference-from-data-class"><a class="header" href="#difference-from-data-class">Difference from Data Class</a></h2>
<p>There are two types of classes: regular classes, which are generated with <code>Class(record)</code>, and data classes, which are generated with <code>Inherit(record)</code>.
The data class inherits the functionality of the record class and has features such as decomposition assignment, <code>==</code> and <code>hash</code> implemented by default, etc. On the other hand, the data class has its own equivalence relation and format display.
On the other hand, if you want to define your own equivalence relations or formatting displays, you should use the normal class.</p>
<pre><code class="language-python">C = Class {i = Int}
c = C.new {i = 1}
d = C.new {i = 2}
print! c # &lt;C object&gt;
c == d # TypeError: `==` is not implemented for `C`

D = Inherit {i = Int}
e = D::{i = 1} # same as `e = D.new {i = 1}`
f = D::{i = 2}
print! e # D(i=1)
assert e ! = f
</code></pre>
<h2 id="enum-class"><a class="header" href="#enum-class">Enum Class</a></h2>
<p>To facilitate defining classes of type <code>Or</code>, an <code>Enum</code> is provided.</p>
<pre><code class="language-python">X = Class()
Y = Class()
XorY = Enum X, Y
</code></pre>
<p>Each type can be accessed as <code>XorY.X</code>, <code>XorY.Y</code> and the constructor can be obtained as <code>X.new |&gt; XorY.new</code>.</p>
<pre><code class="language-python">x1 = XorY.new X.new()
x2 = (X.new |&gt; XorY.new)()
x3 = (Y.new |&gt; XorY.new)()
assert x1 == x2
assert x1 != x3
</code></pre>
<h2 id="class-relationships"><a class="header" href="#class-relationships">Class Relationships</a></h2>
<p>A class is a subtype of a requirement type. methods (including patch methods) of the requirement type can be used in the class.</p>
<pre><code class="language-python">T = Trait {.foo = Foo}
C = Class(... , impl: T)
C.
    foo = foo
    bar x = ...
assert C &lt; T
assert C.foo == foo
assert not T &lt; C
assert T.foo == Foo
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h1>
<p>Inheritance allows you to define a new class that adds functionality or specialization to an existing class.
Inheritance is similar to inclusion in a trait. The inherited class becomes a subtype of the original class.</p>
<pre><code class="language-python">NewInt = Inherit Int
NewInt.
    plus1 self = self + 1

assert NewInt.new(1).plus1() == 2
assert NewInt.new(1) + NewInt.new(1) == 2
</code></pre>
<p>If you want the newly defined class to be inheritable, you must give it the <code>Inheritable</code> decorator.</p>
<p>You can specify an optional argument <code>additional</code> to allow the class to have additional instance attributes, but only if the class is a value class. However, you cannot add instance attributes if the class is a value class.</p>
<pre><code class="language-python">@Inheritable
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}

john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

MailAddress = Inherit Str, additional: {owner = Str} # TypeError: instance variables cannot be added to a value class
</code></pre>
<p>Erg is exceptionally designed not to allow inheritance of type <code>Never</code>. Erg is exceptionally designed not to allow inheritance of <code>Never</code> type, because <code>Never</code> is a unique class that can never be instantiated.</p>
<h2 id="inheritance-of-enumerated-classes"><a class="header" href="#inheritance-of-enumerated-classes">Inheritance of Enumerated Classes</a></h2>
<p><a href="type/./13_algebraic.html">Or type</a> can also be inherited. In this case, you can remove any of the choices (multiple choices are possible with <code>or</code>) by specifying the optional argument <code>Excluding</code>.
No additional choices can be added. The class to which you add an option is not a subtype of the original class.</p>
<pre><code class="language-python">Number = Class Int or Float or Complex
Number.abs(self): Float =
    match self:
        i: Int -&gt; i.abs().into Float
        f: Float -&gt; f.abs()
        c: Complex -&gt; c.abs().into Float

# c: Complex cannot appear in match choices
RealNumber = Inherit Number, Excluding: Complex
</code></pre>
<p>Similarly, <a href="type/./12_refinement.html">refinement type</a> can also be specified.</p>
<pre><code class="language-python">Months = Class 0..12
MonthsNot31Days = Inherit Months, Excluding: {1, 3, 5, 7, 8, 10, 12}

StrMoreThan3 = Class StrWithLen N | N &gt;= 3
StrMoreThan4 = Inherit StrMoreThan3, Excluding: StrWithLen N | N == 3
</code></pre>
<h2 id="overriding"><a class="header" href="#overriding">Overriding</a></h2>
<p>The class is the same as the patch in that new methods can be added to the original type, but the class can be further &quot;overridden&quot;.
This overriding is called override. To override, three conditions must be met.
First, the override must have an <code>Override</code> decorator because by default it will result in an error.
In addition, the override cannot change the type of the method. It must be a subtype of the original type.
And if you override a method that is referenced by another method, you must also override all referenced methods.</p>
<p>Why is this condition necessary? It is because overriding does not merely change the behavior of one method, but may affect the behavior of another method.</p>
<p>Let's start with the first condition. This condition is to prevent &quot;accidental overrides.
In other words, the <code>Override</code> decorator must be used to prevent the name of a newly defined method in a derived class from conflicting with the name of the base class.</p>
<p>Next, consider the second condition. This is for type consistency. Since the derived class is a subtype of the base class, its behavior must also be compatible with that of the base class.</p>
<p>Finally, consider the third condition. This condition is unique to Erg and not often found in other object-oriented languages, again for safety. Let's look at what could go wrong if this were not the case.</p>
<pre><code class="language-python"># Bad example
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    g! ref! self = self.f!() # InfiniteRecursionWarning: This code falls into an infinite loop
    # OverrideError: method `.g` is referenced by `.f` but not overridden
</code></pre>
<p>In the inherited class <code>Inherited!</code>, the <code>.g!</code> method is overridden to transfer processing to <code>.f!</code>. However, the <code>.f!</code> method in the base class transfers its processing to <code>.g!</code>, resulting in an infinite loop. <code>.f</code> was a problem-free method in the <code>Base!</code> class, but it was used in an unexpected way by the override, and it was broken.</p>
<p>Erg has built this rule into the specification.</p>
<pre><code class="language-python"># OK.
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    f! ref! self =
        print! self::x
        self::x.update! x -&gt; x + 1
    @Override
    g! ref! self = self.f!()
</code></pre>
<p>However, this specification does not completely solve the override problem. However, this specification does not completely solve the override problem, since the compiler cannot detect if the override fixes the problem.
It is the responsibility of the programmer creating the derived class to correct the effects of the override. Whenever possible, try to define an alias method.</p>
<h3 id="replacing-traits-or-what-looks-like-it"><a class="header" href="#replacing-traits-or-what-looks-like-it">Replacing Traits (or what looks like it)</a></h3>
<p>Although it is not possible to replace traits at inheritance time, there are examples that appear to do so.</p>
<p>For example, <code>Int</code>, a subtype of <code>Real</code> (which implements <code>Add()</code>), appears to reimplement <code>Add()</code>.</p>
<pre><code class="language-python">Int = Class ... , Impl := Add() and ...
</code></pre>
<p>But in fact <code>Add()</code> in <code>Real</code> stands for <code>Add(Real, Real)</code>, and in <code>Int</code> it is just overwritten by <code>Add(Int, Int)</code>.
They are two different traits (<code>Add</code> is a <a href="type/./advanced/variance.html">covariate</a>, so <code>Add(Real, Real) :&gt; Add(Int, Int)</code>).</p>
<h2 id="multiple-inheritance"><a class="header" href="#multiple-inheritance">Multiple Inheritance</a></h2>
<p>Erg does not allow intersection, diff, and complement between normal classes.</p>
<pre><code class="language-python">Int and Str # TypeError: cannot unite classes
</code></pre>
<p>This rule prevents inheritance from multiple classes, i.e., multiple inheritance.</p>
<pre><code class="language-python">IntAndStr = Inherit Int and Str # SyntaxError: multiple inheritance of classes is not allowed
</code></pre>
<p>However, multiple inherited Python classes can be used.</p>
<h2 id="multi-layer-multi-level-inheritance"><a class="header" href="#multi-layer-multi-level-inheritance">Multi-layer (multi-level) Inheritance</a></h2>
<p>Erg inheritance also prohibits multi-layer inheritance. That is, you cannot define a class that inherits from another class.
Inheritable classes that inherit from an <code>Object</code> may exceptionally inherit.</p>
<p>Also in this case, Python's multi-layered inherited classes can be used.</p>
<h2 id="rewriting-inherited-attributes"><a class="header" href="#rewriting-inherited-attributes">Rewriting Inherited Attributes</a></h2>
<p>Erg does not allow rewriting the attributes inherited from the base class. This has two implications.</p>
<p>The first is an update operation on the inherited source class attribute. It cannot be reassigned, nor can it be updated by the <code>.update!</code> method, for example.</p>
<p>Overriding is different from rewriting because it is an operation to override with a more specialized method. Overrides must also be replaced by compatible types.</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    var = !1
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1

Inherited! = Inherit Base!
Inherited!
    var.update! v -&gt; v + 1
    # TypeError: can't update base class variables
    @Override
    inc_pub! ref! self = self.pub + 1
    # OverrideError: `.inc_pub!` must be subtype of `Self! () =&gt; ()`
</code></pre>
<p>The second is an update operation on the (variable) instance attribute of the inherited source. This is also prohibited. Instance attributes of the base class may only be updated from methods provided by the base class.
Regardless of the visibility of the attribute, it cannot be updated directly. However, they can be read.</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1
    inc_pri! ref! self = self::pri.update! p -&gt; p + 1

self = self.pub.update!
Inherited!
    # OK
    add2_pub! ref! self =
        self.inc_pub!()
        self.inc_pub!()
    # NG, `Child` cannot touch `self.pub` and `self::pri`.
    add2_pub! ref! self =
        self.pub.update! p -&gt; p + 2
</code></pre>
<p>After all, Erg inheritance can only add new attributes and override base class methods.</p>
<h2 id="usage-of-inheritance"><a class="header" href="#usage-of-inheritance">Usage of Inheritance</a></h2>
<p>While inheritance is a powerful feature when used correctly, it also has the drawback that it tends to complicate class dependencies, especially when multiple or multi-layer inheritance is used. Complicated dependencies can reduce code maintainability.
The reason Erg prohibits multiple and multi-layer inheritance is to reduce this risk, and the class patch feature was introduced to reduce the complexity of dependencies while retaining the &quot;add functionality&quot; aspect of inheritance.</p>
<p>So, conversely, where should inheritance be used? One indicator is when &quot;semantic subtypes of the base class are desired.
Erg allows the type system to automatically do part of the subtype determination (e.g., Nat, where Int is greater than or equal to 0).
However, for example, it is difficult to create a &quot;string type representing a valid e-mail address&quot; relying solely on Erg's type system. You should probably perform validation on a normal string. Then, we would like to add some kind of &quot;warrant&quot; to the string object that has passed validation. That is the equivalent of downcasting to an inherited class. Downcasting a <code>Str object</code> to <code>ValidMailAddressStr</code> is a one-to-one correspondence with validating that the string is in the correct email address format.</p>
<pre><code class="language-python">ValidMailAddressStr = Inherit Str
ValidMailAddressStr.
    init s: Str =
        validate s # mail-address validation
        Self.new s

s1 = &quot;invalid mail address&quot;
s2 = &quot;foo@gmail.com&quot;
_ = ValidMailAddressStr.init s1 # panic: invalid mail address
valid = ValidMailAddressStr.init s2
valid: ValidMailAddressStr # assurance that it is in the correct email address format
</code></pre>
<p>Another indicator is when you want to achieve a nominal polymorphism.
For example, the <code>greet!</code> procedure defined below will accept any object of type <code>Named</code>.
But obviously it is wrong to apply a <code>Dog</code> type object. So we will use the <code>Person</code> class for the argument type.
This way, only <code>Person</code> objects, classes that inherit from them, and <code>Student</code> objects will be accepted as arguments.
This is more conservative and avoids unnecessarily assuming too much responsibility.</p>
<pre><code class="language-python">Named = {name = Str; ...}
Dog = Class {name = Str; breed = Str}
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}
structural_greet! person: Named =
    print! &quot;Hello, my name is {person::name}.&quot;
greet! person: Person =
    print! &quot;Hello, my name is {person::name}.&quot;

max = Dog.new {name = &quot;Max&quot;, breed = &quot;Labrador&quot;}
john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

structural_greet! max # Hello, my name is Max.
structural_greet! john # Hello, my name is John.
greet! alice # Hello, my name is Alice.
greet! max # TypeError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="nominal-subtyping-vs-structural-subtyping"><a class="header" href="#nominal-subtyping-vs-structural-subtyping">Nominal Subtyping vs. Structural Subtyping</a></h1>
<pre><code class="language-python">Months = 0..12

# NST
MonthsClass = Class Months
MonthsClass.
    name self =
        match self:
            1 -&gt; &quot;january&quot;
            2 -&gt; &quot;february&quot;
            3 -&gt; &quot;march&quot;
            ...

# SST
MonthsImpl = Patch Months
MonthsImpl.
    name self =
        match self:
            1 -&gt; &quot;January&quot;
            2 -&gt; &quot;February&quot;
            3 -&gt; &quot;March&quot;
            ...

assert 12 in Months
assert 2.name() == &quot;February&quot;
assert not 12 in MonthsClass
assert MonthsClass.new(12) in MonthsClass
# It can use structural types, even though wrapped in a class.
assert MonthsClass.new(12) in Months
# If both exist, class methods take priority.
assert MonthsClass.new(2).name() == &quot;february&quot;
</code></pre>
<h2 id="in-the-end-which-should-i-use-nst-or-sst"><a class="header" href="#in-the-end-which-should-i-use-nst-or-sst">In The End, Which Should I Use, NST or SST?</a></h2>
<p>If you cannot decide which one to use, our recommendation is NST.
SST requires abstraction skills to write code that does not break down in any use case. Good abstraction can lead to high productivity, but wrong abstraction (commonality by appearances) can lead to counterproductive results. (NSTs can reduce this risk by deliberately keeping abstraction to a minimum. If you are not a library implementor, it is not a bad idea to code only with NSTs.</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="patch"><a class="header" href="#patch">Patch</a></h1>
<p>Erg does not allow modification of existing types and classes.
This means, it is not possible to define additional methods in a class, nor to perform specialization (a language feature that monomorphizes a polymorphically declared type and defines a dedicated method, as in C++).
However, there are many situations where you may want to add feature to an existing type or class, and there is a function called &quot;patching&quot; that allows you to do this.</p>
<pre><code class="language-python">StrReverse = Patch Str
StrReverse.
    reverse self = self.iter().rev().collect(Str)

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
</code></pre>
<p>The name of the patch should be a straightforward description of the primary functionality to be added.
This way, objects of the type being patched (<code>Str</code>) can use the methods of the patch (<code>StrReverse</code>).
In fact, built-in method <code>.reverse</code> is not a method of <code>Str</code>, but a method added to <code>StrRReverse</code>.</p>
<p>However, patch methods have lower precedence than methods of the nominal type (class/trait) and cannot override methods of existing types.</p>
<pre><code class="language-python">StrangeInt = Patch Int
StrangeInt.
    `_+_` = Int.`_-_` # AssignError: . `_+_` is already defined in Int
</code></pre>
<p>If you want to override, you must inherit from the class.
However, it is basically recommended not to override and to define a method with a different name.
Overriding is not very easy to do because of some safety restrictions.</p>
<pre><code class="language-python">StrangeInt = Inherit Int
StrangeInt.
    # Overriding methods must be given Override decorators.
    # In addition, you need to override all Int methods that depend on Int.`_+_`.
    @Override
    `_+_` = Super.`_-_` # OverrideError: Int.`_+_` is referenced by ... ````` , so these methods must also be overridden
</code></pre>
<h2 id="selecting-patches"><a class="header" href="#selecting-patches">Selecting Patches</a></h2>
<p>Patches can be defined for a single type, and can be grouped together.</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
StrMultiReplace = Patch(Str)
StrMultiReverse.
    multi_replace self, pattern_and_targets: [(Pattern, Str)] = ...
StrToCamelCase = Patch(Str)
StrToCamelCase.
    to_camel_case self = ...
StrToKebabCase = Patch(Str)
StrToKebabCase.
    to_kebab_case self = ...

StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
</code></pre>
<pre><code class="language-python">{StrBoosterPack; ...} = import &quot;foo&quot;

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
assert &quot;abc&quot;.multi_replace([(&quot;a&quot;, &quot;A&quot;), (&quot;b&quot;, &quot;B&quot;)]) == &quot;ABc&quot;
assert &quot;to camel case&quot;.to_camel_case() == &quot;toCamelCase&quot;
assert &quot;to kebab case&quot;.to_kebab_case() == &quot;to-kebab-case&quot;
</code></pre>
<p>If multiple patches are defined, some of them may result in duplicate implementations.</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
# more efficient implementation
StrReverseMk2 = Patch(Str)
StrReverseMk2.
    reverse self = ...

&quot;hello&quot;.reverse() # PatchSelectionError: multiple choices of `.reverse`: StrReverse, StrReverseMk2
</code></pre>
<p>In such a case, you can make it unique by using the <strong>related function</strong> form instead of the method form.</p>
<pre><code class="language-python">assert StrReverseMk2.reverse(&quot;hello&quot;) == &quot;olleh&quot;
</code></pre>
<p>You can also make it unique by selectively importing.</p>
<pre><code class="language-python">{StrReverseMk2; ...} = import &quot;foo&quot;

assert &quot;hello&quot;.reverse() == &quot;olleh&quot;
</code></pre>
<h2 id="glue-patch"><a class="header" href="#glue-patch">Glue Patch</a></h2>
<p>Patches can also relate types to each other. The <code>StrReverse</code> patch relates <code>Str</code> and <code>Reverse</code>.
Such a patch is called a <strong>glue patch</strong>.
Because <code>Str</code> is a built-in type, a glue patch is necessary for users to retrofit traits.</p>
<pre><code class="language-python">Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch Str, Impl := Reverse
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>Only one glue patch can be defined per type/trait pair.
This is because if multiple glue patches were &quot;visible&quot; at the same time, it would not be possible to uniquely determine which implementation to choose.
However, you can swap patches when moving to another scope (module).</p>
<pre><code class="language-python">NumericStr = Inherit Str
NumericStr.
    ...

NumStrRev = Patch NumericStr, Impl := Reverse
NumStrRev.
    ...
# DuplicatePatchError: NumericStr is already associated with `Reverse`
# hint: `Str` (superclass of `NumericStr`) is associated with `Reverse` by `StrReverse`
</code></pre>
<h2 id="appendix-relationship-to-rusts-trait"><a class="header" href="#appendix-relationship-to-rusts-trait">Appendix: Relationship to Rust's Trait</a></h2>
<p>Erg patches are the equivalent of Rust's (retrofitted) <code>impl</code> blocks.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
trait Reverse {
    fn reverse(self) -&gt; Self;
}

impl Reverse for String {
    fn reverse(self) -&gt; Self {
        self.chars().rev().collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You could say that Rust's traits are features of Erg's traits and patches. This makes Rust's traits sound more convenient, but that is not necessarily the case.</p>
<pre><code class="language-python"># Erg
Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch(Str, Impl := Reverse)
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>Because the <code>impl</code> block is objectized as a patch in Erg, selective inclusion is possible when importing from other modules. As a side-effect, it also allows implementation of external traits to external structures.
Also, syntaxes such as <code>dyn trait</code> and <code>impl trait</code> are no longer required by the structure type.</p>
<pre><code class="language-python"># Erg
reversible: [Reverse; 2] = [[1, 2, 3], &quot;hello&quot;]

iter|T|(i: Iterable T): Iterator T = i.iter()
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
let reversible: [Box&lt;dyn Reverse&gt;; 2] = [Box::new([1, 2, 3]), Box::new(&quot;hello&quot;)];

fn iter&lt;I&gt;(i: I) -&gt; impl Iterator&lt;Item = I::Item&gt; where I: IntoIterator {
    i.into_iter()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="for-all-patch"><a class="header" href="#for-all-patch">For-All Patch</a></h2>
<p>A patch can be defined not only for one specific type, but also for &quot;function types in general&quot; and so on.
In this case, the term to which the degree of freedom is to be given is given as an argument (in the case below, <code>T: Type</code>). A patch defined in this way is called an all-symmetric patch.
As you can see, an all-symmetric patch is precisely a function that returns a patch, but it can also be considered a patch in its own right.</p>
<pre><code class="language-python">FnType T: Type = Patch(T -&gt; T)
FnType(T).
    type = T

assert (Int -&gt; Int).type == Int
</code></pre>
<h2 id="structural-patch"><a class="header" href="#structural-patch">Structural Patch</a></h2>
<p>In addition, patches can be defined for any type that satisfies a certain structure.
However, this has a lower priority than nominal patches and class methods.</p>
<p>Careful design should be used when defining structural patches, as some properties are lost by extension, such as the following.</p>
<pre><code class="language-python"># This should not be `Structural`
Norm = Structural Patch {x = Int; y = Int}
Norm.
    norm self = self::x**2 + self::y**2

Point2D = Class {x = Int; y = Int}
assert Point2D.new({x = 1; y = 2}).norm() == 5

Point3D = Class {x = Int; y = Int; z = Int}
assert Point3D.new({x = 1; y = 2; z = 3}).norm() == 14 # AssertionError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="value-type"><a class="header" href="#value-type">Value Type</a></h1>
<p>Value types are Erg built-in types that can be evaluated at compile time, specifically:</p>
<pre><code class="language-python">Value = (
    Int
    or Nat
    or Ratio
    or Float
    or Complex
    or Bool
    or Str
    or NoneType
    or Array Const
    or Tuple Const
    or Set Const
    or ConstFunc(Const, _)
    or ConstProc(Const, _)
    or ConstMethod(Const, _)
)
</code></pre>
<p>Value-type objects, constants, and compile-time subroutines applied to them are called <strong>constant expressions</strong>.</p>
<pre><code class="language-python">1, 1.0, 1+2im, True, None, &quot;aaa&quot;, [1, 2, 3], Fib(12)
</code></pre>
<p>Be careful with subroutines. Subroutines may or may not be value types.
Since the substance of a subroutine is just a pointer, it can be treated as a value <a href="type/08_value.html#1"><sup id="f1">1</sup></a>, but when compiling something that is not a subroutine cannot be used in a constant context. is not a value type because it doesn't make much sense.</p>
<p>Types classified as value types may be added in the future.</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> The term &quot;value type&quot; in Erg differs from the definition in other languages. There is no concept of memory within pure Erg semantics, and it is incorrect to state that it is a value type because it is placed on the stack, or that it is not a value type because it is actually a pointer. A value type only means that it is a <code>Value</code> type or its subtypes. <a href="type/08_value.html#f1">↩</a></span></p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="attributive-type"><a class="header" href="#attributive-type">Attributive Type</a></h1>
<p>Attribute types are types that contain Record and Dataclass, Patch, Module, etc.
Types belonging to attribute types are not value types.</p>
<h2 id="record-type-composite"><a class="header" href="#record-type-composite">Record Type Composite</a></h2>
<p>It is possible to flatten Record types composited.
For example, <code>{... {.name = Str; .age = Nat}; ... {.name = Str; .id = Nat}}</code> becomes <code>{.name = Str; .age = Nat; .id = Nat}</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interval-type"><a class="header" href="#interval-type">Interval Type</a></h1>
<p>The most basic use of <code>Range</code> objects is as iterator.</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>Note that unlike Python, it includes a end number.</p>
<p>However, this is not only use for the <code>Range</code> objects. It can also be used the type. Such a type is called the Interval type.</p>
<pre><code class="language-python">i: 0..10 = 2
</code></pre>
<p>The <code>Nat</code> type is equivalent to <code>0..&lt;Inf</code> and, <code>Int</code> and <code>Ratio</code> are equivalent to <code>-Inf&lt;..&lt;Inf</code>,
<code>0..&lt;Inf</code> can also be written <code>0.._</code>. <code>_</code> means any instance of <code>Int</code> type.</p>
<p>Since it is can also be used as iterator, it can be specified in reverse order, such as <code>10..0</code>, however <code>&lt;..</code>, <code>..&lt;</code> and <code>&lt;..&lt;</code> cannot be reversed.</p>
<pre><code class="language-python">a = 0..10 # OK
b = 0..&lt;10 # OK
c = 10..0 # OK
d = 10&lt;..0 # Syntax error
e = 10..&lt;0 # Syntax error
f = 10&lt;..&lt;0 # Syntax error
</code></pre>
<p>A Range operator can be used for non-numeric types, as long as they are <code>Ord</code> immutable types.</p>
<pre><code class="language-python">Alphabet = &quot;A&quot;..&quot;z&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enumerative-type"><a class="header" href="#enumerative-type">Enumerative Type</a></h1>
<p>Enum types generated by Set.
Enum types can be used as-is with type specifications, but further methods can be defined by classifying them into classes or defining patches.</p>
<p>A partially typed system with an enumerated type is called an enumerated partially typed.</p>
<pre><code class="language-python">Bool = {True, False}
Status = {&quot;ok&quot;, &quot;error&quot;}
</code></pre>
<p>Since <code>1..7</code> can be rewritten as <code>{1, 2, 3, 4, 5, 6, 7}</code>, so when element is finite, the Enum types essentially equivalent the Range types.</p>
<pre><code class="language-python">Binary! = Class {0, 1}!.
    invert! ref! self =
        if! self == 0:
            do!
                self.set! 1
            do!
                self.set! 0

b = Binary!.new !0
b.invert!()
</code></pre>
<p>Incidentally, Erg's Enum types are a concept that encompasses enumerative types common in other languages.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
enum Status { Ok, Error }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Erg
Status = {&quot;Ok&quot;, &quot;Error&quot;}
</code></pre>
<p>The difference with Rust is that it uses a structural subtype(SST).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// There is no relationship between Status and ExtraStatus.
enum Status { Ok, Error }
enum ExtraStatus { Ok, Error, Unknown }

// Methods can be implemented
impl Status {
    // ...
}
impl ExtraStatus {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Status &gt; ExtraStatus, and elements of Status can use methods of ExtraStatus.
Status = Trait {&quot;Ok&quot;, &quot;Error&quot;}
    # ...
ExtraStatus = Trait {&quot;Ok&quot;, &quot;Error&quot;, &quot;Unknown&quot;}
    # ...
</code></pre>
<p>Methods can also be added by patching.</p>
<p>Use the <code>or</code> operator to explicitly indicate inclusion or to add a choice to an existing Enum type.</p>
<pre><code class="language-python">ExtraStatus = Status or {&quot;Unknown&quot;}
</code></pre>
<p>An enumerated type in which all classes to which an element belongs are identical is called a homogenous enumerated type.</p>
<p>By default, a class whose requirement type is an homogeneous enumerated type can be treated as a subclass of the class to which the element belongs.</p>
<p>If you do not wish to do so, you can make it a wrapper class.</p>
<pre><code class="language-python">Abc = Class {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}
Abc.new(&quot;A&quot;).is_uppercase()

OpaqueAbc = Class {inner = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}}.
    new inner: {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} = Self.new {inner;}
OpaqueAbc.new(&quot;A&quot;).is_uppercase() # TypeError
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="refinement-type"><a class="header" href="#refinement-type">Refinement Type</a></h1>
<p>Refinement type is a type constrained by a predicate expression. Enumeration types and interval types are syntax sugar of refinement types.</p>
<p>The standard form of a refinement type is <code>{Elem: Type | (Pred)*}</code>. This means that the type is a type whose elements are <code>Elem</code> satisfying <code>Pred</code>.
The type that can be used for the refinement type is <a href="type/./08_value.html">Value type</a> only.</p>
<pre><code class="language-python">Nat = 0.. _
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N &gt;= 3}
</code></pre>
<p>When there are multiple preds, they can be separated by <code>;</code> or <code>and</code> or <code>or</code>. <code>;</code> and <code>and</code> mean the same thing.</p>
<p>The elements of <code>Odd</code> are <code>1, 3, 5, 7, 9, ...</code>.
It is called a refinement type because it is a type whose elements are part of an existing type as if it were a refinement.</p>
<p>The <code>Pred</code> is called a (left-hand side) predicate expression. Like assignment expressions, it does not return a meaningful value, and only a pattern can be placed on the left-hand side.
That is, expressions such as <code>X**2 - 5X + 6 == 0</code> cannot be used as refinement-type predicate expressions. In this respect, it differs from a right-hand-side predicate expression.</p>
<pre><code class="language-python">{X: Int | X**2 - 5X + 6 == 0} # SyntaxError: the predicate form is invalid. Only names can be on the left-hand side
</code></pre>
<p>If you know how to solve quadratic equations, you would expect the above refinement form to be equivalent to <code>{2, 3}</code>.
However, the Erg compiler has very little knowledge of algebra, so it cannot solve the predicate on the right.</p>
<h2 id="smart-cast"><a class="header" href="#smart-cast">Smart Cast</a></h2>
<p>It's nice that you defined <code>Odd</code>, but as it is, it doesn't look like it can be used much outside of literals. To promote an odd number in a normal <code>Int</code> object to <code>Odd</code>, i.e., to downcast an <code>Int</code> to <code>Odd</code>, you need to pass the constructor of <code>Odd</code>.
For refinement types, the normal constructor <code>.new</code> may panic, and there is an auxiliary constructor called <code>.try_new</code> that returns a <code>Result</code> type.</p>
<pre><code class="language-python">i = Odd.new (0..10).sample!()
i: Odd # or Panic
</code></pre>
<p>It can also be used as a type specification in <code>match</code>.</p>
<pre><code class="language-python"># i: 0..10
i = (0..10).sample!
match i:
    o: Odd -&gt;
        log &quot;i: Odd&quot;
    n: Nat -&gt; # 0..10 &lt; Nat
        log &quot;i: Nat&quot;
</code></pre>
<p>However, Erg cannot currently make sub-decisions such as <code>Even</code> because it was not <code>Odd</code>, etc.</p>
<h2 id="enumerated-interval-and-refinement-types"><a class="header" href="#enumerated-interval-and-refinement-types">Enumerated, Interval and Refinement Types</a></h2>
<p>The enumerative/interval types introduced before are syntax sugar of the refinement type.
<code>{a, b, ...}</code> is <code>{I: Typeof(a) | I == a or I == b or ... }</code>, and <code>a..b</code> is desugarized to <code>{I: Typeof(a) | I &gt;= a and I &lt;= b}</code>.</p>
<pre><code class="language-python">{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I &gt;= 1 and I &lt;= 10}
1... &lt;10 == {I: Int | I &gt;= 1 and I &lt; 10}
</code></pre>
<h2 id="refinement-pattern"><a class="header" href="#refinement-pattern">Refinement pattern</a></h2>
<p>Just as <code>_: {X}</code> can be rewritten as <code>X</code> (constant pattern), <code>_: {X: T | Pred}</code> can be rewritten as <code>X: T | Pred</code>.</p>
<pre><code class="language-python"># method `.m` is defined for arrays of length 3 or greater
Array(T, N | N &gt;= 3)
    .m(&amp;self) = ...
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-type"><a class="header" href="#algebraic-type">Algebraic type</a></h1>
<p>Algebraic types are types that are generated by operating types by treating them like algebra.
Operations handled by them include Union, Intersection, Diff, Complement, and so on.
Normal classes can only perform Union, and other operations will result in a type error.</p>
<h2 id="union"><a class="header" href="#union">Union</a></h2>
<p>Union types can give multiple possibilities for types. As the name suggests, they are generated by the <code>or</code> operator.
A typical Union is the <code>Option</code> type. The <code>Option</code> type is a <code>T or NoneType</code> patch type, primarily representing values that may fail.</p>
<pre><code class="language-python">IntOrStr = Int or Str
assert dict.get(&quot;some key&quot;) in (Int or NoneType)

# Implicitly become `T != NoneType`
Option T = T or NoneType
</code></pre>
<h2 id="intersection"><a class="header" href="#intersection">Intersection</a></h2>
<p>Intersection types are got by combining types with the <code>and</code> operation.</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
</code></pre>
<p>As mentioned above, normal classes cannot be combined with the <code>and</code> operation. This is because instances belong to only one class.</p>
<h2 id="diff"><a class="header" href="#diff">Diff</a></h2>
<p>Diff types are got by <code>not</code> operation.
It is better to use <code>and not</code> as a closer notation to English text, but it is recommended to use just <code>not</code> because it fits better alongside <code>and</code> and <code>or</code>.</p>
<pre><code class="language-python">CompleteNum = Add and Sub and Mul and Div and Eq and Ord
Num = CompleteNum not Div not Ord

True = Bool not {False}
OneTwoThree = {1, 2, 3, 4, 5, 6} - {4, 5, 6, 7, 8, 9, 10}
</code></pre>
<h2 id="complement"><a class="header" href="#complement">Complement</a></h2>
<p>Complement types is got by the <code>not</code> operation, which is a unary operation. The <code>not T</code> type is a shorthand for <code>{=} not T</code>.
Intersection with type <code>not T</code> is equivalent to Diff, and Diff with type <code>not T</code> is equivalent to Intersection.
However, this way of writing is not recommended.</p>
<pre><code class="language-python"># the simplest definition of the non-zero number type
NonZero = Not {0}
# deprecated styles
{True} == Bool and not {False} # 1 == 2 + - 1
Bool == {True} not not {False} # 2 == 1 - -1
</code></pre>
<h2 id="true-algebraic-type"><a class="header" href="#true-algebraic-type">True Algebraic type</a></h2>
<p>There are two algebraic types: apparent algebraic types that can be simplified and true algebraic types that cannot be further simplified.
The &quot;apparent algebraic types&quot; include <code>or</code> and <code>and</code> of Enum, Interval, and the Record types.
These are not true algebraic types because they are simplified, and using them as type specifiers will result in a Warning; to eliminate the Warning, you must either simplify them or define their types.</p>
<pre><code class="language-python">assert {1, 2, 3} or {2, 3} == {1, 2, 3}
assert {1, 2, 3} and {2, 3} == {2, 3}
assert -2..-1 or 1..2 == {-2, -1, 1, 2}

i: {1, 2} or {3, 4} = 1 # TypeWarning: {1, 2} or {3, 4} can be simplified to {1, 2, 3, 4}
p: {x = Int, ...} and {y = Int; ...} = {x = 1; y = 2; z = 3}
# TypeWaring: {x = Int, ...} and {y = Int; ...} can be simplified to {x = Int; y = Int; ...}

Point1D = {x = Int; ...}
Point2D = Point1D and {y = Int; ...} # == {x = Int; y = Int; ...}
q: Point2D = {x = 1; y = 2; z = 3}
</code></pre>
<p>True algebraic types include the types <code>Or</code> and <code>And</code>. Classes such as <code>or</code> between classes are of type <code>Or</code>.</p>
<pre><code class="language-python">assert Int or Str == Or(Int, Str)
assert Int and Marker == And(Int, Marker)
</code></pre>
<p>Diff, Complement types are not true algebraic types because they can always be simplified.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependent-type"><a class="header" href="#dependent-type">dependent type</a></h1>
<p>Dependent types are a feature that can be said to be the biggest feature of Erg.
A dependent type is a type that takes a value as an argument. Ordinary polymorphic types can take only types as arguments, but dependent types relax that restriction.</p>
<p>Dependent types are equivalent to <code>[T; N]</code> (<code>Array(T, N)</code>).
This type is determined not only by the content type <code>T</code> but also by the number of contents <code>N</code>. <code>N</code> contains an object of type <code>Nat</code>.</p>
<pre><code class="language-python">a1 = [1, 2, 3]
assert a1 in [Nat; 3]
a2 = [4, 5, 6, 7]
assert a1 in [Nat; 4]
assert a1 + a2 in [Nat; 7]
</code></pre>
<p>If the type object passed in the function argument is related to the return type, write:</p>
<pre><code class="language-python">narray: |N: Nat| {N} -&gt; [{N}; N]
narray(N: Nat): [N; N] = [N; N]
assert array(3) == [3, 3, 3]
</code></pre>
<p>When defining a dependent type, all type arguments must be constants.</p>
<p>Dependent types themselves exist in existing languages, but Erg has the feature of defining procedural methods on dependent types.</p>
<pre><code class="language-python">x=1
f x =
    print! f::x, module::x

# The Phantom type has an attribute called Phantom whose value is the same as the type argument
T X: Int = Class Impl := Phantom X
T(X).
    x self = self::Phantom

T(1).x() # 1
</code></pre>
<p>Type arguments of mutable dependent types can be transitioned by method application.
Transition specification is done with <code>~&gt;</code>.</p>
<pre><code class="language-python"># Note that `Id` is an immutable type and cannot be transitioned
VM!(State: {&quot;stopped&quot;, &quot;running&quot;}! := _, Id: Nat := _) = Class(..., Impl := Phantom! State)
VM!().
    # Variables that do not change can be omitted by passing `_`.
    start! ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.initialize_something!()
        self::set_phantom!(&quot;running&quot;)

# You can also cut out by type argument (only in the module where it's defined)
VM!.new() = VM!(!&quot;stopped&quot;, 1).new()
VM!(&quot;running&quot; ~&gt; &quot;running&quot;).stop!ref!self =
    self.close_something!()
    self::set_phantom!(&quot;stopped&quot;)

vm = VM!.new()
vm.start!()
vm.stop!()
vm.stop!() # TypeError: VM!(!&quot;stopped&quot;, 1) doesn't have .stop!()
# hint: VM!(!&quot;running&quot;, 1) has .stop!()
</code></pre>
<p>You can also embed or inherit existing types to create dependent types.</p>
<pre><code class="language-python">MyArray(T, N) = Inherit[T; N]

# The type of self: Self(T, N) changes in conjunction with .array
MyStruct!(T, N: Nat!) = Class {.array: [T; !N]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-variable-quantified-type"><a class="header" href="#type-variable-quantified-type">Type Variable, quantified type</a></h1>
<p>A type variable is a variable used, for example, to specify the type of subroutine arguments, and its type is arbitrary (not monomorphic).
First, as motivation for introducing type variables, consider the <code>id</code> function, which returns input as is.</p>
<pre><code class="language-python">id x: Int = x
</code></pre>
<p>The <code>id</code> function that returns the input as is is defined for the type <code>Int</code>, but this function can obviously be defined for any type.
Let's use <code>Object</code> for the largest class.</p>
<pre><code class="language-python">id x: Object = x

i = id 1
s = id &quot;foo&quot;
b = id True
</code></pre>
<p>Sure, it now accepts arbitrary types, but there is one problem: the return type is expanded to <code>Object</code>. The return type is expanded to <code>Object</code>.
I would like to see the return type <code>Int</code> if the input is of type <code>Int</code>, and <code>Str</code> if it is of type <code>Str</code>.</p>
<pre><code class="language-python">print! id 1 # &lt;Object object&gt;
id(1) + 1 # TypeError: cannot add `Object` and `Int
</code></pre>
<p>To ensure that the type of the input is the same as the type of the return value, use a <strong>type variable</strong>.
Type variables are declared in <code>||</code>(type variable list).</p>
<pre><code class="language-python">id|T: Type| x: T = x
assert id(1) == 1
assert id(&quot;foo&quot;) == &quot;foo&quot;
assert id(True) == True
</code></pre>
<p>This is called the <strong>universal quantification (universalization)</strong> of the function. There are minor differences, but it corresponds to the function called generics in other languages. A universalized function is called a <strong>polymorphic function</strong>.
Defining a polymorphic function is like defining a function of the same form for all types (Erg prohibits overloading, so the code below cannot really be written).</p>
<pre><code class="language-python">id|T: Type| x: T = x
# pseudo code
id x: Int = x
id x: Str = x
id x: Bool = x
id x: Ratio = x
id x: NoneType = x
...
</code></pre>
<p>Also, the type variable <code>T</code> can be inferred to be of type <code>Type</code> since it is used in the type specification. So <code>|T: Type|</code> can simply be abbreviated to <code>|T|</code>.
You can also omit <code>|T, N| foo: [T; N]</code> if it can be inferred to be other than a type object (<code>T: Type, N: Nat</code>).</p>
<p>You can also provide constraints if the type is too large for an arbitrary type.
Constraints also have advantages, for example, a subtype specification allows certain methods to be used.</p>
<pre><code class="language-python"># T &lt;: Add
# =&gt; T is a subclass of Add
# =&gt; can do addition
add|T &lt;: Add| l: T, r: T = l + r
</code></pre>
<p>In this example, <code>T</code> is required to be a subclass of type <code>Add</code>, and the actual types of <code>l</code> and <code>r</code> to be assigned must be the same.
In this case, <code>T</code> is satisfied by <code>Int</code>, <code>Ratio</code>, etc. So, the addition of <code>Int</code> and <code>Str</code>, for example, is not defined and is therefore rejected.</p>
<p>You can also type it like this.</p>
<pre><code class="language-python">f|
    Y, Z: Type
    X &lt;: Add Y, O1
    O1 &lt;: Add Z, O2
    O2 &lt;: Add X, _
| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>If the annotation list is long, you may want to pre-declare it.</p>
<pre><code class="language-python">f: |Y, Z: Type, X &lt;: Add(Y, O1), O1 &lt;: Add(Z, O2), O2 &lt;: Add(X, O3)| (X, Y, Z) -&gt; O3
f|X, Y, Z| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>Unlike many languages with generics, all declared type variables must be used either in the temporary argument list (the <code>x: X, y: Y, z: Z</code> part) or in the arguments of other type variables.
This is a requirement from Erg's language design that all type variables are inferrable from real arguments.
So information that cannot be inferred, such as the return type, is passed from real arguments; Erg allows types to be passed from real arguments.</p>
<pre><code class="language-python">Iterator T = Trait {
    # Passing return types from arguments.
    # .collect: |K: Type -&gt; Type| (self: Self, {K}) -&gt; K(T)
    .collect(self, K: Type -&gt; Type): K(T) = ...
    ...
}

it = [1, 2, 3].iter().map i -&gt; i + 1
it.collect(Array) # [2, 3, 4].
</code></pre>
<p>Type variables can only be declared during <code>||</code>. However, once declared, they can be used anywhere until they exit scope.</p>
<pre><code class="language-python">f|X|(x: X): () =
    y: X = x.clone()
    log X.__name__
    log X

f 1
# Int
# &lt;class Int&gt;
</code></pre>
<p>You can also explicitly monophasize at the time of use as follows</p>
<pre><code class="language-python">f: Int -&gt; Int = id|Int|
</code></pre>
<p>In that case, the specified type takes precedence over the type of the actual argument (failure to match will result in a type error that the type of the actual argument is wrong).
That is, if the actual object passed can be converted to the specified type, it will be converted; otherwise, a compile error will result.</p>
<pre><code class="language-python">assert id(1) == 1
assert id|Int|(1) in Int
assert id|Ratio|(1) in Ratio
# You can also use keyword arguments
assert id|T: Int|(1) == 1
id|Int|(&quot;str&quot;) # TypeError: id|Int| is type `Int -&gt; Int` but got Str
</code></pre>
<p>When this syntax is batting against comprehensions, you need to enclose it in <code>()</code>.</p>
<pre><code class="language-python"># {id|Int| x | x &lt;- 1..10} would be interpreted as {id | ...} will be interpreted as.
{(id|Int| x) | x &lt;- 1..10}
</code></pre>
<p>A type variable cannot be declared with the same name as a type that already exists. This is because all type variables are constants.</p>
<pre><code class="language-python">I: Type
# ↓ invalid type variable, already exists
f|I: Type| ... = ...
</code></pre>
<h2 id="type-arguments-in-method-definitions"><a class="header" href="#type-arguments-in-method-definitions">Type arguments in method definitions</a></h2>
<p>Type arguments on the left-hand side are treated as bound variables by default.</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(T, N).
    foo(x) = ...
</code></pre>
<p>Using another type variable name will result in a warning.</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(U, M). # Warning: K's type variable names are 'T' and 'N'
    foo(x) = ...
</code></pre>
<p>Constants are the same in all namespaces since their definition, so of course they cannot be used for type variable names.</p>
<pre><code class="language-python">N = 1
K(N: Nat) = ... # NameError: N is already defined

L(M: Nat) = ...
# Defined only if M == N == 1
L(N).
    foo(self, x) = ...
# defined for any M: Nat
L(M).
    .bar(self, x) = ...
</code></pre>
<p>You cannot have multiple definitions for each type argument, but you can define methods with the same name because there is no relationship between dependent types that are not assigned type arguments (non-primitive-kind) and dependent types that are assigned (primitive-kind).</p>
<pre><code class="language-python">K(I: Int) = ...
K.
    # K is not a true type (atomic Kind), so we cannot define a method
    # This is not a method (more like a static method)
    foo(x) = ...
K(0).
    foo(self, x): Nat = ...
</code></pre>
<h2 id="all-symmetric-types"><a class="header" href="#all-symmetric-types">All symmetric types</a></h2>
<p>The <code>id</code> function defined in the previous section is a function that can be of any type. So what is the type of the <code>id</code> function itself?</p>
<pre><code class="language-python">print! classof(id) # |T: Type| T -&gt; T
</code></pre>
<p>We get a type <code>|T: Type| T -&gt; T</code>. This is called a <strong>closed universal quantified type/universal type</strong>, which is <code>['a. ...]'</code> in ML, and <code>forall t. ...</code> in Haskell. Why the adjective &quot;closed&quot; is used is discussed below.</p>
<p>There is a restriction on the closed universal quantified type: only subroutine types can be made universal quantified, i.e., only subroutine types can be placed in the left clause. But this is sufficient, since subroutines are the most basic control structure in Erg, so when we say &quot;I want to handle arbitrary X,&quot; i.e., I want a subroutine that can handle arbitrary X. So, the quantified type has the same meaning as the polymorphic function type. From now on, this type is basically called polymorphic function type.</p>
<p>Like anonymous functions, polymorphic types have arbitrary type variable names, but they all have the same value.</p>
<pre><code class="language-python">assert (|T: Type| T -&gt; T) == (|U: Type| U -&gt; U)
</code></pre>
<p>The equality is satisfied when there is an alpha equivalence, as in the lambda calculus. Since there are some restrictions on operations on types, equivalence determination is always possible (if we don't consider the stoppage property).</p>
<h2 id="subtyping-of-polymorphic-function-types"><a class="header" href="#subtyping-of-polymorphic-function-types">Subtyping of Polymorphic Function Types</a></h2>
<p>A polymorphic function type can be any function type. This means that there is a subtype relationship with any function type. Let's look at this relationship in detail.</p>
<p>A type in which the type variable is defined on the left-hand side and used on the right-hand side, such as <code>OpenFn T: Type = T -&gt; T</code>, is called an <strong>open universal type</strong>.
In contrast, a type in which type variables are defined and used on the right-hand side, such as <code>ClosedFn = |T: Type| T -&gt; T</code>, is called a <strong>closed universal type</strong>.</p>
<p>An open universal type is a supertype of all isomorphic &quot;true&quot; types. In contrast, a closed universal type is a subtype of all isomorphic true types.</p>
<pre><code class="language-python">(|T: Type| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)
</code></pre>
<p>You may remember that closed ones are smaller/open ones are larger.
But why is this so? For a better understanding, let's consider an instance of each.</p>
<pre><code class="language-python"># id: |T: Type| T -&gt; T
id|T|(x: T): T = x

# iid: Int -&gt; Int
iid(x: Int): Int = x

# return arbitrary function as is
id_arbitrary_fn|T|(f1: T -&gt; T): (T -&gt; T) = f
# id_arbitrary_fn(id) == id
# id_arbitrary_fn(iid) == iid

# return the poly correlation number as it is
id_poly_fn(f2: (|T| T -&gt; T)): (|T| T -&gt; T) = f
# id_poly_fn(id) == id
id_poly_fn(iid) # TypeError

# Return Int type function as is
id_int_fn(f3: Int -&gt; Int): (Int -&gt; Int) = f
# id_int_fn(id) == id|Int|
# id_int_fn(iid) == iid
</code></pre>
<p>Since <code>id</code>, which is of type <code>|T: Type| T -&gt; T</code>, can be assigned to a parameter <code>f3</code> of type <code>Int -&gt; Int</code>, we may consider <code>(|T| T -&gt; T) &lt; (Int -&gt; Int)</code>.
Conversely, <code>iid</code>, which is of type <code>Int -&gt; Int</code>, cannot be assigned to parameter <code>f2</code> of type <code>(|T| T -&gt; T)</code>, but it can be assigned to parameter <code>f1</code> of type <code>T -&gt; T</code>, so <code>(Int -&gt; Int) &lt; (T -&gt; T)</code>.
Therefore, it is indeed <code>(|T| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)</code>.</p>
<h2 id="quantified-types-and-dependent-types"><a class="header" href="#quantified-types-and-dependent-types">Quantified Types and Dependent Types</a></h2>
<p>What is the relationship between dependent types and quantified types (polymorphic function types) and what is the difference between them?
We can say that a dependent type is a type that takes arguments, and an quantified type is a type that gives arbitrariness to the arguments.</p>
<p>The important point is that there are no type arguments in the closed, polymorphic type itself. For example, the polymorphic function type <code>|T| T -&gt; T</code> is a type that takes a polymorphic function <strong>only</strong>, and its definition is closed. You cannot define methods, etc. using its type argument <code>T</code>.</p>
<p>In Erg, the type itself is also a value, so types that take arguments, such as function types, will probably be dependent types. In other words, polymorphic function types are both a quantified type and a dependent type.</p>
<pre><code class="language-python">PolyFn = Patch(|T| T -&gt; T)
PolyFn.
    type self = T # NameError: cannot find 'T'
DepFn T = Patch(T -&gt; T)
DepFn.
    type self =
        log &quot;by DepFn&quot;
        T

assert (Int -&gt; Int).type() == Int # by DepFn
assert DepFn(Int).type() == Int # by DepFn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subtyping"><a class="header" href="#subtyping">Subtyping</a></h1>
<p>In Erg, class inclusion can be determined with the comparison operators <code>&lt;</code>, <code>&gt;</code>.</p>
<pre><code class="language-python">Nat &lt; Int
Int &lt; Object
1... _ &lt; Nat
{1, 2} &gt; {1}
{=} &gt; {x = Int}
{I: Int | I &gt;= 1} &lt; {I: Int | I &gt;= 0}
</code></pre>
<p>Note that this has a different meaning than the <code>&lt;:</code> operator. It declares that the class on the left-hand side is a subtype of the type on the right-hand side, and is meaningful only at compile-time.</p>
<pre><code class="language-python">C &lt;: T # T: StructuralType
f|D &lt;: E| ...

assert F &lt; G
</code></pre>
<p>You can also specify <code>Self &lt;: Add</code> for a polymorphic subtype specification, for example <code>Self(R, O) &lt;: Add(R, O)</code>.</p>
<h2 id="structural-types-and-class-type-relationships"><a class="header" href="#structural-types-and-class-type-relationships">Structural types and class type relationships</a></h2>
<p>Structural types are types for structural typing and are considered to be the same object if they have the same structure.</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}

assert T == U
t: T = {i = 1}
assert t in T
assert t in U
</code></pre>
<p>In contrast, classes are types for notational typing and cannot be compared structurally to types and instances.</p>
<pre><code class="language-python">C = Class {i = Int}
D = Class {i = Int}

assert C == D # TypeError: cannot compare classes
c = C.new {i = 1}
assert c in C
assert not c in D
</code></pre>
<h2 id="subtyping-of-subroutines"><a class="header" href="#subtyping-of-subroutines">Subtyping of subroutines</a></h2>
<p>Arguments and return values of subroutines take only a single class.
In other words, you cannot directly specify a structural type or a trait as the type of a function.
It must be specified as &quot;a single class that is a subtype of that type&quot; using the partial type specification.</p>
<pre><code class="language-python"># OK
f1 x, y: Int = x + y
# NG
f2 x, y: Add = x + y
# OK
# A is some concrete class
f3&lt;A &lt;: Add&gt; x, y: A = x + y
</code></pre>
<p>Type inference in subroutines also follows this rule. When a variable in a subroutine has an unspecified type, the compiler first checks to see if it is an instance of one of the classes, and if not, looks for a match in the scope of the trait. If it still cannot find one, a compile error occurs. This error can be resolved by using a structural type, but since inferring an anonymous type may have unintended consequences for the programmer, it is designed to be explicitly specified by the programmer with <code>Structural</code>.</p>
<h2 id="class-upcasting"><a class="header" href="#class-upcasting">Class upcasting</a></h2>
<pre><code class="language-python">i: Int
i as (Int or Str)
i as (1..10)
i as {I: Int | I &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cast"><a class="header" href="#cast">Cast</a></h1>
<h2 id="upcasting"><a class="header" href="#upcasting">Upcasting</a></h2>
<p>Because Python is a language that uses duck typing, there is no concept of casting. There is no need to upcast, and there is essentially no downcasting.
However, Erg is statically typed, so there are times when casting must be done.
A simple example is <code>1 + 2.0</code>: the <code>+</code>(Int, Ratio), or Int(&lt;: Add(Ratio, Ratio)) operation is not defined in the Erg language specification. This is because <code>Int &lt;: Ratio</code>, so 1 is upcast to 1.0, an instance of Ratio.</p>
<p>~~The Erg extended bytecode adds type information to BINARY_ADD, in which case the type information is Ratio-Ratio. In this case, the BINARY_ADD instruction does the casting of Int, so no special instruction specifying the cast is inserted. So, for example, even if you override a method in a child class, if you specify the parent as the type, type coercion is performed and the method is executed in the parent's method (name modification is performed at compile time to refer to the parent's method). The compiler only performs type coercion validation and name modification. The runtime does not cast objects (currently. Cast instructions may be implemented for execution optimization). ~~</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    # Override requires Override decorator
    @Override
    greet!() = print! &quot;Hello from Child&quot;

greet! p: Parent = p.greet!()

parent = Parent.new()
child = Child.new()

parent # &quot;Hello from Parent&quot; greet!
child # &quot;Hello from Parent&quot;
</code></pre>
<p>This behavior does not create an incompatibility with Python. In the first place, Python does not specify the type of a variable, so that all variables are typed as type variables, so to speak. Since type variables choose the smallest type they can fit, the same behavior as in Python is achieved if you do not specify a type in Erg.</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    greet!() = print! &quot;Hello from Child&quot; Child.

greet! some = some.greet!()

parent = Parent.new()
child = Child.new()

parent # &quot;Hello from Parent&quot; greet!
child # &quot;Hello from Child&quot;
</code></pre>
<p>You can also use <code>.from</code> and <code>.into</code>, which are automatically implemented for types that are inherited from each other.</p>
<pre><code class="language-python">assert 1 == 1.0
assert Ratio.from(1) == 1.0
assert 1.into&lt;Ratio&gt;() == 1.0
</code></pre>
<h2 id="downcasting"><a class="header" href="#downcasting">Downcasting</a></h2>
<p>Since downcasting is generally unsafe and the conversion method is non-trivial, we instead implement <code>TryFrom.try_from</code>.</p>
<pre><code class="language-python">IntTryFromFloat = Patch Int
IntTryFromFloat.
    try_from r: Float =
        if r.ceil() == r:
            then: r.ceil()
            else: Error &quot;conversion failed&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-type"><a class="header" href="#mutable-type">Mutable Type</a></h1>
<blockquote>
<p><strong>Warning</strong>: The information in this section is old and contains some errors.</p>
</blockquote>
<p>By default all types in Erg are immutable, i.e. their internal state cannot be updated.
But you can of course also define mutable types. Variable types are declared with <code>!</code>.</p>
<pre><code class="language-python">Person! = Class({name = Str; age = Nat!})
Person!.
    greet! ref! self = print! &quot;Hello, my name is {self::name}. I am {self::age}.&quot;
    inc_age!ref!self = self::name.update!old -&gt; old + 1
</code></pre>
<p>To be precise, a type whose base type is a mutable type, or a composite type containing mutable types, must have a <code>!</code> at the end of the type name. Types without <code>!</code> can exist in the same namespace and are treated as separate types.
In the example above, the <code>.age</code> attribute is mutable and the <code>.name</code> attribute is immutable. If even one attribute is mutable, the whole is mutable.</p>
<p>Mutable types can define procedural methods that rewrite instances, but having procedural methods does not necessarily make them mutable. For example, the array type <code>[T; N]</code> implements a <code>sample!</code> method that randomly selects an element, but of course does not destructively modify the array.</p>
<p>Destructive operations on mutable objects are primarily done via the <code>.update!</code> method. The <code>.update!</code> method is a higher-order procedure that updates <code>self</code> by applying the function <code>f</code>.</p>
<pre><code class="language-python">i = !1
i.update! old -&gt; old + 1
assert i == 2
</code></pre>
<p>The <code>.set!</code> method simply discards the old content and replaces it with the new value. .set!x = .update!_ -&gt; x.</p>
<pre><code class="language-python">i = !1
i.set! 2
assert i == 2
</code></pre>
<p>The <code>.freeze_map</code> method operates on values ​​unchanged.</p>
<pre><code class="language-python">a = [1, 2, 3].into [Nat; !3]
x = a.freeze_map a: [Nat; 3] -&gt; a.iter().map(i -&gt; i + 1).filter(i -&gt; i % 2 == 0).collect(Array)
</code></pre>
<p>In a polymorphic immutable type the type argument <code>T</code> of the type is implicitly assumed to be immutable.</p>
<pre><code class="language-python"># ImmutType &lt; Type
KT: ImmutType = Class ...
K!T: Type = Class ...
</code></pre>
<p>In the standard library, variable <code>(...)!</code> types are often based on immutable <code>(...)</code> types. However, <code>T!</code> and <code>T</code> types have no special linguistic relationship, and may not be constructed as such <a href="type/18_mut.html#1"><sup id="f1">1</sup></a> .</p>
<p>Note that there are several types of object mutability.
Below we will review the immutable/mutable semantics of the built-in collection types.</p>
<pre><code class="language-python"># array type
## immutable types
[T; N] # Cannot perform mutable operations
## mutable types
[T!; N] # can change contents one by one
[T; !N] # variable length, content is immutable but can be modified by adding/deleting elements
[!T; N] # The content is an immutable object, but it can be replaced by a different type (actually replaceable by not changing the type)
[!T; !N] # type and length can be changed
[T!; !N] # content and length can be changed
[!T!; N] # content and type can be changed
[!T!; !N] # Can perform all sorts of mutable operations
</code></pre>
<p>Of course, you don't have to memorize and use all of them.
For variable array types, just add <code>!</code> to the part you want to be variable, and practically <code>[T; N]</code>, <code>[T!; N]</code>, <code>[T; !N]</code>, <code> [T!; !N]</code> can cover most cases.</p>
<p>These array types are syntactic sugar, the actual types are:</p>
<pre><code class="language-python"># actually 4 types
[T; N] = Array(T, N)
[T; !N] = Array!(T, !N)
[!T; N] = ArrayWithMutType!(!T, N)
[!T; !N] = ArrayWithMutTypeAndLength!(!T, !N)
[T!; !N] = Array!(T!, !N)
[!T!; N] = ArrayWithMutType!(!T!, N)
[!T!; !N] = ArrayWithMutTypeAndLength!(!T!, !N)
</code></pre>
<p>This is what it means to be able to change the type.</p>
<pre><code class="language-python">a = [1, 2, 3].into [!Nat; 3]
a.map!(_ -&gt; &quot;a&quot;)
a: [!Str; 3]
</code></pre>
<p>The same is true for other collection types.</p>
<pre><code class="language-python"># tuple type
## immutable types
(T, U) # No change in number of elements, contents cannot be changed
## mutable types
(T!, U) # constant number of elements, first element can be changed
(T, U)! # No change in number of elements, content can be replaced
...
</code></pre>
<pre><code class="language-python"># Set type
## immutable types
{T; N} # number of immutable elements, contents cannot be changed
## mutable types
{T!; N} # number of immutable elements, content can be changed (one by one)
{T; N}! # Number of variable elements, content cannot be changed
{T!; N}! # Number of variable elements, content can be changed
...
</code></pre>
<pre><code class="language-python"># Dictionary type
## immutable types
{K: V} # immutable length, contents cannot be changed
## mutable types
{K: V!} # constant length, values ​​can be changed (one by one)
{K: V}! # Variable length, content cannot be changed, but can be added or deleted by adding or removing elements, content type can also be changed
...
</code></pre>
<pre><code class="language-python"># Record type
## immutable types
{x = Int; y = Str} # content cannot be changed
## mutable types
{x = Int!; y = Str} # can change the value of x
{x = Int; y = Str}! # replace any instance of {x = Int; y = Str}
...
</code></pre>
<p>A type <code>(...)</code> that simply becomes <code>T! = (...)!</code> when <code>T = (...)</code> is called a simple structured type. A simple structured type can also be said (semantically) to be a type that has no internal structure.
Arrays, tuples, sets, dictionaries, and record types are all non-simple structured types, but Int and Sieve types are.</p>
<pre><code class="language-python"># Sieve type
## Enums
{1, 2, 3} # one of 1, 2, 3, cannot be changed
{1, 2, 3}! # 1, 2, 3, you can change
## interval type
1..12 # 1 to 12, cannot be changed
1..12! # Any of 1-12, you can change
## Sieve type (general type)
{I: Int | I % 2 == 0} # even type, immutable
{I: Int! | I % 2 == 0} # even type, can be changed
{I: Int | I % 2 == 0}! # Exactly the same type as above, but the above notation is preferred
</code></pre>
<p>From the above explanation, mutable types include not only those that are themselves mutable, but also those whose internal types are mutable.
Types such as <code>{x: Int!}</code> and <code>[Int!; 3]</code> are internal mutable types where the object inside is mutable and the instance itself is not mutable.</p>
<p>For a type <code>K!(T, U)</code> that has internal structure and has a <code>!</code> on the type constructor itself, <code>*self</code> can change the whole object. Local changes are also possible.
However, it is desirable to keep the change authority as local as possible, so if only <code>T</code> can be changed, it is better to use <code>K(T!, U)</code>.
And for the type <code>T!</code> which has no internal structure, this instance is simply a box of <code>T</code> which can be swapped. A method cannot change the type.</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> It is intentional that <code>T!</code> and <code>T</code> types have no special linguistic relationship. It's a design. If there is a relationship, for example, if the <code>T</code>/<code>T!</code> type exists in the namespace, it will not be possible to introduce the <code>T!</code>/<code>T</code> type from another module. Also, the mutable type is not uniquely defined for the immutable type. Given the definition <code>T = (U, V)</code>, the possible variable subtypes of <code>T!</code> are <code>(U!, V)</code> and <code>(U, V!)</code>. <a href="type/18_mut.html#f1">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><p>In the following, we will discuss more advanced type systems. Beginners do not have to read all the sections.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-type-with-default-arguments"><a class="header" href="#function-type-with-default-arguments">Function type with default arguments</a></h1>
<p>First, let's look at an example of using default arguments.</p>
<pre><code class="language-python">f: (Int, Int, z := Int) -&gt; Int
f(x, y, z := 0) = x + y + z

g: (Int, Int, z := Int, w := Int) -&gt; Int
g(x, y, z := 0, w := 1) = x + y + z + w

fold: ((Int, Int) -&gt; Int, [Int], acc := Int) -&gt; Int
fold(f, [], acc) = acc
fold(f, arr, acc := 0) = fold(f, arr[1..], f(acc, arr[0]))
assert fold(f, [1, 2, 3]) == 6
assert fold(g, [1, 2, 3]) == 8
</code></pre>
<p>Arguments after <code>:=</code> are default arguments.
The subtyping rules are as follows.</p>
<pre><code class="language-python">((X, y := Y) -&gt; Z) &lt;: (X -&gt; Z)
((X, y := Y, ...) -&gt; Z) &lt;: ((X, ...) -&gt; Z)
</code></pre>
<p>The first means that a function with default arguments can be identified with a function without.
The second means that any default argument can be omitted.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-erasure"><a class="header" href="#type-erasure">Type erasure</a></h1>
<p>Type erasure is the process of setting a type argument to <code>_</code> and deliberately discarding its information. Type erasure is a feature of many polymorphic languages, but in the context of Erg's syntax, it is more accurate to call it type argument erasure.</p>
<p>The most common example of a type that has been type-erased is <code>[T, _]</code>. Arrays are not always known their length at compile-time. For example, <code>sys.argv</code>, which refers to command line arguments, is of type <code>[Str, _]</code>. Since Erg's compiler has no way of knowing the length of command line arguments, information about their length must be given up.
However, a type that has been type-erased becomes a supertype of a type that has not been (e.g. <code>[T; N] &lt;: [T; _]</code>), so it can accept more objects.
Objects of type <code>[T; N]</code> can of course use methods of type <code>[T; _]</code>, but the <code>N</code> information is erased after use. If the length does not change, then it is possible to use <code>[T; N]</code> in the signature. If the length remains the same, it must be indicated by a signature.</p>
<pre><code class="language-python"># Functions that are guaranteed to not change the length of the array (e.g., sort)
f: [T; N] -&gt; [T; N] # functions that do not (f: [T; N])
# functions that do not (e.g. filter)
g: [T; n] -&gt; [T; _]
</code></pre>
<p>If you use <code>_</code> in the type specification itself, the type is upcast to <code>Object</code>.
For non-type type arguments (Int, Bool, etc.), the parameter with <code>_</code> will be undefined.</p>
<pre><code class="language-python">i: _ # i: Object
[_; _] == [Object; _] == Array
</code></pre>
<p>Type erasure is not the same as omitting a type specification. Once the type argument information has been erased, it will not be returned unless you assert it again.</p>
<pre><code class="language-python">implicit = (1..5).iter().map(i -&gt; i * 2).to_arr()
explicit = (1..5).iter().map(i -&gt; i * 2).into(Array(Nat))
</code></pre>
<p>In Rust, this corresponds to the following code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let partial = (1..6).iter().map(|i| i * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Erg does not allow partial omission of types, but uses higher-order kind polymorphism instead.</p>
<pre><code class="language-python"># collect is a higher-order Kind method that takes Kind
hk = (1..5).iter().map(i -&gt; i * 2).collect(Array)
hk: Array(Int)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="existential-type"><a class="header" href="#existential-type">Existential type</a></h1>
<p>If there is a for-all type corresponding to ∀, it is natural to assume that there is an existential type corresponding to ∃.
Existential types are not difficult. You already know the existential type, just not consciously aware of it as such.</p>
<pre><code class="language-python">T: Trait
f x: T = ...
</code></pre>
<p>The trait <code>T</code> above is used as the existential type.
In contrast, <code>T</code> in the lower case is only a trait, and <code>X</code> is an for-all type.</p>
<pre><code class="language-python">f|X &lt;: T| x: X = ...
</code></pre>
<p>In fact, the existential type is replaced by an for-all type. So why is there such a thing as an existential type?
First of all, as we saw above, existential types do not involve type variables, which simplifies type specification.
Also, since the type variable can be removed, it is possible to construct a type that would have rank 2 or higher if it were an all-presumptive type.</p>
<pre><code class="language-python">show_map f: (|T| T -&gt; T), arr: [Show; _] =
    arr.map x -&gt;
        y = f x
        log y
        y
</code></pre>
<p>However, as you can see, the existential type forgets or expands the original type, so if you do not want to expand the return type, you must use the for-all type.
Conversely, types that are only taken as arguments and are not relevant to the return value may be written as existential types.</p>
<pre><code class="language-python"># id(1): I want it to be Int
id|T|(x: T): T = x
# |S &lt;: Show|(s: S) -&gt; () is redundant
show(s: Show): () = log s
</code></pre>
<p>By the way, a class is not called an existential type. A class is not called an existential type, because its elemental objects are predefined.
Existential type means any type that satisfies a certain trait, and it is not the place to know what type is actually assigned.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generalized-algebraic-data-types-gadts"><a class="header" href="#generalized-algebraic-data-types-gadts">Generalized Algebraic Data Types (GADTs)</a></h1>
<p>Erg can create Generalized Algebraic Data Types (GADTs) by classifying Or types.</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
Cons T = Class {head = T; rest = List T}, Impl := Unpack
List T: Type = Class(Nil T or Cons T)
List.
    nil|T|() = Self(T).new Nil(T).new()
    cons head, rest | T = Self(T).new Cons(T).new(head, rest)
    head self = match self:
        {head; ...}: Cons_ -&gt; head
        _: Nil -&gt; panic &quot;empty list&quot;
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil.head() # RuntimeError: &quot;empty list&quot;
</code></pre>
<p>The reason we say <code>List.nil|T|() = ...</code> instead of <code>List(T).nil() = ...</code> is that we don't need to specify the type when using it.</p>
<pre><code class="language-python">i = List.nil()
_: List Int = cons 1, i
</code></pre>
<p>The <code>List T</code> defined here is GADTs, but it's a naive implementation and doesn't show the true value of GADTs.
For example, the <code>.head</code> method above will throw a runtime error if the body is empty, but this check can be done at compile time.</p>
<pre><code class="language-python">List: (Type, {&quot;Empty&quot;, &quot;Nonempty&quot;}) -&gt; Type
List T, &quot;Empty&quot; = Class(Impl := Phantom T)
List T, &quot;Nonempty&quot; = Class {head = T; rest = List(T, _)}, Impl := Unpack
List.
    nil|T|() = Self(T, &quot;Empty&quot;).new Nil(T).new()
    cons head, rest | T = Self(T, &quot;Nonempty&quot;).new {head; rest}
List(T, &quot;Nonempty&quot;).
    head {head; ...} = head
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil().head() # TypeError
</code></pre>
<p>An example of GADTs that is often explained on the street is a list that can judge whether the contents are empty or not by type as above.
Erg can be further refined to define a list with length.</p>
<pre><code class="language-python">List: (Type, Nat) -&gt; Type
List T, 0 = Class(Impl := Phantom T)
List T, N = Class {head = T; rest = List(T, N-1)}, Impl := Unpack
List.
    nil|T|() = Self(T, 0).new Nil(T).new()
    cons head, rest | T, N = Self(T, N).new {head; rest}
List(_, N | N &gt;= 1).
    head {head; ...} = head
List(_, N | N &gt;= 2).
    pair {head = first; rest = {head = second; ...}} = [first, second]
{nil; cons; ...} = List

print! cons(1, cons(2, nil)).pair() # [1, 2]
print! cons(1, nil).pair() # TypeError
print! cons(1, nil).head() # 1
print! nil. head() # TypeError
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-type-with-keyword-arguments"><a class="header" href="#function-type-with-keyword-arguments">Function type with keyword arguments</a></h1>
<pre><code class="language-python">h(f) = f(y: 1, x: 2)
h: |T: Type|((y: Int, x: Int) -&gt; T) -&gt; T
</code></pre>
<p>The subtyping rules for functions with keyword arguments are as follows.</p>
<pre><code class="language-python">((x: T, y: U) -&gt; V) &lt;: ((T, U) -&gt; V) # x, y are arbitrary keyword parameters
((y: U, x: T) -&gt; V) &lt;: ((x: T, y: U) -&gt; V)
((x: T, y: U) -&gt; V) &lt;: ((y: U, x: T) -&gt; V)
</code></pre>
<p>This means that keyword arguments can be deleted or replaced.
But you can't do both at the same time.
That is, you cannot cast <code>(x: T, y: U) -&gt; V</code> to <code>(U, T) -&gt; V</code>.
Note that keyword arguments are attached only to top-level tuples, and not to arrays or nested tuples.</p>
<pre><code class="language-python">Valid: [T, U] -&gt; V
Invalid: [x: T, y: U] -&gt; V
Valid: (x: T, ys: (U,)) -&gt; V
Invalid: (x: T, ys: (y: U,)) -&gt; V
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">Kind</a></h1>
<p>Everything is typed in Erg. Types themselves are no exception. <strong>kind</strong> represents the &quot;type of type&quot;. For example, <code>Int</code> belongs to <code>Type</code>, just as <code>1</code> belongs to <code>Int</code>. <code>Type</code> is the simplest kind, the <strong>atomic kind</strong>. In type-theoretic notation, <code>Type</code> corresponds to <code>*</code>.</p>
<p>In the concept of kind, what is practically important is one or more kinds (multinomial kind). One-term kind, for example <code>Option</code>, belongs to it. A unary kind is represented as <code>Type -&gt; Type</code> <a href="type/advanced/kind.html#1"><sup id="f1">1</sup></a>. A <strong>container</strong> such as <code>Array</code> or <code>Option</code> is specifically a polynomial kind that takes a type as an argument.
As the notation <code>Type -&gt; Type</code> indicates, <code>Option</code> is actually a function that receives a type <code>T</code> and returns a type <code>Option T</code>. However, since this function is not a function in the usual sense, it is usually called the unary kind.</p>
<p>Note that <code>-&gt;</code> itself, which is an anonymous function operator, can also be seen as a kind when it receives a type and returns a type.</p>
<p>Also note that a kind that is not an atomic kind is not a type. Just as <code>-1</code> is a number but <code>-</code> is not, <code>Option Int</code> is a type but <code>Option</code> is not. <code>Option</code> etc. are sometimes called type constructors.</p>
<pre><code class="language-python">assert not Option in Type
assert Option in Type -&gt; Type
</code></pre>
<p>So code like the following will result in an error:
In Erg, methods can only be defined in atomic kinds, and the name <code>self</code> cannot be used anywhere other than the first argument of a method.</p>
<pre><code class="language-python">#K is an unary kind
K: Type -&gt; Type
K T = Class...
K.
    foo x = ... # OK, this is like a so-called static method
    bar self, x = ... # TypeError: cannot define a method to a non-type object
K(T).
    baz self, x = ... # OK
</code></pre>
<p>Examples of binary or higher kinds are <code>{T: U}</code>(: <code>(Type, Type) -&gt; Type</code>), <code>(T, U, V)</code>(: <code>(Type, Type, Type) - &gt; Type</code>), ... and so on.</p>
<p>There is also a zero-term kind <code>() -&gt; Type</code>. This is sometimes equated with an atomic kind in type theory, but is distinguished in Erg. An example is <code>Class</code>.</p>
<pre><code class="language-python">Nil = Class()
</code></pre>
<h2 id="containment-of-kind"><a class="header" href="#containment-of-kind">Containment of kind</a></h2>
<p>There is also a partial type relation, or rather a partial kind relation, between multinomial kinds.</p>
<pre><code class="language-python">K T = ...
L = Inherit K
L&lt;: K
</code></pre>
<p>That is, for any <code>T</code>, if <code>L T &lt;: K T</code>, then <code>L &lt;: K</code>, and vice versa.</p>
<pre><code class="language-python">∀T. L T &lt;: K T &lt;=&gt; L &lt;: K
</code></pre>
<h2 id="higher-kind"><a class="header" href="#higher-kind">higher kind</a></h2>
<p>There is also a higher-order kind. This is a kind of the same concept as a higher-order function, a kind that receives a kind itself. <code>(Type -&gt; Type) -&gt; Type</code> is a higher kind. Let's define an object that belongs to a higher kind.</p>
<pre><code class="language-python">IntContainerOf K: Type -&gt; Type = K Int
assert IntContainerOf Option == Option Int
assert IntContainerOf Result == Result Int
assert IntContainerOf in (Type -&gt; Type) -&gt; Type
</code></pre>
<p>The bound variables of a polynomial kind are usually denoted as K, L, ..., where K is K for Kind.</p>
<h2 id="set-kind"><a class="header" href="#set-kind">set kind</a></h2>
<p>In type theory, there is the concept of a record. This is almost the same as the Erg record <a href="type/advanced/kind.html#2"><sup id="f2">2</sup></a>.</p>
<pre><code class="language-python"># This is a record, and it corresponds to what is called a record in type theory
{x = 1; y = 2}
</code></pre>
<p>When all record values ​​were types, it was a kind of type called a record type.</p>
<pre><code class="language-python">assert {x = 1; y = 2} in {x = Int; y = Int}
</code></pre>
<p>A record type types a record. A good guesser might have thought that there should be a &quot;record kind&quot; to type the record type. Actually it exists.</p>
<pre><code class="language-python">log Typeof {x = Int; y = Int} # {{x = Int; y = Int}}
</code></pre>
<p>A type like <code>{{x = Int; y = Int}}</code> is a record kind. This is not a special notation. It is simply an enumeration type that has only <code>{x = Int; y = Int}</code> as an element.</p>
<pre><code class="language-python">Point = {x = Int; y = Int}
Pointy = {Point}
</code></pre>
<p>An important property of record kind is that if <code>T: |T|</code> and <code>U &lt;: T</code> then <code>U: |T|</code>.
This is also evident from the fact that enums are actually syntactic sugar for sieve types.</p>
<pre><code class="language-python"># {c} == {X: T | X == c} for normal objects, but
# Equality may not be defined for types, so |T| == {X | X &lt;: T}
{Point} == {P | P &lt;: Point}
</code></pre>
<p><code>U &lt;: T</code> in type constraints is actually syntactic sugar for <code>U: |T|</code>.
A kind that is a set of such types is commonly called a set kind. Setkind also appears in the Iterator pattern.</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<h2 id="type-inference-for-polynomial-kinds"><a class="header" href="#type-inference-for-polynomial-kinds">Type inference for polynomial kinds</a></h2>
<pre><code class="language-python">Container K: Type -&gt; Type, T: Type = Patch K(T, T)
Container (K).
    f self = ...
Option T: Type = Patch T or NoneType
Option(T).
    f self = ...
Fn T: Type = Patch T -&gt; T
Fn(T).
    f self = ...
Fn2 T, U: Type = Patch T -&gt; U
Fn2(T, U).
    f self = ...

(Int -&gt; Int).f() # which one is selected?
</code></pre>
<p>In the example above, which patch would the method <code>f</code> choose?
Naively, <code>Fn T</code> seems to be chosen, but <code>Fn2 T, U</code> is also possible, <code>Option T</code> includes <code>T</code> as it is, so any type is applicable, <code>Container K , T</code> also matches <code> `-&gt;`(Int, Int)</code>, i.e. <code>Container(`-&gt;`, Int)</code> as ```Int -&gt; Int`. So all four patches above are possible options.</p>
<p>In this case, patches are selected according to the following priority criteria.</p>
<ul>
<li>Any <code>K(T)</code> (e.g. <code>T or NoneType</code>) preferentially matches <code>Type -&gt; Type</code> over <code>Type</code>.</li>
<li>Any <code>K(T, U)</code> (e.g. <code>T -&gt; U</code>) matches <code>(Type, Type) -&gt; Type</code> preferentially over <code>Type</code>.
*Similar criteria apply for kind of 3 or more.</li>
<li>The one that requires fewer type variables to replace is chosen. For example, <code>Int -&gt; Int</code> is <code>T -&gt; T</code> rather than <code>K(T, T)</code> (replacement type variables: K, T) or <code>T -&gt; U</code> (replacement type variables: T, U). `(replacement type variable: T) is matched preferentially.</li>
<li>If the number of replacements is also the same, an error is given as being unselectable.</li>
</ul>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> In type theory notation, <code>*=&gt;*</code> <a href="type/advanced/kind.html#f1">↩</a></span></p>
<p><span id="2" style="font-size:x-small"><sup>2</sup> There are subtle differences such as visibility. <a href="type/advanced/kind.html#f2">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="marker-trait"><a class="header" href="#marker-trait">Marker Trait</a></h1>
<p>Marker traits are traits without required attributes. That is, you can Impl without implementing any method.
It seems meaningless without the required attribute, but since the information that it belongs to the trait is registered, you can use the patch method or get special treatment by the compiler.</p>
<p>All marker traits are subsumed by the <code>Marker</code> trait.
<code>Light</code> provided as standard is a kind of marker trait.</p>
<pre><code class="language-python">Light = Subsume Marker
</code></pre>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat} and Light
</code></pre>
<pre><code class="language-python">M = Subsume Marker

MarkedInt = Inherit Int, Impl := M

i = MarkedInt.new(2)
assert i + 1 == 2
assert i in M
</code></pre>
<p>Marker classes can also be excluded with the <code>Excluding</code> argument.</p>
<pre><code class="language-python">NInt = Inherit MarkedInt, Impl := N, Excluding: M
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mutable-structure-type"><a class="header" href="#mutable-structure-type">Mutable Structure Type</a></h1>
<p>The <code>T!</code> type is described as a box type that can be replaced by any <code>T</code> type object.</p>
<pre><code class="language-python">Particle!State: {&quot;base&quot;, &quot;excited&quot;}! = Class(... Impl := Phantom State)
Particle!
    # This method moves the State from &quot;base&quot; to &quot;excited&quot;.
    apply_electric_field!(ref! self(&quot;base&quot; ~&gt; &quot;excited&quot;), field: Vector) = ...
</code></pre>
<p>The <code>T!</code> type can replace data, but it cannot change its structure.
More like the behavior of a real program, it cannot change its size (on the heap). Such a type is called an immutable structure (mutable) type.</p>
<p>In fact, there are data structures that cannot be represented by invariant structure types.
For example, a Mutable-length array. The <code>[T; N]!</code>type can contain objects of any <code>[T; N]</code>, but cannot be replaced by objects of type <code>[T; N+1]</code> and so on.</p>
<p>In other words, the length cannot be changed. To change the length, the structure of the type itself must be changed.</p>
<p>This is achieved by Mutable structure (mutable) types.</p>
<pre><code class="language-python">v = [Str; !0].new()
v.push! &quot;Hello&quot;
v: [Str; !1].
</code></pre>
<p>For mutable structure types, Mutable type arguments are marked with <code>!</code>. In the above case, the type <code>[Str; !0]</code> can be changed to <code>[Str; !1]</code> and so on. That is, the length can be changed.
Incidentally, the <code>[T; !N]</code> type is the sugar-coated syntax of the <code>ArrayWithLength!(T, !N)</code> type.</p>
<p>Mutable structure types can of course be user-defined. Note, however, that there are some differences from invariant structure types in terms of the construction method.</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, !0 = Inherit Nil T
List T, N: Nat! = Class {head = T; rest = List(T, !N-1)}
List(T, !N).
    push! ref! self(N ~&gt; N+1, ...), head: T =
        self.update! old -&gt; Self.new {head; old}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="phantom-class"><a class="header" href="#phantom-class">Phantom class</a></h1>
<p>Phantom types are marker traits that exist only to provide annotations to the compiler.
As a usage of phantom types, let's look at the structure of a list.</p>
<pre><code class="language-python">Nil = Class()
List T, 0 = Inherit Nil
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>This code results in an error.</p>
<pre><code class="language-python">3 | List T, 0 = Inherit Nil
                        ^^^
TypeConstructionError: since Nil does not have a parameter T, it is not possible to construct List(T, 0) with Nil
hint: use 'Phantom' trait to consume T
</code></pre>
<p>This error is a complaint that <code>T</code> cannot be type inferred when <code>List(_, 0).new Nil.new()</code> is used.
In such a case, whatever the <code>T</code> type is, it must be consumed on the right-hand side. A type of size zero, such as a tuple of length zero, is convenient because it has no runtime overhead.</p>
<pre><code class="language-python">Nil T = Class((T; 0))
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>This code passes compilation. But it's a little tricky to understand the intent, and it can't be used except when the type argument is a type.</p>
<p>In such a case, a phantom type is just what you need. A phantom type is a generalized type of size 0.</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}

nil = Nil(Int).new()
assert nil.__size__ == 0
</code></pre>
<p><code>Phantom</code> holds the type <code>T</code>. But in fact the size of the <code>Phantom T</code> type is 0 and does not hold an object of type <code>T</code>.</p>
<p>Also, <code>Phantom</code> can consume arbitrary type arguments in addition to its type. In the following example, <code>Phantom</code> holds a type argument called <code>State</code>, which is a subtype object of <code>Str</code>.
Again, <code>State</code> is a fake type variable that does not appear in the object's entity.</p>
<pre><code class="language-python">VM! State: {&quot;stopped&quot;, &quot;running&quot;}! = Class(... State)
VM!(&quot;stopped&quot;).
    start ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.do_something!()
        self::set_phantom!(&quot;running&quot;))
</code></pre>
<p>The <code>state</code> is updated via the <code>update_phantom!</code> or <code>set_phantom!</code> methods.
This is the method provided by the standard patch for <code>Phantom!</code> (the variable version of <code>Phantom</code>), and its usage is the same as the variable <code>update!</code> and <code>set!</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="projection-type"><a class="header" href="#projection-type">Projection Type</a></h1>
<p>A projection type represents a type such as <code>Self.AddO</code> in the following code.</p>
<pre><code class="language-python">Add R = Trait {
    . `_+_` = Self, R -&gt; Self.AddO
    .AddO = Type
}

AddForInt = Patch(Int, Impl := Add Int)
AddForInt.
    AddO = Int
</code></pre>
<p>The type <code>Add(R)</code> can be said to be a type that defines addition with some object. Since the method should be a type attribute, the <code>+</code> type declaration should be written below the indentation.
The mise-en-scène of the <code>Add</code> type is the declaration <code>.AddO = Type</code>, and the entity of the <code>.AddO</code> type, which is a projective type, is held by a type that is a subtype of <code>Add</code>. For example, <code>Int.AddO = Int</code>, <code>Odd.AddO = Even</code>.</p>
<pre><code class="language-python">assert Int &lt; Add
assert Int.AddO == Int
assert Odd &lt; Add
assert Odd.AddO == Even
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quantified-dependent-type"><a class="header" href="#quantified-dependent-type">Quantified Dependent Type</a></h1>
<p>Erg has quantified and dependent types. Then naturally, it is possible to create a type that combines the two. That is the quantified dependent type.</p>
<pre><code class="language-python">NonNullStr = |N: Nat| StrWithLen N | N ! = 0 # same as {S | N: Nat; S: StrWithLen N; N ! = 0}
NonEmptyArray = |N: Nat| [_; N | N &gt; 0] # same as {A | N: Nat; A: Array(_, N); N &gt; 0}
</code></pre>
<p>The standard form of quantified dependent types are <code>K(A, ... | Pred)</code>. <code>K</code> is a type constructor, <code>A, B</code> are type arguments, and <code>Pred</code> is a conditional expression.</p>
<p>Quantified dependent types as left-hand side values can only define methods in the same module as the original type.</p>
<pre><code class="language-python">K A: Nat = Class ...
K(A).
    ...
K(A | A &gt;= 1).
    method ref! self(A ~&gt; A+1) = ...
</code></pre>
<p>Quantified dependent types as right-hand side values require that the type variable to be used be declared in the type variable list (<code>||</code>).</p>
<pre><code class="language-python"># T is a concrete type
a: |N: Nat| [T; N | N &gt; 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared-reference"><a class="header" href="#shared-reference">Shared Reference</a></h1>
<p>Shared references are one of those language features that must be handled with care.
In TypeScript, for example, the following code will pass type checking.</p>
<pre><code class="language-typescript">class NormalMember {}
class VIPMember extends NormalMember {}

let vip_area: VIPMember[] = []
let normal_area: NormalMember[] = vip_area

normal_area.push(new NormalMember())
console.log(vip_area) # [NormalMember]
</code></pre>
<p>A NormalMember has entered the vip_area. It is an obvious bug, however what went wrong?
The cause is the shared reference <a href="type/advanced/./variance.html">denatured</a>. The <code>normal_area</code> is created by copying the <code>vip_area</code>, but in doing so the type has changed.
But <code>VIPMember</code> inherits from <code>NormalMember</code>, so <code>VIPMember[] &lt;: NormalMember[]</code>, and this is not a problem.
The relation <code>VIPMember[] &lt;: NormalMember[]</code> is fine for immutable objects. However, if you perform a destructive operation like the one above, there will be a breakdown.</p>
<p>In Erg, such code is played back due to the ownership system.</p>
<pre><code class="language-python">NormalMember = Class()
VIPMember = Class()

vip_area = [].into [VIPMember; !_]
normal_area: [NormalMember; !_] = vip_area

normal_area.push!(NormalMember.new())
log vip_area # OwnershipError: `vip_room` was moved to `normal_room`
</code></pre>
<p>However, it can be inconvenient for an object to be owned by only one place.
For this reason, Erg has a type <code>SharedCell!T!</code>, which represents a shared state.</p>
<pre><code class="language-python">$p1 = SharedCell!.new(!1)
$p2 = $p1.mirror!()
$p3 = SharedCell!.new(!1)
# If $p1 == $p2, a comparison of the content type Int!
assert $p1 == $p2
assert $p1 == $p3
# Check if $p1 and $p2 point to the same thing with `.addr!`.
assert $p1.addr!() == $p2.addr!()
assert $p1.addr!() != $p3.addr!()
$p1.add! 1
assert $p1 == 2
assert $p2 == 2
assert $p3 == 1
</code></pre>
<p>Objects of type <code>SharedCell!</code> must be prefixed with <code>$</code>. Also, by their nature, they cannot be constants.</p>
<p>The <code>SharedCell! T!</code> type is also a subtype of <code>T!</code> and can call methods of type <code>T!</code>. The only methods specific to the <code>SharedCell!T!</code> type are <code>.addr!</code>, <code>.mirror!</code> and <code>.try_take</code>.</p>
<p>An important fact is that <code>SharedCell! T!</code> is non-variant, i.e., no inclusions are defined for different type arguments.</p>
<pre><code class="language-python">$vip_area = SharedCell!.new([].into [VIPMember; !_])
$normal_area: SharedCell!([NormalMember; !_]) = $vip_area.mirror!() # TypeError: expected SharedCell!([NormalMember; !_]), but got SharedCell!([VIPMember; !_])
# hint: SharedCell!(T) is non-variant, which means it cannot have a supertype or a subtype.
</code></pre>
<p>However, the following code have not problem. In the last line, it's the <code>VIPMember</code> argument that has been typed converted.</p>
<pre><code class="language-python">$normal_area = SharedCell!.new([].into [NormalMember; !_])
$normal_area.push!(NormalMember.new()) # OK
$normal_area.push!(VIPMember.new()) # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>An iterator is an object used to retrieve elements of a container.</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>This code prints the numbers 0 through 9.
Each number (=Int object) is assigned to <code>i</code> and the following operation (=`print! i``) is executed. This kind of repetitive execution is called <strong>iteration</strong>.</p>
<p>Now let's look at the type signature of the <code>for!</code> procedure.</p>
<pre><code class="language-python">for!: |T: Type, I &lt;: Iterable T| (I, T =&gt; None) =&gt; None
</code></pre>
<p>The first argument seems to accept an object of type <code>Iterable</code>.</p>
<p><code>Iterable</code> is a type with <code>.Iterator</code> attribute, <code>.iter</code> method in the request method.</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<p>The type <code>{Iterator}</code> of the <code>.Iterator</code> attribute is so-called set-kind (kind is described <a href="./type/advanced/kind.html">here</a>).</p>
<pre><code class="language-python">assert [1, 2, 3] in Iterable(Int)
assert 1..3 in Iterable(Int)
assert [1, 2, 3].Iterator == ArrayIterator
assert (1..3).Iterator == RangeIterator

log [1, 2, 3].iter() # &lt;ArrayIterator object
log (1..3).iter() # &lt;RangeIterator object&gt;
</code></pre>
<p>Both <code>ArrayIterator</code> and <code>RangeIterator</code> are classes that implement <code>Iterator</code> and exist only to give <code>Array</code> and <code>Range</code> iteration functions.
Such a design pattern is called companion class <a href="16_iterator.html#1"><sup id="f1">1</sup></a>.
And the <code>IteratorImpl</code> patch is the core of the iteration functionality. <code>Iterator</code> requires only one <code>.next</code> method, <code>IteratorImpl</code> provides dozens of methods indeed. <code>ArrayIterator</code> and <code>RangeIterator</code> can use the implementation method of <code>IteratorImpl</code> just by implementing the <code>.next</code> method. For this convenience, the standard library implements a number of iterators.</p>
<pre><code class="language-mermaid">classDiagram
    class Array~T~ {
        ...
        iter() ArrayIterator~T~
    }
    class Range~T~ {
        ...
        iter() RangeIterator~T~
    }
    class Iterable~T~ {
        &lt;&lt;trait&gt;&gt;
        iter() Iterator~T~
    }
    Iterable~T~ &lt;|.. Array~T~: Impl
    Iterable~T~ &lt;|.. Range~T~: Impl
    class ArrayIterator~T~ {
        array: Array~T~
        next() T
    }
    class RangeIterator~T~ {
        range: Range~T~
        next() T
    }
    class Iterator~T~ {
        &lt;&lt;trait&gt;&gt;
        next() T
    }
    Iterator~T~ &lt;|.. ArrayIterator~T~: Impl
    Iterator~T~ &lt;|.. RangeIterator~T~: Impl

    Array &lt;-- ArrayIterator
    Range &lt;-- RangeIterator
</code></pre>
<p>Types such as <code>Iterable</code> that provide an interface for handling traits (in this case <code>Iterator</code>) in a static dispatch yet unified manner are called companion class adapters.</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> There doesn't seem to be a uniform name for this pattern, but in Rust, there is [companion struct pattern]( https://gist.github.com/qnighy/be99c2ece6f3f4b1248608a04e104b38#:~:text=%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82-,companion%20struct,-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%80%81%E3 %81%9D%E3%81%AE), and was named after it. <a href="16_iterator.html#f1">↩</a> </span></p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>As we have already seen, all Erg variables are immutable. However, Erg objects have the concept of mutability.
Take the following code as an example.</p>
<pre><code class="language-python">a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>The above code cannot actually be executed by Erg. This is because it is not reassignable.</p>
<p>This code can be executed.</p>
<pre><code class="language-python">b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>The final result of <code>a, b</code> looks the same, but their meanings are very different.
Although <code>a</code> is a variable that represents an array of <code>Nat</code>, the objects pointed to in the first and second lines are different. The name <code>a</code> is the same, but the contents are different.</p>
<pre><code class="language-python">a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
</code></pre>
<p>The <code>id!</code> procedure returns the address in memory where the object resides.</p>
<p><code>b</code> is a <code>Nat</code> &quot;dynamic&quot; array. The content of the object changes, but the variables point to the same thing.</p>
<pre><code class="language-python">b = ![1, 2, 3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
</code></pre>
<pre><code class="language-python">i = !0
if! True. do!
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
</code></pre>
<p><code>!</code> is a special operator called the <strong>mutation operator</strong>. It makes immutable objects mutable.
The behavior of objects marked with <code>!</code> can be customized.</p>
<pre><code class="language-python">Point = Class {.x = Int; .y = Int}

# In this case .x is made mutable and .y remains immutable
Point! = Class {.x = Int!; .y = Int}
Point!.
    inc_x! ref!(self) = self.x.update! x -&gt; x + 1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
</code></pre>
<h2 id="constant"><a class="header" href="#constant">Constant</a></h2>
<p>Unlike variables, constants point to the same thing in all scopes.
Constants are declared with the <code>=</code> operator.</p>
<pre><code class="language-python">PI = 3.141592653589
match! x:
    PI =&gt; print! &quot;this is pi&quot;
</code></pre>
<p>Constants are identical in all scopes below the global and cannot be overwritten. Therefore, they cannot be redefined by <code>=</code>. This restriction allows it to be used in pattern matching.
The reason why <code>True</code> and <code>False</code> can be used in pattern matching is because they are constants.
Also, constants always point to immutable objects. Types such as <code>Str!</code> cannot be constants.
All built-in types are constants because they should be determined at compile time. Types that are not constants can be generated, but they cannot be used to specify a type and can only be used like a simple record. Conversely, a type is a record whose contents are determined at compile time.</p>
<h2 id="variable-name-identifier-symbol"><a class="header" href="#variable-name-identifier-symbol">Variable, Name, Identifier, Symbol</a></h2>
<p>Let's clear up a few terms related to variables in Erg.</p>
<p>A Variable is a mechanism to give an object a Name so that it can be reused (or point to that Name).
Identifier is a grammar element that specifies a variable.
A symbol is a grammatical element, a token, that represents a name.</p>
<p>Only non-symbolic characters are symbols, and symbols are not called symbols, although they can be identifiers as operators.
For example, <code>x</code> is an identifier and a symbol. <code>x.y</code> is also an identifier, but it is not a symbol. <code>x</code> and <code>y</code> are symbols.
And even if <code>x</code> were not tied to any object, <code>x</code> would still be a Symbol and an Identifier, but it would not be called a Variable.
Identifiers of the form <code>x.y</code> are called Field Accessors.
Identifiers of the form <code>x[y]</code> are called Subscript Accessors.</p>
<p>The difference between a variable and an identifier is that if we are talking about a variable in the sense of Erg's grammatical theory, the two are in effect the same.
In C, types and functions cannot be assigned to variables; int and main are identifiers, but not variables (strictly speaking, they can be assigned, but there are restrictions).
However, in Erg, &quot;everything is an object&quot;. Not only functions and types, but even operators can be assigned to variables.</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-system"><a class="header" href="#ownership-system">Ownership system</a></h1>
<p>Since Erg is a language that uses Python as the host language, the method of memory management depends on the Python implementation.
But semantically Erg's memory management is different from Python's. A notable difference is in the ownership system and the prohibition of circular references.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<p>Erg has an ownership system inspired by Rust.
Rust's ownership system is generally considered esoteric, but Erg's is simplified to be intuitive.
In Erg, <strong>mutable objects</strong> are owned and cannot be referenced after ownership is lost.</p>
<pre><code class="language-python">v = [1, 2, 3].into [Int; !3]

push! vec, x =
    vec.push!(x)
    vec

# The contents of v ([1, 2, 3]) are owned by w
w = push! v, 4
print! v # error: v was moved
print!w # [1, 2, 3, 4]
</code></pre>
<p>Ownership transfer occurs, for example, when an object is passed to a subroutine.
If you want to still have ownership after giving it away, you'll need to clone, freeze, or borrow.
However, as will be explained later, there are limited situations in which it can be borrowed.</p>
<h2 id="replication"><a class="header" href="#replication">replication</a></h2>
<p>Duplicate an object and transfer its ownership. It does this by applying the <code>.clone</code> method to the actual arguments.
The duplicated object is exactly the same as the original, but independent of each other and unaffected by changes.</p>
<p>Duplication is equivalent to Python's deep copy, and since it recreates the same object entirely, the computation and memory costs are generally higher than freezing and borrowing.
A subroutine that needs to duplicate an object is said to be an &quot;argument consuming&quot; subroutine.</p>
<pre><code class="language-python">capitalize s: Str!=
    s. capitalize!()
    s

s1 = !&quot;hello&quot;
s2 = capitalize s1.clone()
log s2, s1 # !&quot;HELLO hello&quot;
</code></pre>
<h2 id="freeze"><a class="header" href="#freeze">freeze</a></h2>
<p>We take advantage of the fact that immutable objects can be referenced from multiple places and convert mutable objects to immutable objects.
This is called freezing. Freezing is used, for example, when creating an iterator from a mutable array.
Since you can't create an iterator directly from a mutable array, convert it to an immutable array.
If you don't want to destroy the array, use the <a href="./type/18_mut.html"><code>.freeze_map</code> method</a>.</p>
<pre><code class="language-python"># Compute the sum of the values ​​produced by the iterator
sum|T &lt;: Add + HasUnit| i: Iterator T = ...

x = [1, 2, 3].into [Int; !3]
x.push!(4)
i = x.iter() # TypeError: [Int; !4] has no method `iter`
y = x.freeze()
i = y.iter()
assert sum(i) == 10
y # y can still be touched
</code></pre>
<h2 id="borrow"><a class="header" href="#borrow">borrow</a></h2>
<p>Borrowing is cheaper than duplicating or freezing.
Borrowing can be done in the following simple cases:</p>
<pre><code class="language-python">peek_str ref(s: Str!) =
    log s

s = !&quot;hello&quot;
peek_str s
</code></pre>
<p>A borrowed value is called a <strong>reference</strong> to the original object.
You can &quot;sublease&quot; the reference to another subroutine, but you cannot consume it because you are only borrowing it.</p>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # Since the log function only borrows the arguments, it can be sub-leased
    log s
    # error because the discard function consumes arguments
    discard s # OwnershipError: cannot consume a borrowed value
    # hint: use `clone` method
</code></pre>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # This is no good either (= consumes the right side)
    x = s # OwnershipError: cannot consume a borrowed value
    x
</code></pre>
<p>Erg's references are more restrictive than Rust's. References are first-class objects in the language, but cannot be created explicitly, they can only be specified as argument passing via <code>ref</code>/<code>ref!</code>.
This means that you cannot stuff references into arrays or create classes with references as attributes.</p>
<p>However, such restrictions are a natural specification in languages ​​without references in the first place, and they are not so inconvenient.</p>
<h2 id="circular-references"><a class="header" href="#circular-references">circular references</a></h2>
<p>Erg is designed to prevent unintentional memory leaks, and will issue an error if the memory checker detects a circular reference. In most cases, this error can be resolved with a weak reference <code>Weak</code>. However, since it is not possible to generate objects with circular structures such as cyclic graphs, we plan to implement an API that can generate circular references as unsafe operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>Erg variables have the concept of <strong>visibility</strong>.
All the variables we've seen so far are called <strong>private variables</strong>. This is an externally invisible variable.
For example, a private variable defined in the <code>foo</code> module cannot be referenced by another module.</p>
<pre><code class="language-python"># foo.er
x = &quot;this is an invisible variable&quot;
</code></pre>
<pre><code class="language-python">#bar.er
foo = import &quot;foo&quot;
foo.x # AttributeError: Module 'foo' has no attribute 'x' ('x' is private)
</code></pre>
<p>On the other hand, there are also <strong>public variables</strong>, which can be referenced from the outside.
Public variables are defined with <code>.</code>.</p>
<pre><code class="language-python"># foo.er
.x = &quot;this is a visible variable&quot;
</code></pre>
<pre><code class="language-python">#bar.er
foo = import &quot;foo&quot;
assert foo.x == &quot;this is a visible variable&quot;
</code></pre>
<p>You don't need to add anything to private variables, but you can also add <code>::</code> or <code>self::</code> (<code>Self::</code> for types etc.) to indicate that they are private. increase. It can also be <code>module::</code> if it is a module.</p>
<pre><code class="language-python">::x = &quot;this is an invisible variable&quot;
assert ::x == x
assert self ::x == ::x
assert module::x == ::x
</code></pre>
<p>In the context of purely sequential execution, private variables are almost synonymous with local variables. It can be referenced from the inner scope.</p>
<pre><code class="language-python">::x = &quot;this is a private variable&quot;
y =
    x + 1 # exactly module::x
</code></pre>
<p>By using <code>::</code>, you can distinguish variables with the same name within the scope.
Specify the scope of the variable you want to refer to on the left. Specify <code>module</code> for the top level.
If not specified, the innermost variable is referenced as usual.</p>
<pre><code class="language-python">::x = 0
assert x == 0
y =
    ::x = 1
    assert x == 1
    z =
        ::x = 2
        assert ::x == 2
        assert z::x == 2
        assert y::x == 1
        assert module::x == 0
</code></pre>
<p>In the anonymous subroutine scope, <code>self</code> specifies its own scope.</p>
<pre><code class="language-python">x = 0
f = x -&gt;
    log module::x, self::x
f1# 0 1
</code></pre>
<p><code>::</code> is also responsible for accessing private instance attributes.</p>
<pre><code class="language-python">x = 0
C = Class {x = Int}
C.
    # Top-level x is referenced (warning to use module::x)
    f1 self = x
    # instance attribute x is referenced
    f2 self = self::x
</code></pre>
<h2 id="visibility-in-external-modules"><a class="header" href="#visibility-in-external-modules">Visibility in external modules</a></h2>
<p>A class defined in one module can actually define methods from an external module.</p>
<pre><code class="language-python"># foo.er
.Foo = Class()
</code></pre>
<pre><code class="language-python">#bar.er
{Foo; ...} = import &quot;foo&quot;

Foo::
    private self = pass
Foo.
    public self = self::private()

.f() =
    foo = Foo.new()
    foo.public()
    foo::private() # AttributeError
</code></pre>
<p>However, both of those methods are only available within that module.
Private methods defined externally are visible to methods of the <code>Foo</code> class only within the defining module.
Public methods are exposed outside the class, but not outside the module.</p>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;

foo = Foo.new()
foo.public() # AttributeError: 'Foo' has no attribute 'public' ('public' is defined in module 'bar')
</code></pre>
<p>Also, methods cannot be defined in the type to be re-exported.
This is to avoid confusion about methods being found or not found depending on the module they are imported from.</p>
<pre><code class="language-python">#bar.er
{.Foo; ...} = import &quot;foo&quot;

.Foo::
    private self = pass # Error
Foo.
    public self = self::private() # Error
</code></pre>
<p>If you want to do something like this, define a <a href="./type/07_patch.html">patch</a>.</p>
<pre><code class="language-python">#bar.er
{Foo; ...} = import &quot;foo&quot;

FooImpl = Patch Foo
FooImpl :=:
    private self = pass
Foo Impl.
    public self = self::private()
</code></pre>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;
{FooImpl; ...} = import &quot;bar&quot;

foo = Foo.new()
foo.public()
</code></pre>
<h2 id="restricted-public-variables"><a class="header" href="#restricted-public-variables">restricted public variables</a></h2>
<p>Variable visibility is not limited to complete public/private.
You can also publish with restrictions.</p>
<pre><code class="language-python"># foo.er
.record = {
    .a = {
        .(.record)x = 0
        .(module)y = 0
        .z = 0
    }
    _ = .a.x # OK
    _ = .a.y # OK
    _ = .a.z # OK
}

_ = .record.a.x # VisibilityError
_ = .record.a.y # OK
_ = .record.a.z # OK
</code></pre>
<pre><code class="language-python">foo = import &quot;foo&quot;
_ = foo.record.a.x # VisibilityError
_ = foo.record.a.y # VisibilityError
_ = foo.record.a.z # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="naming-convention"><a class="header" href="#naming-convention">Naming convention</a></h1>
<p>If you want to use a variable as a constant expression, make sure it starts with a capital letter. Two or more letters may be lowercase.</p>
<pre><code class="language-python">i: Option Type = Int
match i:
    t: Type -&gt; log &quot;type&quot;
    None -&gt; log &quot;None&quot;
</code></pre>
<p>Objects with side effects always end with <code>!</code>. Procedures and procedural methods, and mutable types.
However, the <code>Proc</code> type itself is not mutable.</p>
<pre><code class="language-python"># Callable == Func or Proc
c: Callable = print!
match c:
    p! -&gt; log &quot;proc&quot; # `: Proc` can be omitted since it is self-explanatory
    f -&gt; log &quot;func&quot;
</code></pre>
<p>If you want to expose an attribute to the outside world, define it with <code>.</code> at the beginning. If you don't put <code>.</code> at the beginning, it will be private. To avoid confusion, they cannot coexist within the same scope.</p>
<pre><code class="language-python">o = {x = 1; .x = 2} # SyntaxError: private and public variables with the same name cannot coexist
</code></pre>
<h2 id="literal-identifiers"><a class="header" href="#literal-identifiers">Literal Identifiers</a></h2>
<p>The above rule can be circumvented by enclosing the string in single quotes (''). That is, procedural objects can also be assigned without <code>!</code>. However, in this case, even if the value is a constant expression, it is not considered a constant.
A character string enclosed in single quotes like this is called a literal identifier.
This is used when calling APIs (FFI) of other languages ​​such as Python.</p>
<pre><code class="language-python">bar! = pyimport(&quot;foo&quot;).'bar'
</code></pre>
<p>Identifiers that are also valid in Erg do not need to be enclosed in ''.</p>
<p>Furthermore, literal identifiers can contain both symbols and spaces, so strings that cannot normally be used as identifiers can be used as identifiers.</p>
<pre><code class="language-python">'∂/∂t' y
'test 1: pass x to y'()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anonymous-function"><a class="header" href="#anonymous-function">anonymous function</a></h1>
<p>Anonymous functions are a syntax for creating function objects on the fly without naming them.</p>
<pre><code class="language-python"># `-&gt;` is an anonymous function operator
# same as `f x, y = x + y`
f = (x, y) -&gt; x + y
# same as `g(x, y: Int): Int = x + y`
g = (x, y: Int): Int -&gt; x + y
</code></pre>
<p>You can omit the <code>()</code> if there is only one argument.</p>
<pre><code class="language-python">assert [1, 2, 3].map_collect(i -&gt; i + 1) == [2, 3, 4]
assert ((i, j) -&gt; [i, j])(1, 2) == [1, 2]
</code></pre>
<p>In the case below it is <code>0..9, (i -&gt; ...)</code> and not <code>(0..9, i) -&gt; ...</code>.
<code>-&gt;</code> takes only one argument on the left side. Multiple arguments are received as a single tuple.</p>
<pre><code class="language-python">for 0..9, i: Int -&gt;
    ...
</code></pre>
<p>In anonymous functions, there is a difference in parsing due to whitespace.</p>
<pre><code class="language-python"># In this case, interpreted as `T(() -&gt; Int)`
i: T() -&gt; Int
# in this case it is interpreted as (U()) -&gt; Int
k: U() -&gt; Int
</code></pre>
<p>Anonymous functions can be used without arguments.</p>
<pre><code class="language-python"># `=&gt;` is an anonymous procedure operator
p! = () =&gt; print! &quot;`p!` was called&quot;
# `() -&gt;`, `() =&gt;` have syntax sugar `do`, `do!`
# p! = do! print! &quot;`p!` was called&quot;
p!() # `p!` was called
</code></pre>
<p>No-argument functions can be used for lazy initialization.</p>
<pre><code class="language-python">time = import &quot;time&quot;
date = import &quot;datetime&quot;
now = if! True:
    do!:
        time. sleep! 1000
        date.now!()
    do date.new(&quot;1970&quot;, &quot;1&quot;, &quot;1&quot;, &quot;00&quot;, &quot;00&quot;)
</code></pre>
<p>You can also type and pattern match. Because of this, the <code>match</code> function is mostly implemented with the power of anonymous functions.
Anonymous functions given as arguments to the <code>match</code> function are tried in order from the top. So, you should describe the special cases at the top and the more general cases at the bottom. If you get the order wrong, the compiler will issue a warning (if possible).</p>
<pre><code class="language-python">n = (Complex or Ratio or Int).sample!()
i = matchn:
    PI -&gt; PI # if equal to constant PI
    For (i: 1..10) -&gt; i # Int from 1 to 10
    (i: Int) -&gt; i # Int
    (c: Complex) -&gt; c.real() # For Complex. Int &lt; Complex, but can fallback
    _ -&gt; panic &quot;cannot convert to Int&quot; # If none of the above apply. match must cover all patterns
</code></pre>
<p>Error handling is also generally done using <code>?</code> or <code>match</code>.</p>
<pre><code class="language-python">res: ParseResult Int
matchres:
    i: Int -&gt; i
    err: Error -&gt; panic err.msg

res2: Result Int, Error
match res2:
    ok: Not Error -&gt; log Type of ok
    err: Error -&gt; panic err.msg
</code></pre>
<h2 id="anonymous-polymorphic-functions"><a class="header" href="#anonymous-polymorphic-functions">Anonymous polymorphic functions</a></h2>
<pre><code class="language-python"># same as id|T| x: T = x
id = |T| x: T -&gt; x
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subroutine-signatures"><a class="header" href="#subroutine-signatures">Subroutine Signatures</a></h1>
<h2 id="func"><a class="header" href="#func">Func</a></h2>
<pre><code class="language-python">some_func(x: T, y: U) -&gt; V
some_func: (T, U) -&gt; V
</code></pre>
<h2 id="proc"><a class="header" href="#proc">Proc</a></h2>
<pre><code class="language-python">some_proc!(x: T, y: U) =&gt; V
some_proc!: (T, U) =&gt; V
</code></pre>
<h2 id="func-method"><a class="header" href="#func-method">Func Method</a></h2>
<p>The method type cannot be specified externally with <code>Self</code>.</p>
<pre><code class="language-python">.some_method(self, x: T, y: U) =&gt; ()
# Self.(T, U) =&gt; () takes ownership of self
.some_method: (Ref(Self), T, U) =&gt; ()
</code></pre>
<h2 id="proc-method-dependent"><a class="header" href="#proc-method-dependent">Proc Method (dependent)</a></h2>
<p>In the following, assume that the type <code>T!</code> takes the type argument <code>N: Nat</code>. To specify it externally, use a type variable.</p>
<pre><code class="language-python">T!: Nat -&gt; Type
# ~&gt; indicates the state of the type argument before and after application (in this case, self must be a variable reference)
T!(N).some_method!: (Ref!(T! N ~&gt; N+X), X: Nat) =&gt; ()
</code></pre>
<p>As a note, the type of <code>.some_method</code> is <code>|N, X: Nat| (Ref!(T N ~&gt; N+X), {X}) =&gt; ()</code>.
For methods that do not have <code>ref!</code>, i.e., are deprived of ownership after application, the type argument transition (<code>~&gt;</code>) cannot be used.</p>
<p>If ownership is taken, it is as follows.</p>
<pre><code class="language-python"># If you don't use N, you can omit it with _.
# .some_method!: |N, X: Nat| (T!(N), {X}) =&gt; T!(N+X)
.some_method!|N, X: Nat|(self: T!(N), X: Nat) =&gt; T!(N+X)
</code></pre>
<h2 id="operator-1"><a class="header" href="#operator-1">Operator</a></h2>
<p>It can be defined as a normal function by enclosing it with ``.</p>
<p>Neuter alphabetic operators such as <code>and</code> and <code>or</code> can be defined as neuter operators by enclosing them with ``.</p>
<pre><code class="language-python">and(x, y, z) = x and y and z
`_+_`(x: Foo, y: Foo) = x.a + y.a
`-_`(x: Foo) = Foo.new(-x.a)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>Erg subroutines have a feature called a &quot;closure&quot; that captures external variables.</p>
<pre><code class="language-python">outer = 1
f x = outer + x
assert f(1) == 2
</code></pre>
<p>As with immutable objects, mutable objects can also be captured.</p>
<pre><code class="language-python">sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45

p!x=
    sum.add!x
p!(1)
assert sum == 46
</code></pre>
<p>Note, however, that functions cannot capture mutable objects.
If a mutable object can be referenced in a function, you can write code like the following.</p>
<pre><code class="language-python"># !!! This code actually gives an error !!!
i = !0
f x = i + x
assert f 1 == 1
i.add! 1
assert f 1 == 2
</code></pre>
<p>The function should return the same value for the same arguments, but the assumption is broken.
Note that <code>i</code> is evaluated only at call time.</p>
<p>Call <code>.clone</code> if you want the contents of the mutable object at the time the function was defined.</p>
<pre><code class="language-python">i = !0
immut_i = i.clone().freeze()
fx = immut_i + x
assert f 1 == 1
i.add! 1
assert f 1 == 1
</code></pre>
<h2 id="avoid-mutable-state-functional-programming"><a class="header" href="#avoid-mutable-state-functional-programming">avoid mutable state, functional programming</a></h2>
<pre><code class="language-python"># Erg
sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45
</code></pre>
<p>The equivalent program above can be written in Python as follows:</p>
<pre><code class="language-python"># Python
sum = 0
for i in range(1, 10):
    sum += i
assert sum == 45
</code></pre>
<p>However, Erg recommends a simpler notation.
Instead of carrying around state using subroutines and mutable objects, use a style of localizing state using functions. This is called functional programming.</p>
<pre><code class="language-python"># Functional style
sum = (1..10).sum()
assert sum == 45
</code></pre>
<p>The code above gives exactly the same result as before, but you can see that this one is much simpler.</p>
<p>The <code>fold</code> function can be used to do more than sum.
<code>fold</code> is an iterator method that executes the argument <code>f</code> for each iteration.
The initial value of the counter that accumulates results is specified in <code>init</code> and accumulated in <code>acc</code>.</p>
<pre><code class="language-python"># start with 0, result will
sum = (1..10).fold(init: 0, f: (acc, i) -&gt; acc + i)
assert sum == 45
</code></pre>
<p>Erg is designed to be a natural succinct description of programming with immutable objects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">module</a></h1>
<p>Erg allows you to think of the file itself as a single record. This is called a module.</p>
<pre><code class="language-python:foo.er"># foo.er
.i = 1
</code></pre>
<pre><code class="language-python"># Defining the foo module is almost the same as defining this record
foo = {.i = 1}
</code></pre>
<pre><code class="language-python:bar.er">#bar.er
foo = import &quot;foo&quot;
print! foo # &lt;module 'foo'&gt;
assert foo.i == 1
</code></pre>
<p>Since module types are also record types, deconstruction assignment is possible.</p>
<pre><code class="language-python">{sin; cos; ...} = import &quot;math&quot;
</code></pre>
<h2 id="module-visibility"><a class="header" href="#module-visibility">module visibility</a></h2>
<pre><code class="language-console">└─┬ ./src
   ├─ lib.er
   ├─ foo.er
   ├─bar.er
   └─┬ bar
     ├─ baz.er
     └─ qux.er
</code></pre>
<h2 id="circular-dependencies"><a class="header" href="#circular-dependencies">circular dependencies</a></h2>
<p>Erg allows you to define circular dependencies between modules.</p>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;

print! bar.g 1
.f x = x
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;

print! foo.f 1
.g x = x
</code></pre>
<p>However, variables created by procedure calls cannot be defined in circular reference modules.
This is because Erg rearranges the order of definitions according to dependencies.</p>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;

print! bar.x
.x = g!(1) # ModuleError: variables created by procedure calls cannot be defined in circular reference modules
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;

print! foo.x
.x = 0
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="object"><a class="header" href="#object">Object</a></h1>
<p>All data that can be assigned to a variable. The attributes of the <code>Object</code> class are as follows.</p>
<ul>
<li><code>.__repr__</code>: Returns a (non-rich) string representation of the object</li>
<li><code>.__sizeof__</code>: Returns the size of the object (including heap allocation)</li>
<li><code>.__dir__</code>: Returns a list of object attributes</li>
<li><code>.__hash__</code>: returns the hash value of the object</li>
<li><code>.__getattribute__</code>: Get and return an attribute of an object</li>
<li><code>.clone</code>: Creates and returns a clone of an object (with an independent entity in memory)</li>
<li><code>.copy</code>: Returns a copy of the object (pointing to the same thing in memory)</li>
</ul>
<h2 id="record-1"><a class="header" href="#record-1">Record</a></h2>
<p>An object generated by a record literal (<code>{attr = value; ...}</code>).
This object has basic methods such as <code>.clone</code> and <code>.__sizeof__</code>.</p>
<pre><code class="language-python">obj = {.x = 1}
assert obj.x == 1

obj2 = {...x; .y = 2}
assert obj2.x == 1 and obj2.y == 2
</code></pre>
<h2 id="attribute"><a class="header" href="#attribute">Attribute</a></h2>
<p>An object associated with an object. In particular, a subroutine attribute that takes self (<code>self</code>) as its implicit first argument is called a method.</p>
<pre><code class="language-python"># note that there is no `.` in private_attr
record = {.public_attr = j; private_attr = 2; .method = self -&gt; self.i + 1}
record. public_attr == 2
record.private_attr # AttributeError: private_attr is private
assert record.method() == 3
</code></pre>
<h2 id="element"><a class="header" href="#element">Element</a></h2>
<p>An object belonging to a particular type (e.g. <code>1</code> is an element of type <code>Int</code>). All objects are at least elements of type <code>{=}</code>.
Elements of classes are sometimes called instances.</p>
<h2 id="subroutine"><a class="header" href="#subroutine">Subroutine</a></h2>
<p>Indicates an object that is an instance of a function or procedure (including methods). The class representing a subroutine is <code>Subroutine</code>.
An object that implements <code>.__call__</code> is more commonly called a <code>Callable</code>.</p>
<h2 id="callable"><a class="header" href="#callable">Callable</a></h2>
<p>An object that implements <code>.__call__</code>. It is also the superclass of <code>Subroutine</code>.</p>
<h2 id="type"><a class="header" href="#type">Type</a></h2>
<p>An object that defines requirement attributes and commonizes objects.
There are two main types: Polymorphic Type and Monomorphic Type. Typical monomorphic types are <code>Int</code>, <code>Str</code>, etc., and polymorphic types are <code>Option Int</code>, <code>[Int; 3]</code>, etc.
Furthermore, a type that defines a method that changes the state of an object is called a Mutable type, and it is necessary to add <code>!</code> to the variable attribute (e.g. dynamic array: <code>[T; !_]</code>) .</p>
<h2 id="class-1"><a class="header" href="#class-1">Class</a></h2>
<p>A type that has <code>.__new__</code>, <code>.__init__</code> methods, etc. Implement class-based object orientation.</p>
<h2 id="function-1"><a class="header" href="#function-1">Function</a></h2>
<p>A subroutine that has read permission for external variables (excluding static variables) but does not have read/write permission for external variables. In other words, it has no external side effects.
Erg functions are defined differently than Python's because they do not allow side effects.</p>
<h2 id="procedure"><a class="header" href="#procedure">Procedure</a></h2>
<p>It has read and <code>self</code> permissions for external variables, read/write permissions for static variables, and is allowed to use all subroutines. It can have external side effects.</p>
<h2 id="method"><a class="header" href="#method">Method</a></h2>
<p>A subroutine that implicitly takes <code>self</code> as the first argument. It is a different type than a simple function/procedure.</p>
<h2 id="entity"><a class="header" href="#entity">Entity</a></h2>
<p>Objects that are not subroutines and types.
Monomorphic entities (<code>1</code>, <code>&quot;a&quot;</code>, etc.) are also called value objects, polymorphic entities (<code>[1, 2, 3], {&quot;a&quot;: 1}</code>) are also called container objects .</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching-refutable"><a class="header" href="#pattern-matching-refutable">pattern matching, refutable</a></h1>
<h2 id="patterns-available-in-erg"><a class="header" href="#patterns-available-in-erg">Patterns available in Erg</a></h2>
<h3 id="variable-pattern"><a class="header" href="#variable-pattern">variable pattern</a></h3>
<pre><code class="language-python"># basic assignments
i = 1
# with type
i: Int = 1
# with anonymous type
i: {1, 2, 3} = 2

# functions
fn x = x + 1
# equals
fn x: Add(Int) = x + 1
# (anonymous) function
fn = x -&gt; x + 1
fn: Int -&gt; Int = x -&gt; x + 1

# higher-order type
a: [Int; 4] = [0, 1, 2, 3]
# or
a: Array Int, 4 = [0, 1, 2, 3]
</code></pre>
<h3 id="literal-patterns"><a class="header" href="#literal-patterns">Literal patterns</a></h3>
<pre><code class="language-python"># Raise a TypeError if `i` cannot be determined to be 1 at compile time.
# omit `_: {1} = i`
1 = i

# simple pattern matching
match x:
    1 -&gt; &quot;1&quot;
    2 -&gt; &quot;2&quot;
    _ -&gt; &quot;other&quot;

# fibonacci function
fib0 = 0
fib1 = 1
fibn: Nat = fibn-1 + fibn-2
</code></pre>
<h3 id="constant-pattern"><a class="header" href="#constant-pattern">constant pattern</a></h3>
<pre><code class="language-python">cond=False
match! cond:
    True =&gt; print! &quot;cond is True&quot;
    _ =&gt; print! &quot;cond is False&quot;

PI = 3.141592653589793
E = 2.718281828459045
num = PI
name = match num:
    PI -&gt; &quot;pi&quot;
    E -&gt; &quot;e&quot;
    _ -&gt; &quot;unnamed&quot;
</code></pre>
<h3 id="sieve-pattern"><a class="header" href="#sieve-pattern">Sieve pattern</a></h3>
<pre><code class="language-python"># these two are the same
Array(T, N: {N | N &gt;= 3})
Array(T, N | N &gt;= 3)

f M, N | M &gt;= 0, N &gt;= 1 = ...
f(1, 0) # TypeError: N (2nd parameter) must be 1 or more
</code></pre>
<h3 id="discard-wildcard-pattern"><a class="header" href="#discard-wildcard-pattern">discard (wildcard) pattern</a></h3>
<pre><code class="language-python">_ = 1
_: Int = 1
zero_ = 0
right(_, r) = r
</code></pre>
<h3 id="variable-length-patterns"><a class="header" href="#variable-length-patterns">Variable length patterns</a></h3>
<p>It is used in combination with the tuple/array/record pattern described later.</p>
<pre><code class="language-python">[i,...j] = [1, 2, 3, 4]
assert j == [2, 3, 4]
first|T|(fst: T, ...rest: T) = fst
assert first(1, 2, 3) == 1
</code></pre>
<h3 id="tuple-pattern"><a class="header" href="#tuple-pattern">Tuple pattern</a></h3>
<pre><code class="language-python">(i, j) = (1, 2)
((k, l), _) = ((1, 2), (3, 4))
# If not nested, () can be omitted (1, 2 are treated as (1, 2))
m, n = 1, 2

f(x, y) = ...
</code></pre>
<h3 id="array-pattern"><a class="header" href="#array-pattern">array pattern</a></h3>
<pre><code class="language-python">[i, j] = [1, 2]
[[k, l], _] = [[1, 2], [3, 4]]

length[] = 0
length[_, ...rest] = 1 + lengthrest
</code></pre>
<h4 id="record-pattern"><a class="header" href="#record-pattern">record pattern</a></h4>
<pre><code class="language-python">record = {i = 1; j = 2; k = 3}
{j; ...} = record # i, k will be freed

{sin; cos; tan; ...} = import &quot;math&quot;
{*} = import &quot;math&quot; # import all

person = {name = &quot;John Smith&quot;; age = 20}
age = match person:
    {name = &quot;Alice&quot;; _} -&gt; 7
    {_; age} -&gt; age

f {x: Int; y: Int} = ...
</code></pre>
<h3 id="data-class-pattern"><a class="header" href="#data-class-pattern">Data class pattern</a></h3>
<pre><code class="language-python">Point = Inherit {x = Int; y = Int}
p = Point::{x = 1; y = 2}
Point::{x; y} = p

Nil T = Class Impl := Phantom T
Cons T = Inherit {head = T; rest = List T}
List T = Enum Nil(T), Cons(T)
List T.
    first self =
        match self:
            Cons::{head; ...} -&gt; x
            _ -&gt; ...
    second self =
        match self:
            Cons::{rest=Cons::{head; ...}; ...} -&gt; head
            _ -&gt; ...
</code></pre>
<h3 id="enumeration-pattern"><a class="header" href="#enumeration-pattern">enumeration pattern</a></h3>
<p>*Actually, it's just an enumeration type</p>
<pre><code class="language-python">match x:
    i: {1, 2} -&gt; &quot;one or two: {i}&quot;
    _ -&gt; &quot;other&quot;
</code></pre>
<h3 id="range-pattern"><a class="header" href="#range-pattern">range pattern</a></h3>
<p>*Actually, it is just an interval type.</p>
<pre><code class="language-python"># 0 &lt; i &lt; 1
i: 0&lt;..&lt;1 = 0.5
# 1 &lt; j &lt;= 2
_: {[I, J] | I, J: 1&lt;..2} = [1, 2]
# 1 &lt;= i &lt;= 5
match i
    i: 1..5 -&gt; ...
</code></pre>
<h3 id="things-that-arent-patterns-things-that-cant-be-patterned"><a class="header" href="#things-that-arent-patterns-things-that-cant-be-patterned">Things that aren't patterns, things that can't be patterned</a></h3>
<p>A pattern is something that can be uniquely specified. In this respect pattern matching differs from ordinary conditional branching.</p>
<p>Condition specifications are not unique. For example, to check if the number <code>n</code> is even, the orthodox is <code>n % 2 == 0</code>, but you can also write <code>(n / 2).round() == n / 2</code>.
A non-unique form is not trivial whether it works correctly or is equivalent to another condition.</p>
<h4 id="set-1"><a class="header" href="#set-1">set</a></h4>
<p>There is no set pattern. Because the set has no way to uniquely retrieve the elements.
You can retrieve them by iterator, but the order is not guaranteed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehension"><a class="header" href="#comprehension">Comprehension</a></h1>
<p>Array with <code>[expr | (name &lt;- iterable)+ (predicate)*]</code>,
set with <code>{expr | (name &lt;- iterable)+ (predicate)*}</code>,
You can create a Dict with <code>{key: value | (name &lt;- iterable)+ (predicate)*}</code>.</p>
<p>The first part of the clauses separated by <code>|</code> is called the layout clause (location clause), the second part is called the bind clause (binding clause), and the third part is called the guard clause (conditional clause).
A guard clause can be omitted, but a bind clause cannot be omitted, and a guard clause cannot precede a bind clause.</p>
<p>Comprehension example</p>
<pre><code class="language-python"># the layout clause is i
# bind clause is i &lt;- [0, 1, 2]
assert [i | i &lt;- [0, 1, 2]] == [0, 1, 2]

# layout clause is i / 2
# bind clause is i &lt;- 0..2
assert [i/2 | i &lt;- 0..2] == [0.0, 0.5, 1.0]

# layout clause is (i, j)
# bind clause i &lt;- 0..2, j &lt;- 0..2
# guard clause is (i + j) % 2 == 0
assert [(i, j) | i &lt;- 0..2; j &lt;- 0..2; (i + j) % 2 == 0] == [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)]

assert {i % 2 | i &lt;- 0..9} == {0, 1}
assert {k: v | k &lt;- [&quot;a&quot;, &quot;b&quot;]; v &lt;- [1, 2]} == {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<p>Erg comprehensions are inspired by Haskell, but with some differences.
For Haskell list comprehensions, the order of variables makes a difference in the result, but in Erg it doesn't matter.</p>
<pre><code class="language-haskell">-- Haskell
[(i, j) | i &lt;- [1..3], j &lt;- [3..5]] == [(1,3),(1,4),(1,5),(2 ,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
[(i, j) | j &lt;- [3..5], i &lt;- [1..3]] == [(1,3),(2,3),(3,3),(1 ,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>
<pre><code class="language-python"># Erg
assert [(i, j) | i &lt;- 1..&lt;3; j &lt;- 3..&lt;5] == [(i, j) | j &lt;- 3..&lt;5; i &lt;- 1.. &lt;3]
</code></pre>
<p>This specification is the same as that of Python.</p>
<pre><code class="language-python"># Python
assert [(i, j) for i in range(1, 3) for j in range(3, 5)] == [(i, j) for j in range(3, 5) for i in range(1, 3)]
</code></pre>
<h2 id="sieve-type"><a class="header" href="#sieve-type">Sieve type</a></h2>
<p>Similar to comprehensions are sieve types. A sieve type is a type (enumerated type) created in the form <code>{Name: Type | Predicate}</code>.
In the case of the sieve type, only one Name can be specified and the layout cannot be specified (however, multiple values ​​can be handled if it is a tuple type), and the Predicate can be calculated at compile time, that is, only a constant expression can be specified.</p>
<pre><code class="language-python">Nat = {I: Int | I &gt;= 0}
# If the predicate expression is only and, it can be replaced with ;
# Nat2D = {(I, J): (Int, Int) | I &gt;= 0; J &gt;= 0}
Nat2D = {(I, J): (Int, Int) | I &gt;= 0 and J &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spread-assignment"><a class="header" href="#spread-assignment">Spread assignment</a></h1>
<p>In a decomposing assignment, putting <code>...</code> in front of a variable expands all remaining elements into that variable. This is called expansion assignment.</p>
<pre><code class="language-python">[x,...y] = [1, 2, 3]
assert x == 1
assert y == [2, 3]
x, ...y = (1, 2, 3)
assert x == 1
assert y == (2, 3)
</code></pre>
<h2 id="extract-assignment"><a class="header" href="#extract-assignment">Extract assignment</a></h2>
<p>If nothing is written after <code>...</code>, the remaining elements are ignored and assigned. This type of expansion assignment is specifically called extractive assignment.
Extraction assignment is a convenient syntax for localizing specific attributes within a module or record.</p>
<pre><code class="language-python">{sin; cos; tan; ..} = import &quot;math&quot;
</code></pre>
<p>After that, you can use <code>sin, cos, tan</code> locally.</p>
<p>You can do the same with records.</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x; y; ...} = record
</code></pre>
<p>If you want to expand all, use <code>{*} = record</code>. It is <code>open</code> in OCaml.</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{*} = records
assert x == 1 and y == 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator-modifier"><a class="header" href="#decorator-modifier">decorator (modifier)</a></h1>
<p>Decorators are used to add or demonstrate a particular state or behavior to a type or function.
The syntax of the decorator is as follows.</p>
<pre><code class="language-python">@deco
X=...
</code></pre>
<p>You can have multiple decorators as long as they don't conflict.</p>
<p>A decorator is not a special object, it's just a one-argument function. The decorator is equivalent to the following pseudocode.</p>
<pre><code class="language-python">X=...
X = deco(X)
</code></pre>
<p>Erg doesn't allow reassignment of variables, so code like the one above won't work.
For simple variables it's the same as <code>X = deco(...)</code>, but for instant blocks and subroutines you can't do that, so you need a decorator.</p>
<pre><code class="language-python">@deco
f x =
    y = ...
    x + y

# You can also prevent the code from becoming horizontal
@LongNameDeco1
@LongNameDeco2
C = Class...
</code></pre>
<p>Below are some frequently used built-in decorators.</p>
<h2 id="inheritable"><a class="header" href="#inheritable">Inheritable</a></h2>
<p>Indicates that the defining type is an inheritable class. If you specify <code>&quot;public&quot;</code> for the argument <code>scope</code>, it will be possible to inherit even the class of the external module. By default it is <code>&quot;private&quot;</code> and cannot be inherited externally.</p>
<p>##Final</p>
<p>Make the method non-overridable. Adding it to a class makes it a non-inheritable class, but since it's the default it doesn't make sense.</p>
<h2 id="override"><a class="header" href="#override">Override</a></h2>
<p>Used when overriding attributes. By default, Erg will throw an error if you try to define the same attribute as the base class.</p>
<h2 id="impl"><a class="header" href="#impl">Impl</a></h2>
<p>Indicates that the argument trait is implemented.</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
Sub = Trait {
    .`_-_` = Self.(Self) -&gt; Self
}

C = Class({i = Int}, Impl := Add and Sub)
C.
    @Impl Add
    `_+_` self, other = C.new {i = self::i + other::i}
    @Impl Sub
    `_-_` self, other = C.new {i = self::i - other::}
</code></pre>
<h2 id="attach"><a class="header" href="#attach">Attach</a></h2>
<p>Specifies the attachment patch that comes with the trait by default.
This allows you to reproduce the same behavior as Rust traits.</p>
<pre><code class="language-python"># foo.er
Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
@Attach AddForInt, AddForOdd
ClosedAdd = Subsume Add(Self)

AddForInt = Patch(Int, Impl := ClosedAdd)
AddForInt.AddO = Int
AddForOdd = Patch(Odd, Impl := ClosedAdd)
AddForOdd.AddO = Even
</code></pre>
<p>This will automatically apply the attachment patch when importing traits from other modules.</p>
<pre><code class="language-python"># Originally, IntIsBinAdd and OddIsBinAdd should be imported at the same time, but if it's an attachment patch, you can omit it
{BinAdd; ...} = import &quot;foo&quot;

assert Int. AddO == Int
assert Odd.AddO == Even
</code></pre>
<p>Internally it's just attached using the trait's <code>.attach</code> method. Conflicts can be removed with the trait's <code>.detach</code> method.</p>
<pre><code class="language-python">@Attach X
T = Trait...
assert X in T. attaches
U = T.detach(X).attach(Y)
assert X not in U. attaches
assert Y in U. attaches
</code></pre>
<p>##Deprecated</p>
<p>Indicates that the variable specification is obsolete and deprecated.</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>Indicates that this is a test subroutine. Test subroutines are run with the <code>erg test</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-system"><a class="header" href="#error-handling-system">error handling system</a></h1>
<p>Mainly use Result type.
In Erg, an error occurs if you throw away an Error type object (not supported at the top level).</p>
<h2 id="exceptions-interop-with-python"><a class="header" href="#exceptions-interop-with-python">Exceptions, interop with Python</a></h2>
<p>Erg does not have an exception mechanism (Exception). When importing a Python function</p>
<ul>
<li>Set return value to <code>T or Error</code> type</li>
<li><code>T or Panic</code> type (may cause runtime error)</li>
</ul>
<p>There are two options, <code>pyimport</code> defaults to the latter. If you want to import as the former, use
Specify <code>Error</code> in <code>pyimport</code> <code>exception_type</code> (<code>exception_type: {Error, Panic}</code>).</p>
<h2 id="exceptions-and-result-types"><a class="header" href="#exceptions-and-result-types">Exceptions and Result types</a></h2>
<p>The <code>Result</code> type represents values ​​that may be errors. Error handling with <code>Result</code> is superior to the exception mechanism in several ways.
First of all, it's obvious from the type definition that the subroutine might throw an error, and it's also obvious when you actually use it.</p>
<pre><code class="language-python"># Python
try:
    x = foo().bar()
    y = baz()
    qux()
except e:
    print(e)
</code></pre>
<p>In the above example, it is not possible to tell from this code alone which function raised the exception. Even going back to the function definition, it's hard to tell if the function throws an exception.</p>
<pre><code class="language-python"># Erg
try!:
    do!:
        x = foo!()?.bar()
        y = baz!()
        qux!()?
    e =&gt;
        print! e
</code></pre>
<p>On the other hand, in this example we can see that <code>foo!</code> and <code>qux!</code> can raise an error.
Precisely <code>y</code> could also be of type <code>Result</code>, but you'll have to deal with it eventually to use the value inside.</p>
<p>The benefits of using the <code>Result</code> type don't stop there. The <code>Result</code> type is also thread-safe. This means that error information can be (easily) passed between parallel executions.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Since the <code>Error</code>/<code>Result</code> type alone does not cause side effects, unlike exceptions, it cannot have information such as the sending location (Context), but if you use the <code>.context</code> method, you can put information in the <code>Error</code> object. can be added. The <code>.context</code> method is a type of method that consumes the <code>Error</code> object itself and creates a new <code>Error</code> object. They are chainable and can hold multiple contexts.</p>
<pre><code class="language-python">f() =
    todo() \
        .context &quot;to be implemented in ver 1.2&quot; \
        .context &quot;and more hints ...&quot;

f()
# Error: not implemented yet
# hint: to be implemented in ver 1.2
# hint: and more hints ...
</code></pre>
<p>Note that <code>Error</code> attributes such as <code>.msg</code> and <code>.kind</code> are not secondary, so they are not context and cannot be overridden as they were originally created.</p>
<h2 id="stack-trace"><a class="header" href="#stack-trace">Stack trace</a></h2>
<p>The <code>Result</code> type is often used in other languages ​​because of its convenience, but it has the disadvantage of making it difficult to understand the source of an error compared to the exception mechanism.
Therefore, in Erg, the <code>Error</code> object has an attribute called <code>.stack</code>, and reproduces a pseudo-exception mechanism-like stack trace.
<code>.stack</code> is an array of caller objects. Each time an Error object is <code>returned</code> (including by <code>?</code>) it pushes its calling subroutine onto the <code>.stack</code>.
And if it is <code>?</code>ed or <code>.unwrap</code>ed in a context where <code>return</code> is not possible, it will panic with a traceback.</p>
<pre><code class="language-python">f x =
    ...
    y = foo.try_some(x)?
    ...

g x =
    y = f(x)?
    ...

i = g(1)?
# Traceback (most recent call first):
# ...
# Foo.try_some, line 10, file &quot;foo.er&quot;
# 10 | y = foo.try_some(x)?
# module::f, line 23, file &quot;foo.er&quot;
# 23 | y = f(x)?
# module::g, line 40, file &quot;foo.er&quot;
# 40 | i = g(1)?
# Error: ...
</code></pre>
<h2 id="panic"><a class="header" href="#panic">Panic</a></h2>
<p>Erg also has a mechanism for dealing with unrecoverable errors called <strong>panicing</strong>.
An unrecoverable error is an error caused by an external factor such as a software/hardware malfunction, an error so fatal that it makes no sense to continue executing the code, or an error unexpected by the programmer. Etc. If this happens, the program will be terminated immediately, because the programmer's efforts cannot restore normal operation. This is called &quot;panicing&quot;.</p>
<p>Panic is done with the <code>panic</code> function.</p>
<pre><code class="language-python">panic &quot;something went wrong!&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pipeline-operator"><a class="header" href="#pipeline-operator">pipeline operator</a></h1>
<p>Pipeline operators are used like this:</p>
<pre><code class="language-python">assert f(g(x)) == (x |&gt; g |&gt; f)
assert f(g(x, y)) == ((x, y) |&gt; g |&gt; f)
</code></pre>
<p>In other words, the order <code>Callable(object)</code> can be changed to <code>object |&gt; Callable</code>.
The pipeline operator can also be used on methods. For methods, <code>object.method(args)</code> changes to <code>object |&gt;.method(args)</code>.
It looks like just more <code>|&gt;</code>, but since the bond strength is low, you may be able to reduce the amount of <code>()</code>.</p>
<pre><code class="language-python">rand = -1.0..1.0 |&gt;.sample!()
log rand # 0.2597...

1+1*2 |&gt;.times do log(&quot;a&quot;, end := &quot;&quot;) # aaa

evens = 1..100 |&gt;.iter |&gt;.filter i -&gt; i % 2 == 0 |&gt;.collect Array
# When implemented without the pipeline operator,
_evens = (1..100).iter().filter(i -&gt; i % 2 == 0).collect(Array)
# or
__evens = 1..100 \
    .iter() \
    .filter i -&gt; i % 2 == 0 \
    .collect Array
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integration-with-python"><a class="header" href="#integration-with-python">Integration With Python</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="package-system"><a class="header" href="#package-system">Package System</a></h1>
<p>Erg packages can be roughly classified into the app package, which is the application, and the lib package, which is the library.
The entry point of the app package is <code>src/app.er</code>. The <code>main</code> function defined in <code>app.er</code> is executed.
The entry point for the lib package is <code>src/lib.er</code>. Importing a package is equivalent to importing <code>lib.er</code>.</p>
<p>A package has a sub-structure called a module, which in Erg is an Erg file or directory composed of Erg files. External Erg files/directories are manipulatable objects as module objects.</p>
<p>In order for a directory to be recognized as a module, it is necessary to place a <code>(directory name).er</code> file in the directory.
This is similar to Python's <code>__init__.py</code>, but unlike <code>__init__.py</code>, it is placed outside the directory.</p>
<p>As an example, consider the following directory structure.</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.er
    └─ qux.er
</code></pre>
<p>You can import <code>foo</code> and <code>bar</code> modules in <code>app.er</code>. The <code>bar</code> directory can be recognized as a module because of the <code>bar.er</code> file.
A <code>foo</code> module is a module consisting of files, and a <code>bar</code> module is a module consisting of directories. The <code>bar</code> module also contains <code>baz</code> and <code>qux</code> modules.
This module is simply an attribute of the <code>bar</code> module, and can be accessed from <code>app.er</code> as follows.</p>
<pre><code class="language-python"># app.er
foo = import &quot;foo&quot;
bar = import &quot;bar&quot;
baz = bar.baz
# or `baz = import &quot;bar/baz&quot;`

main args =
    ...
</code></pre>
<p>Note the <code>/</code> delimiter for accessing submodules. This is because there can be file names such as <code>bar.baz.er</code>.
Such filenames are discouraged, since the <code>.er</code> prefix is meaningful in Erg.
For example, a module for testing. A file ending with <code>.test.er</code> is a (white box) test module, which executes a subroutine decorated with <code>@Test</code> when the test is run.</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  └─ foo.test.er
./src

```python
# app.er
foo = import &quot;foo&quot;

main args =
    ...
</code></pre>
<p>Also, files ending in <code>.private.er</code> are private modules and can only be accessed by modules in the same directory.</p>
<pre><code class="language-console">└─┬
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.private.er
    └─ qux.er
</code></pre>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;
bar.qux
bar.baz # AttributeError: module 'baz' is private
</code></pre>
<pre><code class="language-python"># qux.er
baz = import &quot;baz&quot;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="generator"><a class="header" href="#generator">Generator</a></h1>
<p>Generators are special procedures that use the <code>yield!</code> procedure in a block.</p>
<pre><code class="language-python">g!() =
    yield! 1
    yield! 2
    yield! 3
</code></pre>
<p><code>yield!</code> is a procedure defined in a block of subroutines that calls <code>self!.yield!</code>. Like <code>return</code>, it returns the value passed to it as a return value, but it has the feature of saving the current execution state of the block and executing it from the beginning when it is called again.
A generator is both a procedure and an iterator; a Python generator is a function that creates an iterator, while Erg iterates directly. Procedures themselves are generally not mutable objects (no <code>!</code>), but a generator is a mutable object because its own contents can change with each execution.</p>
<pre><code class="language-python"># Generator!
g!: Generator!((), Int)
assert g!() == 1
assert g!() == 2
assert g!() == 3
</code></pre>
<p>A Python-style generator can be defined as follows.</p>
<pre><code class="language-python">make_g() = () =&gt;
    yield! 1
    yield! 2
    yield! 3
make_g: () =&gt; Generator!
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="index"><a class="header" href="#index">index</a></h1>
<p>See <a href="../API/index.html">here</a> for APIs not in this index.</p>
<p>Also, see <a href="../terms.html">here</a> for terminology.</p>
<h2 id="symbol"><a class="header" href="#symbol">symbol</a></h2>
<ul>
<li>! → <a href="./07_side_effect.html">side effect</a>
<ul>
<li>!-type → <a href="./type/18_mut.html">mutable type</a></li>
</ul>
</li>
<li>? → <a href="./30_error_handling.html">error handling</a></li>
<li># → <a href="./00_basic.html">Str</a></li>
<li>$ → <a href="./type/advanced/shared.html">shared</a></li>
<li>%</li>
<li>&amp;
<ul>
<li>&amp;&amp;</li>
</ul>
</li>
<li><a href="./20_naming_rule.html#literal-identifiers">′ (single quote)</a></li>
<li><a href="./01_literal.html#str-literal">&quot; (double quote)</a></li>
<li>() → <a href="./11_tuple.html">Tuple</a></li>
<li>*
<ul>
<li>* → <a href="./01_literal.html">*-less multiplication</a></li>
</ul>
</li>
<li>+ (prefix) → <a href="./06_operator.html">operator</a>
<ul>
<li>+_ → + (prefix)</li>
</ul>
</li>
<li>+ (infix) → <a href="./06_operator.html">operator</a></li>
<li>+ (infix) → <a href="./type/03_trait.html">Trait</a></li>
<li>,</li>
<li>− (prefix)
<ul>
<li>−_ → − (prefix)</li>
</ul>
</li>
<li>− (infix) → <a href="./06_operator.html">operator</a></li>
<li>− (infix) → <a href="./type/03_trait.html">Trait</a>
<ul>
<li>−&gt; → <a href="./21_lambda.html">anonymous function</a></li>
</ul>
</li>
<li>. → <a href="./19_visibility.html">Visibility</a>
<ul>
<li>.. → <a href="./01_literal.html">closed range operator</a></li>
<li>..&lt; → <a href="./01_literal.html">right-open range operator</a></li>
<li>...
<ul>
<li>... → <a href="./28_spread_syntax.html#extract-assignment">Extract assignment</a></li>
<li>... → <a href="./04_function.html#variable-length-arguments">Variable-length arguments</a></li>
</ul>
</li>
</ul>
</li>
<li>/</li>
<li>:
<ul>
<li>: → <a href="./04_function.html">Colon application style</a></li>
<li>: → <a href="./03_declaration.md.html">Type ascription</a></li>
<li>: → <a href="./04_function.html">Keyword arguments</a></li>
<li>:: → <a href="./19_visibility.html">private variable modifier</a></li>
<li>:= → <a href="./04_function.html">default parameters</a></li>
</ul>
</li>
<li>;</li>
<li>&lt;
<ul>
<li>&lt;: → <a href="./type/02_basic.html">Subtype specification</a></li>
<li>&lt;&lt;</li>
<li>&lt;=</li>
<li>&lt;.. → <a href="./01_literal.html">left-open range operator</a></li>
<li>&lt;..&lt; → <a href="./01_literal.html">open range operator</a></li>
</ul>
</li>
<li>= → <a href="./19_visibility.html">Variable</a>
<ul>
<li>==</li>
<li>=&gt; → <a href="./08_procedure.html">anonymous procedure operator</a></li>
</ul>
</li>
<li>&gt;
<ul>
<li>&gt;&gt;</li>
<li>&gt;=</li>
</ul>
</li>
<li>@ → <a href="./29_decorator.html">decorator</a></li>
<li>[] → <a href="./10_array.html">Array</a></li>
<li>\ → <a href="./00_basic.html">Escaping</a></li>
<li>^
<ul>
<li>^^</li>
</ul>
</li>
<li>_ → <a href="./type/advanced/erasure.html">Type erasure</a>
<ul>
<li>_+_ → + (infix)</li>
<li>_-_ → − (infix)</li>
</ul>
</li>
<li><a href="./22_subroutine.html#operator">`` (back quote)</a></li>
<li>{}
<ul>
<li><a href="./type/01_type_system.html">{} type</a></li>
</ul>
</li>
<li>{=} → <a href="./type/01_type_system.html#classification">Type System</a>
<ul>
<li><a href="./13_record.html#empty-record">{=} type</a></li>
</ul>
</li>
<li>|
<ul>
<li>|| → <a href="./type/advanced/">Type variable list</a></li>
</ul>
</li>
<li>~</li>
</ul>
<h2 id="alphabet"><a class="header" href="#alphabet">alphabet</a></h2>
<h3 id="a"><a class="header" href="#a">A</a></h3>
<ul>
<li>[Add]</li>
<li><a href="type/02_basic.html#aliasing">alias</a></li>
<li><a href="./type/02_basic.html#aliasing">Aliasing</a></li>
<li><a href="./type/15_quantified.html#all-symmetric-types">All symmetric types</a></li>
<li><a href="./type/13_algebraic.html">algebraic type</a></li>
<li>[And]</li>
<li>[and]</li>
<li><a href="./21_lambda.html">anonymous function</a></li>
<li>anonymous type → <a href="./type/01_type_system.html">Type system</a></li>
<li><a href="./10_array.html">Array</a></li>
<li>[assert]</li>
<li><a href="./29_decorator.html#attach">Attach</a></li>
<li><a href="type/09_attributive.html">attribute</a></li>
<li><a href="./type/02_basic.html#attribute-definitions">Attribute definitions</a></li>
<li><a href="./type/09_attributive.html">Attribute type</a></li>
</ul>
<h3 id="b"><a class="header" href="#b">B</a></h3>
<ul>
<li><a href="./01_literal.html#boolean-object">Bool, Boolean</a></li>
<li><a href="./01_literal.html#boolean-object">Boolean object</a></li>
<li><a href="./18_ownership.html#borrow">borrowing</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li><a href="./type/17_type_casting.html">Cast</a></li>
<li><a href="./00_basic.html#comments">Comments</a></li>
<li><a href="./01_literal.html#complex-object">Complex object</a></li>
<li><a href="./04_function.html#compile-time-functions">Compile-time functions</a></li>
<li><a href="./18_ownership.html#circular-references">circular references</a></li>
<li><a href="./type/04_class.html">Class</a></li>
<li><a href="./type/04_class.html#class-relationships">Class relationship</a></li>
<li><a href="./type/16_subtyping.html#class-upcasting">Class upcasting</a></li>
<li><a href="./04_function.html#colon-application-style">Colon application style</a></li>
<li><a href="./23_closure.html">Closure</a></li>
<li><a href="./01_literal.html#compound-literals">Compound literals</a></li>
<li><a href="./type/13_algebraic.html#complement">Complement</a></li>
<li><a href="./27_comprehension.html">Comprehension</a></li>
<li><a href="./17_mutability.html#constant">constant</a></li>
<li><a href="./02_name.html#constants">Constants</a></li>
<li><a href="./30_error_handling.html#context">Context</a></li>
</ul>
<h3 id="d"><a class="header" href="#d">D</a></h3>
<ul>
<li><a href="./type/01_type_system.html#data-type">Data type</a></li>
<li><a href="./03_declaration.html">Declaration</a></li>
<li><a href="./29_decorator.html">decorator</a></li>
<li><a href="./04_function.html#default-parameters">Default parameters</a></li>
<li><a href="./02_name.html#delete-an-variable">Del</a></li>
<li><a href="./type/14_dependent.html">Dependent type</a></li>
<li>Deprecated</li>
<li><a href="./12_dict.html">Dict</a></li>
<li><a href="./type/13_algebraic.html#diff">Diff</a></li>
<li>distinct</li>
<li><a href="./type/17_type_casting.html#downcasting">Downcasting</a></li>
</ul>
<h3 id="e"><a class="header" href="#e">E</a></h3>
<ul>
<li><a href="./13_record.html#empty-record">Empty record</a></li>
<li><a href="./type/04_class.html#enum-class">Enum class</a></li>
<li><a href="./type/11_enum.html">Enum type</a></li>
<li><a href="./type/12_refinement.html#enumerated-interval-and-refinement-types">Enumerated, Interval and Refinement types</a></li>
<li><a href="./30_error_handling.html">error handling</a></li>
<li><a href="./type/advanced/existential.html">Existential type</a></li>
<li><a href="./01_literal.html#exponential-literal">Exponential literal</a></li>
<li><a href="./28_spread_syntax.html#extract-assignment">Extract assignment</a></li>
</ul>
<h3 id="f"><a class="header" href="#f">F</a></h3>
<ul>
<li>False → <a href="./01_literal.html#boolean-object">Boolean object</a></li>
<li><a href="./01_literal.html#float-object">Float object</a></li>
<li><a href="./05_builtin_funcs.html#for">for</a></li>
<li><a href="./type/07_patch.html#for-all-patch">For-All patch</a></li>
<li><a href="./18_ownership.html#freeze">freeze</a></li>
<li><a href="./04_function.html">Function</a></li>
<li><a href="./04_function.html#function-definition-with-multiple-patterns">Function definition with multiple patterns</a></li>
</ul>
<h3 id="g"><a class="header" href="#g">G</a></h3>
<ul>
<li><a href="./type/advanced/GADTs.html">GADTs(Generalized Algebraic Data Types)</a></li>
<li><a href="./34_generator.html">Generator</a></li>
<li><a href="./type/07_patch.html#glue-patch">Glue Patch</a></li>
</ul>
<h3 id="h"><a class="header" href="#h">H</a></h3>
<h3 id="i"><a class="header" href="#i">I</a></h3>
<ul>
<li><a href="./09_builtin_procs.html#id">id</a></li>
<li><a href="./05_builtin_funcs.html#if">if</a></li>
<li><a href="./33_package_system.html">import</a></li>
<li><a href="./29_decorator.html#impl">impl</a></li>
<li>[in]</li>
<li><a href="./00_basic.html#indentation">Indention</a></li>
<li><a href="./13_record.html#instant-block">Instant block</a></li>
<li><a href="./type/04_class.html#instance-and-class-attributes">Instance/class attributes</a></li>
<li><a href="./29_decorator.html#inheritable">inheritable</a></li>
<li><a href="./type/05_inheritance.html">inheritance</a></li>
<li><a href="./01_literal.html">Int</a></li>
<li><a href="./32_integration_with_Python.html">Integration with Python</a></li>
<li><a href="./type/10_interval.html">Interval Type</a></li>
<li><a href="./type/13_algebraic.html#intersection">Intersection</a></li>
<li><a href="./16_iterator.html">Iterator</a></li>
</ul>
<h3 id="j"><a class="header" href="#j">J</a></h3>
<h3 id="k"><a class="header" href="#k">K</a></h3>
<ul>
<li><a href="./04_function.html#keyword-arguments">Keyword arguments</a></li>
<li><a href="./type/advanced/kind.html">Kind</a></li>
</ul>
<h3 id="l"><a class="header" href="#l">L</a></h3>
<ul>
<li>lambda → <a href="./21_lambda.html">anonymous function</a></li>
<li>let-polymorphism → [rank 1 polymorphism]</li>
<li><a href="./20_naming_rule.html#literal-identifiers">Literal Identifiers</a></li>
</ul>
<h3 id="m"><a class="header" href="#m">M</a></h3>
<ul>
<li>[match]</li>
<li><a href="./type/advanced/marker_trait.html">Marker trait</a></li>
<li><a href="./07_side_effect.html#methods">Method</a></li>
<li>Modifier → <a href="./29_decorator.html">decorator</a></li>
<li><a href="./24_module.html">module</a></li>
<li><a href="type/05_inheritance.html#multiple-inheritance">Multiple inheritance</a></li>
<li><a href="type/05_inheritance.html#multi-layer-multi-level-inheritance">Multi-layer (multi-level) Inheritance</a></li>
<li><a href="./type/18_mut.html">Mutable type</a></li>
<li><a href="./type/advanced/mut_struct.html">Mutable structure type</a></li>
<li><a href="./17_mutability.html">Mutability</a></li>
</ul>
<h3 id="n"><a class="header" href="#n">N</a></h3>
<ul>
<li><a href="./01_literal.html#int-literal">Nat</a></li>
<li>[Never]</li>
<li><a href="./type/advanced/newtype.html">New type</a></li>
<li><a href="./12_dict.html#heterogeneous-dict">Heterogeneous Dict</a></li>
<li>None → [None Object]</li>
<li>[None Object]</li>
<li>Nominal Subtyping → <a href="./type/04_class.html">Class</a></li>
<li>[Not]</li>
<li>[not]</li>
</ul>
<h3 id="o"><a class="header" href="#o">O</a></h3>
<ul>
<li><a href="./25_object_system.html">Object</a></li>
<li>[Option]</li>
<li>[Or]</li>
<li>[or]</li>
<li>[Ord]</li>
<li><a href="./18_ownership.html">ownership system</a></li>
<li><a href="./type/advanced/overloading.html">Overloading</a></li>
<li><a href="./type/05_inheritance.html#overriding">Overriding</a></li>
<li><a href="./type/03_trait.html#override-in-trait">Override in trait</a></li>
</ul>
<h3 id="p"><a class="header" href="#p">P</a></h3>
<ul>
<li><a href="./30_error_handling.html#panic">Panic</a></li>
<li><a href="./type/07_patch.html">Patch</a></li>
<li><a href="./26_pattern_matching.html">Pattern match</a></li>
<li><a href="./type/advanced/phantom.html">Phantom class</a></li>
<li><a href="./31_pipeline.html">pipeline operator</a></li>
<li><a href="./type/19_bound.html#predicate">Predicate</a></li>
<li>[print!]</li>
<li><a href="./08_procedure.html">Procedures</a></li>
<li><a href="./type/advanced/projection.html">Projection type</a></li>
<li>Python → <a href="./32_integration_with_Python.html">Integration with Python</a></li>
</ul>
<h3 id="q"><a class="header" href="#q">Q</a></h3>
<ul>
<li><a href="./type/15_quantified.html">Quantified type</a></li>
<li><a href="./type/advanced/quantified_dependent.html">Quantified dependent type</a></li>
</ul>
<h3 id="r"><a class="header" href="#r">R</a></h3>
<ul>
<li><a href="./01_literal.html#range-object">Range Object</a></li>
<li>[ref]</li>
<li>[ref!]</li>
<li><a href="./13_record.html">Record</a></li>
<li><a href="./04_function.html#recursive-functions">Recursive functions</a></li>
<li><a href="./type/12_refinement.html#refinement-pattern">Refinement pattern</a></li>
<li><a href="./type/12_refinement.html">Refinement type</a></li>
<li><a href="./18_ownership.html#replication">replication</a></li>
<li><a href="./type/05_inheritance.html#replacing-traits-or-what-looks-like-it">Replacing traits</a></li>
<li>Result → <a href="./30_error_handling.html">error handling</a></li>
</ul>
<h3 id="s"><a class="header" href="#s">S</a></h3>
<ul>
<li><a href="./00_basic.html#scripts">Script</a></li>
<li>self</li>
<li><a href="./type/advanced/special.html">Self</a></li>
<li><a href="./type/advanced/shared.html">Shared reference</a></li>
<li><a href="./07_side_effect.html">side-effect</a></li>
<li><a href="./type/12_refinement.html#smart-cast">Smart cast</a></li>
<li><a href="./28_spread_syntax.html">Spread assignment</a></li>
<li><a href="./type/advanced/special.html#special-type-variables">special type variables</a></li>
<li><a href="30_error_handling.html#stack-trace">Stack trace</a></li>
<li><a href="./type/01_type_system.html#structure-type-anonymous-type">Structure type</a></li>
<li><a href="./type/07_patch.html#structural-patch">Structural patch</a></li>
<li><a href="./type/03_trait.html#structural-traits">Structural trait</a></li>
<li><a href="./type/01_type_system.html#classification">Structural subtyping</a></li>
<li><a href="./type/16_subtyping.html#structural-types-and-class-type-relationships">Structural types and class type relationships</a></li>
<li><a href="./01_literal.html#str-literal">Str</a></li>
<li><a href="./type/16_subtyping.html">Subtyping</a></li>
<li><a href="./type/16_subtyping.html#subtyping-of-subroutines">Subtyping of subroutines</a></li>
<li><a href="./type/02_basic.html#subtype-specification">Subtype specification</a></li>
<li><a href="./type/15_quantified.html#subtyping-of-polymorphic-function-types">Subtyping of polymorphic function types</a></li>
<li><a href="./22_subroutine.html">Subroutine signatures</a></li>
</ul>
<h3 id="t"><a class="header" href="#t">T</a></h3>
<ul>
<li><a href="./29_decorator.html#test">Test</a></li>
<li><a href="./type/03_trait.html">Traits</a></li>
<li><a href="./type/03_trait.html#trait-inclusion">Trait inclusion</a></li>
<li>True → <a href="./01_literal.html#boolean-object">Boolean object</a></li>
<li><a href="./type/13_algebraic.html#true-algebraic-type">True algebraic type</a></li>
<li>[Type]</li>
<li><a href="./15_type.html">type</a></li>
<li><a href="./type/15_quantified.html#type-arguments-in-method-definitions">Type arguments in method definitions</a></li>
<li><a href="./type/19_bound.html">Type bound</a></li>
<li><a href="./type/01_type_system.html#type-definitions">Type definitions</a></li>
<li><a href="./type/advanced/erasure.html">Type erasure</a></li>
<li><a href="./type/01_type_system.html#type-inference-system">Type inference system</a></li>
<li><a href="./type/02_basic.html#type-specification">Type specification</a></li>
<li><a href="./type/01_type_system.html">Type system</a></li>
<li><a href="./type/advanced/widening.html">Type widening</a></li>
<li><a href="./11_tuple.html">Tuple</a></li>
</ul>
<h3 id="u"><a class="header" href="#u">U</a></h3>
<ul>
<li><a href="type/13_algebraic.html#union">union</a></li>
<li><a href="./11_tuple.html#unit">Unit</a></li>
<li><a href="type/17_type_casting.html#upcasting">Upcasting</a></li>
</ul>
<h3 id="v"><a class="header" href="#v">V</a></h3>
<ul>
<li><a href="./type/08_value.html">Value type</a></li>
<li><a href="./02_name.html">Variable</a></li>
<li><a href="./04_function.html#variable-length-arguments">variable-length arguments</a></li>
</ul>
<h3 id="w"><a class="header" href="#w">W</a></h3>
<ul>
<li>[while]</li>
</ul>
<h3 id="x"><a class="header" href="#x">X</a></h3>
<h3 id="y"><a class="header" href="#y">Y</a></h3>
<h3 id="z"><a class="header" href="#z">Z</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
