<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Erg Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="theme/css/error.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_basic.html"><strong aria-hidden="true">1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="01_literal.html"><strong aria-hidden="true">2.</strong> Literal</a></li><li class="chapter-item expanded "><a href="02_name.html"><strong aria-hidden="true">3.</strong> Name</a></li><li class="chapter-item expanded "><a href="03_declaration.html"><strong aria-hidden="true">4.</strong> Declaration</a></li><li class="chapter-item expanded "><a href="04_function.html"><strong aria-hidden="true">5.</strong> Function</a></li><li class="chapter-item expanded "><a href="05_builtin_funcs.html"><strong aria-hidden="true">6.</strong> Builtin Functions</a></li><li class="chapter-item expanded "><a href="06_operator.html"><strong aria-hidden="true">7.</strong> Operator</a></li><li class="chapter-item expanded "><a href="07_side_effect.html"><strong aria-hidden="true">8.</strong> Side Effect</a></li><li class="chapter-item expanded "><a href="08_procedure.html"><strong aria-hidden="true">9.</strong> Procedure</a></li><li class="chapter-item expanded "><a href="09_builtin_procs.html"><strong aria-hidden="true">10.</strong> Builtin Procedures</a></li><li class="chapter-item expanded "><a href="10_array.html"><strong aria-hidden="true">11.</strong> Array</a></li><li class="chapter-item expanded "><a href="11_tuple.html"><strong aria-hidden="true">12.</strong> Tuple</a></li><li class="chapter-item expanded "><a href="12_dict.html"><strong aria-hidden="true">13.</strong> Dict</a></li><li class="chapter-item expanded "><a href="13_record.html"><strong aria-hidden="true">14.</strong> Record</a></li><li class="chapter-item expanded "><a href="14_set.html"><strong aria-hidden="true">15.</strong> Set</a></li><li class="chapter-item expanded "><a href="15_type.html"><strong aria-hidden="true">16.</strong> Type</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/01_type_system.html"><strong aria-hidden="true">16.1.</strong> Type System</a></li><li class="chapter-item expanded "><a href="type/02_basic.html"><strong aria-hidden="true">16.2.</strong> Basics</a></li><li class="chapter-item expanded "><a href="type/03_trait.html"><strong aria-hidden="true">16.3.</strong> Trait</a></li><li class="chapter-item expanded "><a href="type/04_class.html"><strong aria-hidden="true">16.4.</strong> Class</a></li><li class="chapter-item expanded "><a href="type/05_inheritance.html"><strong aria-hidden="true">16.5.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="type/06_nst_vs_sst.html"><strong aria-hidden="true">16.6.</strong> NST vs SST</a></li><li class="chapter-item expanded "><a href="type/07_patch.html"><strong aria-hidden="true">16.7.</strong> Patch</a></li><li class="chapter-item expanded "><a href="type/08_value.html"><strong aria-hidden="true">16.8.</strong> Value Type</a></li><li class="chapter-item expanded "><a href="type/09_attributive.html"><strong aria-hidden="true">16.9.</strong> Attributive Type</a></li><li class="chapter-item expanded "><a href="type/10_interval.html"><strong aria-hidden="true">16.10.</strong> Interval Type</a></li><li class="chapter-item expanded "><a href="type/11_enum.html"><strong aria-hidden="true">16.11.</strong> Enum Type</a></li><li class="chapter-item expanded "><a href="type/12_refinement.html"><strong aria-hidden="true">16.12.</strong> Refinement Type</a></li><li class="chapter-item expanded "><a href="type/13_algebraic.html"><strong aria-hidden="true">16.13.</strong> Algebraic Type</a></li><li class="chapter-item expanded "><a href="type/14_dependent.html"><strong aria-hidden="true">16.14.</strong> Dependent Type</a></li><li class="chapter-item expanded "><a href="type/15_quantified.html"><strong aria-hidden="true">16.15.</strong> Quantified Type</a></li><li class="chapter-item expanded "><a href="type/16_subtyping.html"><strong aria-hidden="true">16.16.</strong> Subtyping</a></li><li class="chapter-item expanded "><a href="type/17_type_casting.html"><strong aria-hidden="true">16.17.</strong> Type Casting</a></li><li class="chapter-item expanded "><a href="type/18_mut.html"><strong aria-hidden="true">16.18.</strong> Mutable Type</a></li><li class="chapter-item expanded "><a href="type/advanced.html"><strong aria-hidden="true">16.19.</strong> Advanced</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/advanced/default_param.html"><strong aria-hidden="true">16.19.1.</strong> Default Parameter</a></li><li class="chapter-item expanded "><a href="type/advanced/erasure.html"><strong aria-hidden="true">16.19.2.</strong> Type Erasure</a></li><li class="chapter-item expanded "><a href="type/advanced/existential.html"><strong aria-hidden="true">16.19.3.</strong> Existential</a></li><li class="chapter-item expanded "><a href="type/advanced/GADTs.html"><strong aria-hidden="true">16.19.4.</strong> GADTs</a></li><li class="chapter-item expanded "><a href="type/advanced/keyword_param.html"><strong aria-hidden="true">16.19.5.</strong> Keyword Parameters</a></li><li class="chapter-item expanded "><a href="type/advanced/kind.html"><strong aria-hidden="true">16.19.6.</strong> Kind</a></li><li class="chapter-item expanded "><a href="type/advanced/marker_trait.html"><strong aria-hidden="true">16.19.7.</strong> Marker Trait</a></li><li class="chapter-item expanded "><a href="type/advanced/mut_struct.html"><strong aria-hidden="true">16.19.8.</strong> Mutable Struct</a></li><li class="chapter-item expanded "><a href="type/advanced/phantom.html"><strong aria-hidden="true">16.19.9.</strong> Phantom Type</a></li><li class="chapter-item expanded "><a href="type/advanced/projection.html"><strong aria-hidden="true">16.19.10.</strong> Projection Type</a></li><li class="chapter-item expanded "><a href="type/advanced/quantified_dependent.html"><strong aria-hidden="true">16.19.11.</strong> Quantified Dependent Type</a></li><li class="chapter-item expanded "><a href="type/advanced/shared.html"><strong aria-hidden="true">16.19.12.</strong> Shared</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="16_iterator.html"><strong aria-hidden="true">17.</strong> Iterator</a></li><li class="chapter-item expanded "><a href="17_mutability.html"><strong aria-hidden="true">18.</strong> Mutability</a></li><li class="chapter-item expanded "><a href="18_ownership.html"><strong aria-hidden="true">19.</strong> Ownership</a></li><li class="chapter-item expanded "><a href="19_visibility.html"><strong aria-hidden="true">20.</strong> Visibility</a></li><li class="chapter-item expanded "><a href="20_naming_rule.html"><strong aria-hidden="true">21.</strong> Naming Rule</a></li><li class="chapter-item expanded "><a href="21_lambda.html"><strong aria-hidden="true">22.</strong> Lambda</a></li><li class="chapter-item expanded "><a href="22_subroutine.html"><strong aria-hidden="true">23.</strong> Subroutine</a></li><li class="chapter-item expanded "><a href="23_closure.html"><strong aria-hidden="true">24.</strong> Closure</a></li><li class="chapter-item expanded "><a href="24_module.html"><strong aria-hidden="true">25.</strong> Module</a></li><li class="chapter-item expanded "><a href="25_object_system.html"><strong aria-hidden="true">26.</strong> Object System</a></li><li class="chapter-item expanded "><a href="26_pattern_matching.html"><strong aria-hidden="true">27.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="27_comprehension.html"><strong aria-hidden="true">28.</strong> Comprehension</a></li><li class="chapter-item expanded "><a href="28_spread_syntax.html"><strong aria-hidden="true">29.</strong> Spread Syntax</a></li><li class="chapter-item expanded "><a href="29_decorator.html"><strong aria-hidden="true">30.</strong> Decorator</a></li><li class="chapter-item expanded "><a href="30_error_handling.html"><strong aria-hidden="true">31.</strong> Error Handling</a></li><li class="chapter-item expanded "><a href="31_pipeline.html"><strong aria-hidden="true">32.</strong> Pipeline</a></li><li class="chapter-item expanded "><a href="32_integration_with_Python.html"><strong aria-hidden="true">33.</strong> Integration With Python</a></li><li class="chapter-item expanded "><a href="33_package_system.html"><strong aria-hidden="true">34.</strong> Package System</a></li><li class="chapter-item expanded "><a href="34_generator.html"><strong aria-hidden="true">35.</strong> Generator</a></li><li class="chapter-item expanded "><a href="quick_tour.html"><strong aria-hidden="true">36.</strong> Quick Tour</a></li><li class="chapter-item expanded "><a href="indexes.html"><strong aria-hidden="true">37.</strong> Index</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Erg Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本事項"><a class="header" href="#基本事項">基本事項</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/00_basic.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/00_basic.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>: 本ドキュメントは未完成です。校正(文体、正しいリンクが張られているか、など)がなされていません。また、Ergの文法はバージョン0.*の間に破壊的変更が加えられる可能性があり、それに伴うドキュメントの更新が追いついていない可能性があります。予めご了承ください。
また、本ドキュメントの誤りを見つけた場合は、<a href="https://forms.gle/HtLYRfYzWCAaeTGb6">こちらのフォーム</a>または<a href="https://github.com/erg-lang/erg/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.yaml">GitHubリポジトリ</a>から修正の提案をしていただけると幸いです。</p>
</blockquote>
<p>本ドキュメントは、Ergの基本文法について解説するものです。
既にpythonなどの言語に触れた経験がある方は、概説的な<a href="./quick_tour.html">quick tour</a>もあるためそちらを参照してください。
また、<a href="../API/index.html">標準API</a>や<a href="../dev_guide/index.html">Ergコントリビューター向けの内部資料</a>は別途存在します。文法やErg本体についての詳細な説明が必要な場合はそちらを参照してください。</p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h2>
<p>まずは恒例の、Hello Worldを行いましょう。</p>
<pre><code class="language-python">print!(&quot;Hello, World!&quot;)
</code></pre>
<p>Pythonや同系統の言語とほぼ同じです。目を引くのは<code>print</code>の後に付く<code>!</code>ですが、これの意味はおいおい説明します。
また、Ergでは解釈に紛れのない限り括弧<code>()</code>を省略することが出来ます。
括弧の省略ができるのはRubyと似ていますが、複数の解釈ができる括弧省略はできませんし、また引数が0個のときもPythonと同じく<code>()</code>の省略が出来ません。</p>
<pre><code class="language-python.checker_ignore">print! &quot;Hello, World!&quot; # OK
print! &quot;Hello,&quot;, &quot;World!&quot; # OK
print!() # OK
print! # OKだが呼び出しという意味ではなく、単に`print!`を呼び出し可能なオブジェクトとして取得するという意味となる

print! f x # OK、これは`print!(f(x))`として解釈される
print!(f(x, y)) # OK
print! f(x, y) # OK
print! f(x, g y) # OK
print! f x, y # NG, `print!(f(x), y)`または`print!(f(x, y))`の二通りの解釈ができてしまう
print!(f x, y) # NG, `print!(f(x), y)`または`print!(f(x, y))`の二通りの解釈ができてしまう
print! f(x, g y, z) # NG, `print!(x, g(y), z)`または`print!(x, g(y, z))`の二通りの解釈ができてしまう
</code></pre>
<h2 id="スクリプト"><a class="header" href="#スクリプト">スクリプト</a></h2>
<p>Ergのコードはスクリプトと呼ばれます。スクリプトはファイル形式(.er)で保存・実行できます。</p>
<p>以下のコードを&quot;hello.er&quot;として保存します。</p>
<pre><code class="language-python">print! &quot;hello, world&quot;
</code></pre>
<p>ターミナルですぐに実行することができます。</p>
<pre><code class="language-sh">$ erg hello.er
hello, world
</code></pre>
<h2 id="コメント"><a class="header" href="#コメント">コメント</a></h2>
<p><code>#</code>以降はコメントとして無視されます。コードの意図を説明したいときや一時的にコードを無効化したいときなどに使います。</p>
<pre><code class="language-python"># コメント
## `#`以降は改行されるまで無視されるため、`#`は何個でも使用できる
#[
複数行コメント
対応する`#[`から`]#`のところまでがコメントとして扱われる
]#
</code></pre>
<h2 id="式セパレータ"><a class="header" href="#式セパレータ">式、セパレータ</a></h2>
<p>スクリプトは、式(expression)の連なりです。式とは計算・評価ができるもので、Ergではほとんどすべてのものが式です。
各式はセパレータ―改行かセミコロン<code>;</code>―で区切ります。
Ergのスクリプトは基本的に左から右へ、上から下へ評価されます。</p>
<pre><code class="language-python">n = 1 # 代入式
f x, y = x + y # 関数定義
f(1, 2) # 関数適用式
1 + 1 # 演算子適用式
f(1, 2); 1 + 1
</code></pre>
<p>以下のように、ブロック内で最後に評価した式を変数の値とするインスタントブロックという機能があります。
これは引数なし関数とは違い、<code>()</code>をつけません。ブロックがその場で1度だけ評価されることに注意してください。</p>
<pre><code class="language-python">i =
    x = 1
    x + 1
assert i == 2
</code></pre>
<p>これはセミコロン(<code>;</code>)では実現できません。</p>
<pre><code class="language-python compile_fail">i = (x = 1; x + 1) # SyntaxError:  cannot use `;` in parentheses
</code></pre>
<h2 id="インデント"><a class="header" href="#インデント">インデント</a></h2>
<p>ErgはPythonと同じくインデントを使ってブロックを表します。ブロックの開始を示すトリガーとなる演算子(特殊形式)は、<code>=</code>, <code>-&gt;</code>, <code>=&gt;</code>, <code>do</code>, <code>do!</code>の5種類です(その他に、演算子ではありませんが<code>:</code>と<code>|</code>もインデントを生成します)。それぞれの意味は後述します。</p>
<pre><code class="language-python">f x, y =
    x + y

for! 0..9, i =&gt;
    print! i

for! 0..9, i =&gt;
    print! i; print! i

ans = match x:
    0 -&gt; &quot;zero&quot;
    _: 0..9 -&gt; &quot;1 dight&quot;
    _: 10..99 -&gt; &quot;2 dights&quot;
    _ -&gt; &quot;unknown&quot;
</code></pre>
<p>また1行が長くなりすぎる場合、<code>\</code>を使って途中で改行させることができます。</p>
<pre><code class="language-python"># これは`x + y + z`と解釈されず`x; +y; +z`と解釈される
x
+ y
+ z

# これは`x + y + z`と解釈される
x \
+ y \
+ z
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="リテラル"><a class="header" href="#リテラル">リテラル</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/01_literal.md&amp;commit_hash=7078f95cecc961a65befb15929af06ae2331c934"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/01_literal.md%26commit_hash%3D7078f95cecc961a65befb15929af06ae2331c934" alt="badge" /></a></p>
<h2 id="基本的なリテラル"><a class="header" href="#基本的なリテラル">基本的なリテラル</a></h2>
<h3 id="整数リテラルint-literal"><a class="header" href="#整数リテラルint-literal">整数リテラル(Int Literal)</a></h3>
<pre><code class="language-python">0, -0, 1, -1, 2, -2, 3, -3, ...
</code></pre>
<p>整数(Int)リテラルはInt型のオブジェクトです。</p>
<blockquote>
<p><strong>Note</strong>: <code>Int</code>型の部分型として<code>Nat</code>型が存在します。
0以上の数値は<code>Nat</code>型とも解釈できます。</p>
</blockquote>
<h3 id="有理数リテラルratio-literal"><a class="header" href="#有理数リテラルratio-literal">有理数リテラル(Ratio Literal)</a></h3>
<pre><code class="language-python">0.00, -0.0, 0.1, 400.104, ...
</code></pre>
<p>有理数を表すリテラルです。専ら小数として表現されますが、内部的には分数として扱われます。
<code>Ratio</code>リテラルで整数部分または小数部分が<code>0</code>のときは、その<code>0</code>を省略できます。</p>
<pre><code class="language-python">assert 1.0 == 1.
assert 0.5 == .5
</code></pre>
<blockquote>
<p><strong>Note</strong>: この<code>assert</code>という関数は、<code>1.0</code>と<code>1.</code>が等しいことを示すために使用しました。
以降のドキュメントでは、結果が等しいことを示すために<code>assert</code>を使用する場合があります。</p>
</blockquote>
<h3 id="文字列リテラルstr-literal"><a class="header" href="#文字列リテラルstr-literal">文字列リテラル(Str Literal)</a></h3>
<p>Unicodeで表現可能な文字列は、すべて使用できます。
Pythonとは違い、<code>'</code>ではクオーテーション(囲み)できません。文字列の中で<code>&quot;</code>を使いたいときは<code>\&quot;</code>としてください。</p>
<pre><code class="language-python">&quot;&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;111&quot;, &quot;1# 3f2-3*8$&quot;, &quot;こんにちは&quot;, &quot;السَّلَامُ عَلَيْكُمْ&quot;, ...
</code></pre>
<p><code>\{...}</code>によって文字列の中に式を埋めこめます。これを文字列補間(string interpolation)といいます。
<code>\{...}</code>自体を出力したい場合は<code>\\{...}</code>とします。</p>
<pre><code class="language-python">assert &quot;1 + 1 is 2&quot; == &quot;\{1} + \{1} is \{1+1}&quot;
</code></pre>
<h3 id="指数リテラルexponential-literal"><a class="header" href="#指数リテラルexponential-literal">指数リテラル(Exponential Literal)</a></h3>
<p>これは学術計算でよく使用される指数表記を表すリテラルです。<code>Ratio</code>型のインスタンスになります。
非常に大きな/小さな数を表すときに使用します。Pythonと表記法は同じです。</p>
<pre><code class="language-python">1e-34, 0.4e-10, 2.455+e5, 245e5, 25E5, ...
</code></pre>
<pre><code class="language-python">assert 1e-10 == 0.0000000001
</code></pre>
<h2 id="リテラルを組み合わせて生成するもの複合リテラル"><a class="header" href="#リテラルを組み合わせて生成するもの複合リテラル">リテラルを組み合わせて生成するもの(複合リテラル)</a></h2>
<p>これらのリテラルは、それぞれ単独で解説されているドキュメントがあるので、詳しくはそちらを参照してください。</p>
<h3 id="a-href10_arrayhtml配列リテラルarray-literala"><a class="header" href="#a-href10_arrayhtml配列リテラルarray-literala"><a href="./10_array.html">配列リテラル(Array Literal)</a></a></h3>
<pre><code class="language-python">[], [1], [1, 2, 3], [&quot;1&quot;, &quot;2&quot;,], ...
</code></pre>
<h3 id="a-href11_tuplehtml組リテラルtuple-literala"><a class="header" href="#a-href11_tuplehtml組リテラルtuple-literala"><a href="./11_tuple.html">組リテラル(Tuple Literal)</a></a></h3>
<pre><code class="language-python">(), (1, 2, 3), (1, &quot;hello&quot;, True), ...
</code></pre>
<h3 id="a-href12_dicthtml辞書リテラルdict-literala"><a class="header" href="#a-href12_dicthtml辞書リテラルdict-literala"><a href="./12_dict.html">辞書リテラル(Dict Literal)</a></a></h3>
<pre><code class="language-python">{:}, {&quot;one&quot;: 1}, {&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;1&quot;: 1, &quot;2&quot;: 2}, {1: &quot;1&quot;, 2: True, &quot;three&quot;: [1]}, ...
</code></pre>
<h3 id="a-href13_recordhtmlレコードリテラルrecord-literala"><a class="header" href="#a-href13_recordhtmlレコードリテラルrecord-literala"><a href="./13_record.html">レコードリテラル(Record Literal)</a></a></h3>
<pre><code class="language-python">{=}, {one = 1}, {one = 1; two = 2}, {.name = &quot;John&quot;; .age = 12}, {.name = Str; .age = Nat}, ...
</code></pre>
<h3 id="a-href14_sethtml集合リテラルset-literala"><a class="header" href="#a-href14_sethtml集合リテラルset-literala"><a href="./14_set.html">集合リテラル(Set Literal)</a></a></h3>
<pre><code class="language-python">{}, {1}, {1, 2, 3}, {&quot;1&quot;, &quot;2&quot;, &quot;1&quot;}, ...
</code></pre>
<p><code>Array</code>リテラルとの違いとして、<code>Set</code>では重複する要素が取り除かれます。</p>
<pre><code class="language-python">assert {1, 2, 1} == {1, 2}
</code></pre>
<h3 id="リテラルのように見えるがそうではないもの"><a class="header" href="#リテラルのように見えるがそうではないもの">リテラルのように見えるがそうではないもの</a></h3>
<h2 id="真偽値オブジェクトboolean-object"><a class="header" href="#真偽値オブジェクトboolean-object">真偽値オブジェクト(Boolean Object)</a></h2>
<pre><code class="language-python">True, False
</code></pre>
<p>真偽値オブジェクトはBool型の単なるシングルトン(ダブルトン?)です。
Pythonからの伝統により、<code>Bool</code>型は<code>Int</code>型ないし<code>Nat</code>型のサブタイプとなります。
すなわち、<code>True</code>は<code>1</code>、<code>False</code>は<code>0</code>と解釈できます。</p>
<pre><code class="language-python">assert True * 2 == 2
</code></pre>
<h3 id="noneオブジェクト"><a class="header" href="#noneオブジェクト">Noneオブジェクト</a></h3>
<pre><code class="language-python">None
</code></pre>
<p><code>NoneType</code>型のシングルトンです。</p>
<h2 id="範囲オブジェクトrange-object"><a class="header" href="#範囲オブジェクトrange-object">範囲オブジェクト(Range Object)</a></h2>
<pre><code class="language-python">assert 0..10 in 5
assert 0..&lt;10 notin 10
assert 0..9 == 0..&lt;10
assert (0..5).to_set() == {1, 2, 3, 4, 5}
assert &quot;a&quot; in &quot;a&quot;..&quot;z&quot;
</code></pre>
<p>Pythonの<code>range</code>とは異なり、IntだけでなくStrオブジェクトなども範囲として扱うことができます。</p>
<h2 id="浮動小数点数オブジェクトfloat-object"><a class="header" href="#浮動小数点数オブジェクトfloat-object">浮動小数点数オブジェクト(Float Object)</a></h2>
<pre><code class="language-python">assert 0.0f64 == 0
assert 0.0f32 == 0.0f64
</code></pre>
<p><code>Ratio</code>オブジェクトに<code>Float 64</code>の単位オブジェクトである<code>f64</code>を乗算したものです。
誤差が生じる可能性がありますが、<code>Ratio</code>よりも高速に計算できます。</p>
<h2 id="複素数オブジェクトcomplex-object"><a class="header" href="#複素数オブジェクトcomplex-object">複素数オブジェクト(Complex Object)</a></h2>
<pre><code class="language-python">1+2Im, 0.4-1.2Im, 0Im, Im
</code></pre>
<p><code>Complex</code>オブジェクトは、単に虚数単位オブジェクトである<code>Im</code>との演算の組み合わせで表します。</p>
<h2 id="-less-multiplication"><a class="header" href="#-less-multiplication">*-less multiplication</a></h2>
<p>Ergでは、解釈に紛れがない限り乗算を表す<code>*</code>を省略できます。
ただし、演算子の結合強度は<code>*</code>よりも強く設定されています。</p>
<pre><code class="language-python"># `assert (1*m) / (1*s) == 1*(m/s)`と同じ
assert 1m / 1s == 1 (m/s)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="変数"><a class="header" href="#変数">変数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/02_name.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/02_name.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>変数は代数の一種です。Ergにおける代数―紛れがなければ単に変数と呼ばれることもあります―とは、オブジェクトを名前付けしてコード中の別の場所から利用できるようにする機能を指します。</p>
<p>変数は以下のように定義します。
<code>n</code>の部分を変数名(または、識別子)、<code>=</code>を代入演算子、<code>1</code>の部分を代入値と呼びます。</p>
<pre><code class="language-python">n = 1
</code></pre>
<p>このようにして定義した<code>n</code>は、以降整数オブジェクトである<code>1</code>を示す変数として使用できます。このシステムを代入(または束縛)といいます。
いま<code>1</code>はオブジェクトであると述べました。オブジェクトが何であるかは後述しますが、今は代入できるもの、すなわち代入演算子(<code>=</code>など)の右側におけるものとしておきます。</p>
<p>変数の「型」を指定したい場合は以下のようにします。型とは、これも後述しますが、大まかにはオブジェクトの属する集合です。
ここでは<code>n</code>は自然数(<code>Nat</code>)型であると指定しています。</p>
<pre><code class="language-python">n: Nat = 1
</code></pre>
<p>他の言語とは違い、多重代入はできないので注意してください。</p>
<pre><code class="language-python compile_fail"># NG
l1 = l2 = [1, 2, 3] # SyntaxError: multiple assignment not allowed
</code></pre>
<pre><code class="language-python"># OK
l1 = [1, 2, 3]
l2 = l1.clone()
</code></pre>
<p>また、変数への再代入もできません。その代わりに使える機能、すなわち可変な状態を保持する機能については後述します。</p>
<pre><code class="language-python compile_fail">i = 1
i = i + 1 # AssignError: cannot assign twice
</code></pre>
<p>内側のスコープで同じ名前の変数を定義できますが、上に被せているだけで、値を破壊的に書き換えているわけではありません。外側のスコープに戻れば値も戻ります。
これはPythonの「文」のスコープとは違う挙動なので注意してください。
このような機能は一般にシャドーイングと言います。ただし他言語のシャドーイングとは違い同一スコープではシャドーイングできません。</p>
<pre><code class="language-python">x = 0
# x = 1 # AssignError: cannot assign twice
if x.is_zero(), do:
    x = 1 # 外側のxとは同名の別物になる
    assert x == 1
assert x == 0
</code></pre>
<p>以下は一見すると可能なように思えますが、やはりできません。これは技術的な制約ではなく、設計判断です。</p>
<pre><code class="language-python compile_fail">x = 0
if x.is_zero(), do:
    x = x + 1 # NameError: cannot define variables refer to variables with the same name
    assert x == 1
assert x == 0
</code></pre>
<h2 id="定数"><a class="header" href="#定数">定数</a></h2>
<p>定数も代数の一種です。識別子を大文字で始めると定数として扱われます。一度定義したら変わらないので、定数と呼ばれます。
<code>N</code>の部分を定数名(または、識別子)と呼びます。その他は変数と同じです。</p>
<pre><code class="language-python compile_fail">N = 0
if True, do:
    N = 1 # AssignError: constants cannot be shadowed
    pass()
</code></pre>
<p>定数は定義されたスコープ以降では不変になります。シャドーイングもできません。この性質から、定数はパターンマッチで使用できます。
パターンマッチについては後に説明します。</p>
<p>定数は、数学的定数、外部リソースに関する情報など不変な値に対して使用すると良いでしょう。
<a href="./type/01_type_system.html">型</a>以外のオブジェクトは、オールキャップス(全ての文字を大文字にするスタイル)にするのが一般的です。</p>
<pre><code class="language-python">PI = 3.141592653589793
URL = &quot;https://example.com&quot;
CHOICES = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<pre><code class="language-python">PI = 3.141592653589793
match! x:
    PI =&gt; print! &quot;π&quot;
    other =&gt; print! &quot;other&quot;
</code></pre>
<p>上のコードは<code>x</code>が<code>3.141592653589793</code>のとき<code>π</code>を出力します。<code>x</code>を他の数字に変えると、<code>other</code>を出力します。</p>
<p>定数には代入できないものがあります。可変オブジェクトなどです。詳しくは後述しますが、可変オブジェクトは内容を変更することができるオブジェクトです。
これは定数には定数式のみを代入できるという規則があるためです。定数式についても後述することとします。</p>
<pre><code class="language-python">X = 1 # OK
</code></pre>
<pre><code class="language-python compile_fail">X = !1 # TypeError: cannot define Int! object as a constant
</code></pre>
<h2 id="代数の削除"><a class="header" href="#代数の削除">代数の削除</a></h2>
<p><code>Del</code>関数を使うことで、代数を削除することが出来ます。その代数に依存している(その代数の値を直接参照している)他の代数もまとめて削除されます。</p>
<pre><code class="language-python">x = 1
y = 2
z = 3
f a = x + a

assert f(2) == 3
Del x # xを直接参照しているためfも削除される
Del y, Z

f(2) # NameError: f is not defined (deleted in line 6)
</code></pre>
<p>ただし、<code>Del</code>によって削除できるのはモジュール内で定義された代数のみです。<code>True</code>などの組み込み定数は削除できません。</p>
<pre><code class="language-python compile_fail">Del True # TypeError: cannot delete built-in constants
Del print! # TypeError: cannot delete built-in variables
</code></pre>
<h2 id="付録-代入と同値性"><a class="header" href="#付録-代入と同値性">付録: 代入と同値性</a></h2>
<p>注意として、<code>x = a</code>であるとき、<code>x == a</code>とは限らない。例としては<code>Float.NaN</code>がある。これはIEEE 754により定められた正式な浮動小数点数の仕様である。</p>
<pre><code class="language-python">x = Float.NaN
assert x != Float.NaN
assert x != x
</code></pre>
<p>その他、そもそも同値関係が定義されていないオブジェクトも存在する。</p>
<pre><code class="language-python compile_fail">f = x -&gt; x**2 + 2x + 1
g = x -&gt; (x + 1)**2
f == g # TypeError: cannot compare function objects

C = Class {i: Int}
D = Class {i: Int}
C == D # TypeError: cannot compare class objects
</code></pre>
<p>厳密に言うと<code>=</code>は右辺値をそのまま左辺の識別子に代入するわけではない。
関数オブジェクトやクラスオブジェクトの場合、オブジェクトに変数名の情報を与えるなどの「修飾」を行う。
ただし構造型の場合はその限りではない。</p>
<pre><code class="language-python">f x = x
print! f # &lt;function f&gt;
g x = x + 1
print! g # &lt;function g&gt;

C = Class {i: Int}
print! C # &lt;class C&gt;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="宣言"><a class="header" href="#宣言">宣言</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/03_declaration.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/03_declaration.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>宣言は、使用する変数の型を指定する構文です。
宣言はコード中のどこでも可能ですが、宣言しただけでその変数を参照することはできません。必ず初期化する必要があります。
代入後の宣言では、代入されたオブジェクトと型が適合するかをチェック可能です。</p>
<pre><code class="language-python">i: Int
# i: Int = 2のように代入と同時に宣言できる
i = 2
i: Num
i: Nat
i: -2..2
i: {2}
</code></pre>
<p>代入後の宣言は<code>assert</code>による型チェックと似ていますが、コンパイル時にチェックされるという特徴があります。
実行時の<code>assert</code>による型チェックは「〇〇型かもしれない」で検査が可能ですが、コンパイル時の<code>:</code>による型チェックは厳密です。
「〇〇型である」ことが確定していなくては検査を通らず、エラーとなります。</p>
<pre><code class="language-python">i = (-1..10).sample!()
assert i in Nat # これは通る可能性がある
i: Int # これは通る
i: Nat # これは通らない(-1はNatの要素ではないため)
</code></pre>
<p>関数は以下の2種類の方法で宣言が可能です。</p>
<pre><code class="language-python checker_ignore">f: (x: Int, y: Int) -&gt; Int
f: (Int, Int) -&gt; Int
</code></pre>
<p>引数名を明示して宣言した場合、定義時に名前が違うと型エラーとなります。引数名の任意性を与えたい場合は2番目の方法で宣言すると良いでしょう。その場合、型検査で見られるのはメソッド名とその型のみです。キーワード指定による呼び出しはできなくなります。</p>
<pre><code class="language-python compile_fail">T = Trait {
    .f = (x: Int, y: Int): Int
}

C = Class()
C|&lt;: T|.
    f(a: Int, b: Int): Int = ... # TypeError: `.f` must be type of `(x: Int, y: Int) -&gt; Int`, not `(a: Int, b: Int) -&gt; Int`
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="関数"><a class="header" href="#関数">関数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/04_function.md&amp;commit_hash=96b113c47ec6ca7ad91a6b486d55758de00d557d"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/04_function.md%26commit_hash%3D96b113c47ec6ca7ad91a6b486d55758de00d557d" alt="badge" /></a></p>
<p>関数は「引数」を受け取ってそれを加工し、「戻り値」として返すブロックです。以下のように定義します。</p>
<pre><code class="language-python">add x, y = x + y
# or
add(x, y) = x + y
</code></pre>
<p>関数定義の際に指定される引数は、詳しくは仮引数(parameter)と呼ばれるものです。
これに対し、関数呼び出しの際に渡される引数は、実引数(argument)と呼ばれるものです。
<code>add</code>は<code>x</code>と<code>y</code>を仮引数として受け取り、それを足したもの、<code>x + y</code>を返す関数です。
定義した関数は、以下のようにして呼び出し(適用)ができます。</p>
<pre><code class="language-python">add 1, 2
# or
add(1, 2)
</code></pre>
<h2 id="コロン適用スタイル"><a class="header" href="#コロン適用スタイル">コロン適用スタイル</a></h2>
<p>関数は<code>f x, y, ...</code>のように呼び出しますが、<strong>実引数</strong> が多く一行では長くなりすぎる場合は<code>:</code>(コロン)を使った適用も可能です。</p>
<pre><code class="language-python checker_ignore">f some_long_name_variable_1 + some_long_name_variable_2, some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python checker_ignore">f some_long_name_variable_1 + some_long_name_variable_2:
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<p>上の2つのコードは同じ意味です。このスタイルは<code>if</code>関数などを使用するときにも便利です。</p>
<pre><code class="language-python">result = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
</code></pre>
<p>この場合、<code>:</code>の後はコメント以外のコードを書いてはならず、必ず改行しなくてはなりません。
また、関数の直後に<code>:</code>を使うことはできません。これができるのは<code>do</code>と<code>do!</code>のみです。</p>
<pre><code class="language-python compile_fail"># NG
f:
    x
    y
</code></pre>
<pre><code class="language-python checker_ignore"># Ok
f(
    x,
    y
)
</code></pre>
<h2 id="キーワード引数"><a class="header" href="#キーワード引数">キーワード引数</a></h2>
<p>引数の数が多い関数を定義されていると、引数を渡す順番を間違える危険性があります。
そのような場合はキーワード引数を使用して呼び出すと安全です。</p>
<pre><code class="language-python checker_ignore">f x, y, z, w, v, u: Int = ...
</code></pre>
<p>上に定義された関数は、引数が多く、分かりにくい並びをしています。
このような関数は作るべきではありませんが、他人の書いたコードを使うときにこのようなコードにあたってしまうかもしれません。
そこで、キーワード引数を使います。キーワード引数は並びよりも名前が優先されるため、順番を間違えていても名前から正しい引数に値が渡されます。</p>
<pre><code class="language-python">f u := 6, v := 5, w := 4, x := 1, y := 2, z := 3
</code></pre>
<h2 id="デフォルト引数"><a class="header" href="#デフォルト引数">デフォルト引数</a></h2>
<p>ある引数が大抵の場合決まりきっており省略できるようにしたい場合、デフォルト引数を使うと良いでしょう。</p>
<p>デフォルト引数は<code>:=</code>(default-assign operator)で指定します。<code>base</code>が指定されなかったら<code>math.E</code>を<code>base</code>に代入します。</p>
<pre><code class="language-python">math_log x: Ratio, base := math.E = ...

assert math_log(100, 10) == 2
assert math_log(100) == math_log(100, math.E)
</code></pre>
<p>引数を指定しないことと<code>None</code>を代入することは区別されるので注意してください。</p>
<pre><code class="language-python">p! x := 0 = print! x
p!(2) # 2
p!() # 0
p!(None) # None
</code></pre>
<p>型指定、パターンと併用することもできます。</p>
<pre><code class="language-python">math_log x, base: Ratio := math.E = ...
f [x, y] := [1, 2] = ...
</code></pre>
<p>しかしデフォルト引数内では、後述するプロシージャを呼び出したり、可変オブジェクトを代入したりすることができません。</p>
<pre><code class="language-python compile_fail">f x := p! 1 = ... # NG
</code></pre>
<p>また、定義したばかりの引数はデフォルト引数に渡す値として使えません。</p>
<pre><code class="language-python compile_fail">f x := 1, y := x = ... # NG
</code></pre>
<h2 id="可変長引数"><a class="header" href="#可変長引数">可変長引数</a></h2>
<p>引数をログ(記録)として出力する<code>log</code>関数は、任意の個数の引数を受け取ることができます。</p>
<pre><code class="language-python">log &quot;Hello&quot;, &quot;World&quot;, &quot;!&quot; # Hello World !
</code></pre>
<p>このような関数を定義したいときは、引数に<code>...</code>を付けます。このようにすると、引数を可変長の配列として受け取ることができます。</p>
<pre><code class="language-python">f x: ...Int =
    for x, i -&gt;
        log i

# x == [1, 2, 3, 4, 5]
f 1, 2, 3, 4, 5
</code></pre>
<h2 id="複数パターンによる関数定義"><a class="header" href="#複数パターンによる関数定義">複数パターンによる関数定義</a></h2>
<pre><code class="language-python">fib n: Nat =
    match n:
        0 -&gt; 0
        1 -&gt; 1
        n -&gt; fib(n - 1) + fib(n - 2)
</code></pre>
<p>上のような定義直下に<code>match</code>が現れる関数は、下のように書き直すことができます。</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
fib(n: Nat): Nat = fib(n - 1) + fib(n - 2)
</code></pre>
<p>複数のパターンによる関数定義は、いわゆるオーバーロード(多重定義)ではないことに注意してください。1つの関数はあくまで単一の型のみを持ちます。上の例では、<code>n</code>は<code>0</code>や<code>1</code>と同じ型である必要があります。また、<code>match</code>と同じくパターンの照合は上から順に行われます。</p>
<p>違うクラスのインスタンスが混在する場合は、最後の定義で関数引数がOr型であることを明示しなくてはなりません。</p>
<pre><code class="language-python">f &quot;aa&quot; = ...
f 1 = ...
# `f x = ...` is invalid
f x: Int or Str = ...
</code></pre>
<p>また、<code>match</code>と同じく網羅性がなくてはなりません。</p>
<pre><code class="language-python compile_fail">fib 0 = 0
fib 1 = 1
# PatternError: pattern of fib's parameter is not exhaustive
</code></pre>
<p>しかし、上のような場合でも、後述する<a href="./type/12_refinement.html">篩型</a>を使って明示的に型指定することで、網羅性を獲得できます。</p>
<pre><code class="language-python">fib: 0..1 -&gt; 0..1
fib 0 = 0
fib 1 = 1
# OK
</code></pre>
<h2 id="再帰関数"><a class="header" href="#再帰関数">再帰関数</a></h2>
<p>再帰関数は自身を定義に含む関数です。</p>
<p>簡単な例として階乗の計算を行う関数<code>factorial</code>を定義してみます。階乗とは、「それ以下の正の数をすべてかける」計算です。
5の階乗は<code>5*4*3*2*1 == 120</code>となります。</p>
<pre><code class="language-python">factorial 0 = 1
factorial 1 = 1
factorial(n: Nat): Nat = n * factorial(n - 1)
</code></pre>
<p>まず階乗の定義から、0と1の階乗はどちらも1です。
順に考えて、2の階乗は<code>2*1 == 2</code>、3の階乗は<code>3*2*1 == 6</code>、4の階乗は<code>4*3*2*1 == 24</code>となります。
ここでよく見ると、ある数nの階乗はその前の数n-1の階乗にnをかけた数となることがわかります。
これをコードに落とし込むと、<code>n * factorial(n - 1)</code>となるわけです。
<code>factorial</code>の定義に自身が含まれているので、<code>factorial</code>は再帰関数です。</p>
<p>注意として、型指定を付けなかった場合はこのように推論されます。</p>
<pre><code class="language-python">factorial: |T &lt;: Sub(Int, T) and Mul(Int, Int) and Eq(Int)| T -&gt; Int
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial(n - 1)
</code></pre>
<p>しかし例え推論が出来たとしても、再帰関数には型を明示的に指定しておくべきです。上の例では、<code>factorial(-1)</code>のようなコードは有効ですが、</p>
<pre><code class="language-python">factorial(-1) == -1 * factorial(-2) == -1 * -2 * factorial(-3) == ...
</code></pre>
<p>となって、この計算は停止しません。再帰関数は慎重に値の範囲を定義しないと無限ループに陥ってしまう可能性があります。
型指定は想定しない値の受け入れを防ぐのにも役立つというわけです。</p>
<h2 id="高階関数"><a class="header" href="#高階関数">高階関数</a></h2>
<p>高階関数は引数や返り値に関数を取る関数のことを指します。
例えば引数に関数を取る高階関数は以下のように記述できます。</p>
<pre><code class="language-python">arg_f = i -&gt; log i
higher_f(x: (Int -&gt; NoneType)) = x 10
higher_f arg_f # 10
</code></pre>
<p>もちろん、関数を返り値にすることもできます。</p>
<pre><code class="language-python">add(x): (Int -&gt; Int) = y -&gt; x + y
add_ten = add(10) # y -&gt; 10 + y
add_hundred = add(100) # y -&gt; 100 + y
assert add_ten(1) == 11
assert add_hundred(1) == 101
</code></pre>
<p>このようにして関数を引数や返り値にとることで、より柔軟な表現を関数で定義することができます。</p>
<h2 id="コンパイル時関数"><a class="header" href="#コンパイル時関数">コンパイル時関数</a></h2>
<p>関数名を大文字で始めるとコンパイル時関数となります。ユーザー定義のコンパイル時関数は、引数がすべて定数で、かつ型を明示する必要があります。
コンパイル関数ができることは限られています。コンパイル時関数内で使えるのは定数式のみ、すなわち、いくつかの演算子(四則演算や比較演算、型構築演算など)とコンパイル時関数のみです。代入する引数も定数式である必要があります。
そのかわり、計算をコンパイル時に行うことができるというメリットがあります。</p>
<pre><code class="language-python">Add(X, Y: Nat): Nat = X + Y
assert Add(1, 2) == 3

Factorial 0 = 1
Factorial(X: Nat): Nat = X * Factorial(X - 1)
assert Factorial(10) == 3628800

math = import &quot;math&quot;
Sin X = math.sin X # ConstantError: this function is not computable at compile time
</code></pre>
<p>コンパイル時関数は多相型の定義などでもよく使われます。</p>
<pre><code class="language-python">Option T: Type = T or NoneType
Option: Type -&gt; Type
</code></pre>
<h2 id="付録1-関数の比較"><a class="header" href="#付録1-関数の比較">付録1: 関数の比較</a></h2>
<p>Ergでは、関数に<code>==</code>が定義されていません。それは関数の構造的な同値性判定アルゴリズムが一般には存在しないためです。</p>
<pre><code class="language-python">f = x: Int -&gt; (x + 1)**2
g = x: Int -&gt; x**2 + 2x + 1

assert f == g # TypeError: cannot compare functions
</code></pre>
<p><code>f</code>と<code>g</code>は常に同じ結果を返しますが、その判定を行うのは至難の業です。コンパイラに代数学を教え込む必要があります。
そのため、Ergは関数の比較をまるごと諦めており、<code>(x -&gt; x) == (x -&gt; x)</code>もコンパイルエラーになります。これはPythonとは違った仕様なので注意する必要があります。</p>
<pre><code class="language-python"># Pythonの奇妙な例
f = lambda x: x
assert f == f # True
assert (lambda x: x) != (lambda x: x) # Passed
</code></pre>
<h2 id="付録2-の補完"><a class="header" href="#付録2-の補完">付録2: ()の補完</a></h2>
<pre><code class="language-python">f x: Object = ...
# これは以下のように補完される
f(x: Object) = ...

f a
# これは以下のように補完される
f(a)

f a, b # TypeError: f() takes 1 positional argument but 2 were given
f(a, b) # TypeError: f() takes 1 positional argument but 2 were given
f((a, b)) # OK
</code></pre>
<p>関数型<code>T -&gt; U</code>は実際のところ、<code>(T,) -&gt; U</code>の糖衣構文です。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="組み込み関数"><a class="header" href="#組み込み関数">組み込み関数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/05_builtin_funcs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/05_builtin_funcs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="if"><a class="header" href="#if">if</a></h2>
<p><code>if</code>は条件に応じて処理を変える関数です。</p>
<pre><code class="language-python">result: Option Int = if! Bool.sample!(), do:
    log &quot;True was chosen&quot;
    1
print! result # None (または1)
</code></pre>
<p><code>.sample!()</code>は集合の値をランダムに返します。もし戻り値が真ならば、<code>print! &quot;True&quot;</code>が実行されます。
条件が偽であった際の処理も指定できます。２つ目のdoブロックはelseブロックと呼ばれます。</p>
<pre><code class="language-python">result: Nat = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
print! result # 1 (または0)
</code></pre>
<p>処理が1行ならば、インデントを省略できます。</p>
<pre><code class="language-python">result = if Bool.sample!():
    do 1
    do 0
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>繰り返し行う処理を書くときは<code>for</code>が使えます。</p>
<pre><code class="language-python">match_s(ss: Iterator(Str), pat: Pattern): Option Str =
    for ss, s -&gt;
        if pat.match(s).is_some():
            break s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="演算子"><a class="header" href="#演算子">演算子</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/06_operator.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/06_operator.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>演算子(オペレーター)は、演算を表す記号です。被演算子(オペランド)は演算子の(左)右にあるもので、Ergでは専らオブジェクトです。</p>
<p>演算子は関数の一種であり、したがってそれ自体も第一級オブジェクトで変数に束縛できます。束縛の際は``で囲む必要があります。
<code>+</code>(と<code>-</code>)については、単項演算子と二項演算子の両方が存在するため、一意化するために<code>_+_</code>(二項演算)/<code>+_</code>(単項演算)のどちらかを指定する必要があります。</p>
<pre><code class="language-python compile_fail">add = `+` # SyntaxError: specify `_+_` or `+_`
</code></pre>
<pre><code class="language-python">add = `_+_`
assert f(1, 2) == 3
assert f(&quot;a&quot;, &quot;b&quot;) == &quot;ab&quot;

mul = `*` # OK, this is binary only
assert mul(1, 2) == 2
</code></pre>
<p>ただし、特殊形式と呼ばれる一部の演算子は束縛できないことに注意してください。</p>
<pre><code class="language-python compile_fail">def = `=` # SyntaxError: cannot bind `=` operator, this is a special form
# NG: def x, 1
function = `-&gt;` # SyntaxError: cannot bind `-&gt;` operator, this is a special form
# NG: function x, x + 1
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="副作用とプロシージャ"><a class="header" href="#副作用とプロシージャ">副作用とプロシージャ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/07_side_effect.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/07_side_effect.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>これまで<code>print!</code>の<code>!</code>の意味を説明せずにいましたが、いよいよその意味が明かされます。この!は、ズバリこのオブジェクトが「副作用」のある「プロシージャ」であることを示しています。プロシージャは関数に「副作用」という効果を与えたものです。</p>
<pre><code class="language-python compile_fail">f x = print! x # EffectError: functions cannot be assigned objects with side effects
# hint: change the name to 'f!'
</code></pre>
<p>上のコードはコンパイルエラーになります。関数中でプロシージャを使用しているからです。このような場合は、プロシージャとして定義しなくてはなりません。</p>
<pre><code class="language-python">p! x = print! x
</code></pre>
<p><code>p!</code>, <code>q!</code>, ...は、プロシージャを表すための典型的な変数名です。
このようにして定義したプロシージャもまた関数内では使用できないため、副作用は完全に隔離されるわけです。</p>
<h2 id="メソッド"><a class="header" href="#メソッド">メソッド</a></h2>
<p>関数とプロシージャにはそれぞれメソッドが存在します。関数メソッドは<code>self</code>の不変参照のみを取れ、プロシージャルメソッドは<code>self</code>の可変参照を取れます。
<code>self</code>は特殊な引数で、メソッドの文脈では呼び出したオブジェクト自身を指します。参照の<code>self</code>は他のいかなる変数にも代入できません。</p>
<pre><code class="language-python">C.
    method ref self =
        x = self # OwnershipError: cannot move out 'self'
        x
</code></pre>
<p>メソッドは<code>self</code>の所有権を奪うこともできます。そのメソッドの定義では<code>ref</code>または<code>ref!</code>を外します。</p>
<pre><code class="language-python compile_fail">n = 1
s = n.into(Str) # 所有権がnから移動し、s = '1'になる
n # ValueError: n was moved by .into (line 2)
</code></pre>
<p>可変参照を持てるのは常に1つのプロシージャルメソッドのみです。さらに可変参照が取られている間は元のオブジェクトから参照を取れなくなります。その意味で<code>ref!</code>は<code>self</code>に副作用を引き起こします。</p>
<p>ただし、可変参照から(不変/可変)参照の生成はできることに注意してください。これによって、プロシージャルメソッド中で再帰したり<code>self</code>を<code>print!</code>できたりします。</p>
<pre><code class="language-python">T -&gt; T # OK (移動)
T -&gt; Ref T # OK
T =&gt; Ref! T # OK (一度のみ)
Ref T -&gt; T # NG
Ref T -&gt; Ref T # OK
Ref T =&gt; Ref! T # NG
Ref! T -&gt; T # NG
Ref! T -&gt; Ref T # OK
Ref! T =&gt; Ref! T # OK
</code></pre>
<h2 id="付録-副作用の厳密な定義"><a class="header" href="#付録-副作用の厳密な定義">付録: 副作用の厳密な定義</a></h2>
<p>コードに副作用があるかないかのルールはすぐに理解できるものではありません。
理解できるようになるまでは、とりあえず関数として定義してエラーが出ればプロシージャとするコンパイラ任せのスタイルを推奨します。
しかし、言語の厳密な仕様を把握しておきたい人のために、以下ではもう少し詳しく副作用について説明します。</p>
<p>まず、Ergにおける副作用に関して、戻り値の同値性は関係がないということに注意してください。
任意の<code>x</code>に対して<code>p!(x) == p!(x)</code>となるプロシージャが存在します(常に<code>None</code>を返すなど)し、<code>f(x) != f(x)</code>となる関数も存在します。</p>
<p>前者の例は<code>print!</code>で、後者の例は以下の関数です。</p>
<pre><code class="language-python">nan _ = Float.NaN
assert nan(1) != nan(1)
</code></pre>
<p>また、クラスや関数のように同値判定自体ができないオブジェクトも存在します。</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}
assert T == U

C = Class {i = Int}
D = Class {i = Int}
assert C == D # TypeError: cannot compare classes
</code></pre>
<p>本題に戻ります。Ergにおける「副作用」の正確な定義は、</p>
<ul>
<li>外部の可変な情報にアクセスすること</li>
</ul>
<p>です。外部とは、一般には外側のスコープを指します。Ergがタッチできないコンピューターリソースや、実行前/後の情報については「外部」に含まれません。「アクセス」は書き込みだけでなく読み込みも含めます。</p>
<p>例として<code>print!</code>プロシージャについて考えます。<code>print!</code>は一見何の変数も書き換えていないように見えます。しかし、もしこれが関数だったとすると、例えばこのようなコードで外側変数を書き換えられます。</p>
<pre><code class="language-python">camera = import &quot;some_camera_module&quot;
ocr = import &quot;some_ocr_module&quot;

n = 0
_ =
    f x = print x # 仮にprintを関数として使えたとする
    f(3.141592)
cam = camera.new() # カメラはPCのディスプレイの方向を向く
image = cam.shot!()
n = ocr.read_num(image) # n = 3.141592
</code></pre>
<p><code>camera</code>モジュールはあるカメラ製品のAPIを提供する外部のライブラリ、<code>ocr</code>はOCR(光学文字認識)のためのライブラリとします。
直接の副作用は<code>cam.shot!()</code>によって引き起こされていますが、明らかにその情報は<code>f</code>から漏洩しています。よって、<code>print!</code>は性質上関数とはなれません。</p>
<p>とはいえ、関数中で値を一時的に確認するとき、そのためだけに関連する関数まで<code>!</code>を付けたくない場合もあるでしょう。その際は<code>log</code>関数が使えます。
<code>log</code>はコード全体の実行後に値を表示します。これにより、副作用は伝搬されません。</p>
<pre><code class="language-python">log &quot;これは実行後にプリントされます&quot;
print! &quot;これはすぐにプリントされます&quot;
# これはすぐにプリントされる
# これは実行後にプリントされる
</code></pre>
<p>つまり、プログラムへのフィードバックがない、言い換えればいかなる外部オブジェクトもその情報を使うことが出来ないならば、情報の「漏洩」自体は許される場合があります。「伝搬」されなければよいのです。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="プロシージャ"><a class="header" href="#プロシージャ">プロシージャ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/08_procedure.md&amp;commit_hash=96b113c47ec6ca7ad91a6b486d55758de00d557d"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/08_procedure.md%26commit_hash%3D96b113c47ec6ca7ad91a6b486d55758de00d557d" alt="badge" /></a></p>
<p>プロシージャは<a href="/07_side_effect.html">副作用</a>を許容する関数を意味します。
基本的な定義や利用方法は<a href="/04_function.html">関数</a>を参照してください。
関数名に対して<code>!</code>をつけることで定義することができます。</p>
<pre><code class="language-python">proc!(x: Int!, y: Int!) =
    for! 0..x, i =&gt;
        for 0..y, j =&gt;
            print! i, j
</code></pre>
<p>プロシージャは可変オブジェクトを取り扱う際に必要となります。
ですが、可変オブジェクトを引数に持つときやプロシージャの定義するだけの場合はプロシージャであるとは限りません。</p>
<pre><code class="language-python">peek_str s: Str! = log s

make_proc(x!: (Int =&gt; Int)): (Int =&gt; Int) = y =&gt; x! y
p! = make_proc(x =&gt; x)
print! p! 1 # 1
</code></pre>
<p>またプロシージャと関数は<code>proc :&gt; func</code>の関係にあります。
そのため、プロシージャ内で関数ブロックを定義することもできます。
しかし、逆はできないので注意をしてください。</p>
<pre><code class="language-python">proc!(x: Int!) = y -&gt; log x, y # OK
func(x: Int) = y =&gt; print! x, y # NG
</code></pre>
<h2 id="バインド"><a class="header" href="#バインド">バインド</a></h2>
<p>プロシージャはスコープ外の可変変数を操作することができます。</p>
<pre><code class="language-python">x = !0
proc!() =
    x.inc!()

proc!()
assert x == 1
</code></pre>
<p>このとき、<code>proc!</code>は以下のような型を持ちます。</p>
<pre><code class="language-python">proc!: {|x: Int!|}() =&gt; ()
</code></pre>
<p><code>{|x: Int!|}</code>の部分はバインド列と呼ばれ、そのプロシージャが操作する変数とその型を表します。
バインド列は自動で導出されるため、明示的に書く必要はありません。</p>
<p>注意として、通常のプロシージャは予め決められた外部変数のみを操作することができます。これはつまり、引数に渡された変数を書き換えることはできないということです。
そのようなことがしたい場合は、プロシージャルメソッドを使う必要があります。プロシージャルメソッドは、<code>self</code>を書き換えることができます。</p>
<pre><code class="language-python">C! N = Class {arr = [Int; N]!}
C!.
    new() = Self!(0)::__new__ {arr = ![]}
C!(N).
    # push!: {|self: C!(N) ~&gt; C!(N+1)|}(self: RefMut(C!(N)), x: Int) =&gt; NoneType
    push! ref! self, x = self.arr.push!(x)
    # pop!: {|self: C!(N) ~&gt; C!(N-1)|}(self: RefMut(C!(N))) =&gt; Int
    pop! ref! self = self.arr.pop!()

c = C!.new()
c.push!(1)
assert c.pop!() == 1
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="組み込みプロシージャ"><a class="header" href="#組み込みプロシージャ">組み込みプロシージャ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/09_builtin_procs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/09_builtin_procs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="id"><a class="header" href="#id">id!</a></h2>
<p>オブジェクトのユニークな識別番号を返します。
純粋なErgの意味論の中では同一の構造を持つオブジェクトの間に差異を見出す事はできませんが、実際のところ、オブジェクトはメモリ上の位置が異なります。<code>id!</code>はこの位置を表す数値を返します。</p>
<pre><code class="language-python"></code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="配列"><a class="header" href="#配列">配列</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/10_array.md&amp;commit_hash=603abbd5fa3f8baffe0d614758e1a554705e6732"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/10_array.md%26commit_hash%3D603abbd5fa3f8baffe0d614758e1a554705e6732" alt="badge" /></a></p>
<p>配列はもっとも基本的な <strong>コレクション(集約)</strong> です。
コレクションとは、内部にオブジェクトを複数保持できるオブジェクトのことです。</p>
<pre><code class="language-python">a = [1, 2, 3]
a: [Int; 3] # 型指定: セミコロンの後の数字は要素数
# 要素数がわからない場合は省略できる
a: [Int]

mut_a = [!1, !2, !3]
mut_a[0].inc!()
assert mut_a == [2, 2, 3]
</code></pre>
<p>配列には、原則として違う型のオブジェクトを入れることはできません。</p>
<pre><code class="language-python compile_fail">[1, &quot;a&quot;] # TypeError: 1st element is Int, but 2nd element is Str
</code></pre>
<p>しかし、このように要素の型を明示的に指定すると制限を回避できます。</p>
<pre><code class="language-python">[1: Int or Str, &quot;a&quot;]
</code></pre>
<blockquote>
<p>しかしこのような場合、基本的には後述する <strong>タプル</strong> を使うべきです。</p>
<pre><code class="language-python">(1, &quot;a&quot;)
</code></pre>
</blockquote>
<h2 id="スライス"><a class="header" href="#スライス">スライス</a></h2>
<p>配列は、複数の値をまとめて取り出すこともできます。これをスライスと呼びます。</p>
<pre><code class="language-python">l = [1, 2, 3, 4]
# Pythonのl[1:3]に相当
assert l[1..&lt;3] == [2, 3]
assert l[1..2] == [2, 3]
# l[1]と同じ
assert l[1..1] == [2]
# Pythonのl[::2]に相当
assert l[..].step(2) == [2, 4]
</code></pre>
<p>スライスで得られるオブジェクトは配列の(不変)参照です。</p>
<pre><code class="language-python">print! Typeof l[1..2] # Ref [Int; 4]
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="タプル"><a class="header" href="#タプル">タプル</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/11_tuple.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/11_tuple.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>タプルは配列と似ていますが、違う型のオブジェクトを保持できます。
このようなコレクションを非等質なコレクションと呼びます。対して等質なコレクションには配列、セットなどがあります。</p>
<pre><code class="language-python">t = (1, True, &quot;a&quot;)
(i, b, s) = t
assert(i == 1 and b == True and s == &quot;a&quot;)
</code></pre>
<p>タプル<code>t</code>は<code>t.n</code>の形式でn番目の要素を取り出すことができます。Pythonと違い、<code>t[n]</code>ではないことに注意してください。
これは、タプル要素のアクセスはメソッド(配列の<code>[]</code>はメソッドです)というより属性に近い(コンパイル時に要素の存在がチェックされる、nによって型が変わりうる)ためです。</p>
<pre><code class="language-python">assert t.0 == 1
assert t.1 == True
assert t.2 == &quot;a&quot;
</code></pre>
<p>括弧<code>()</code>はネストしないとき省略可能です。</p>
<pre><code class="language-python">t = 1, True, &quot;a&quot;
i, b, s = t
</code></pre>
<p>タプルは違う型のオブジェクトを保持できますが、そのかわり配列のようなイテレーションができなくなります。</p>
<pre><code class="language-python compile_fail">t: ({1}, {2}, {3}) = (1, 2, 3)
(1, 2, 3).iter().map(x -&gt; x + 1) # TypeError: type ({1}, {2}, {3}) has no method `.iter()`
</code></pre>
<pre><code class="language-python"># すべて同じ型の場合配列と同じように`(T; n)`で表せるが、これでもイテレーションは出来ない
t: (Int; 3) = (1, 2, 3)
assert (Int; 3) == (Int, Int, Int)
</code></pre>
<p>ただし、非等質なコレクション(タプルなど)はアップキャスト、Intersectionなどによって等質なコレクション(配列など)に変換できます。
これを等質化といいます。</p>
<pre><code class="language-python">homogenize rule

* (X, Y, Z, ...) can be [T; N] if T :&gt; X, T :&gt; Y, T :&gt; Z, ...
</code></pre>
<pre><code class="language-python">t: (Int, Bool, Str) = (1, True, &quot;a&quot;) # 非等質
a: [Int or Bool or Str; 3] = [1, True, &quot;a&quot;] # 等質
_a: [Show; 3] = [1, True, &quot;a&quot;] # 等質
_a.iter().map(x -&gt; log x) # OK
t.try_into([Show; 3])?.iter().map(x -&gt; log x) # OK
</code></pre>
<h2 id="ユニット"><a class="header" href="#ユニット">ユニット</a></h2>
<p>要素が0個のタプルはユニットと言います。ユニットは値ですが、自身の型そのものも指します。</p>
<pre><code class="language-python">unit = ()
(): ()
</code></pre>
<p>ユニットはすべてのタプルのスーパークラスです。</p>
<pre><code class="language-python">() :&gt; (Int; 0)
() :&gt; (Str; 0)
() :&gt; (Int, Str)
...
</code></pre>
<p>このオブジェクトの使いみちは、引数、戻り値がないプロシージャなどです。Ergのサブルーチンは、必ず引数と戻り値を持つ必要があります。しかしプロシージャなどの場合、副作用を起こすだけで意味のある引数・戻り値がない場合もあります。その際に「意味のない、形式上の値」としてユニットを使うわけです。</p>
<pre><code class="language-python">p!() =
    # `print!`は意味のある値を返さない
    print! &quot;Hello, world!&quot;
p!: () =&gt; () # 引数部分は構文の一部でありタプルではない
</code></pre>
<p>ただしPythonはこのようなときユニットではなく<code>None</code>を使う傾向があります。
Ergでの使い分けとしては、プロシージャなどではじめから意味のある値を返さないことが確定しているときは<code>()</code>、要素の取得のように操作が失敗して何も得られなかったときは<code>None</code>を返してください。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="辞書"><a class="header" href="#辞書">辞書</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/12_dict.md&amp;commit_hash=e86a0987ed14a4de5da770372d4f3729c7691503"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/12_dict.md%26commit_hash%3De86a0987ed14a4de5da770372d4f3729c7691503" alt="badge" /></a></p>
<p>Dictはキーと値のペアを持つコレクションです。</p>
<pre><code class="language-python">ids = {&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301}
assert ids[&quot;Alice&quot;] == 145
</code></pre>
<p>キーはHashableであるならば文字列でなくても構いません。</p>
<pre><code class="language-python"># rangeオブジェクトをキーにするのは非推奨(スライスと混同される)
r = {1..3: &quot;1~3&quot;, 4..6: &quot;4~6&quot;, 7..9: &quot;7~9&quot;}
assert r[1..3] == &quot;1~3&quot;
l = {[]: &quot;empty&quot;, [1]: &quot;1&quot;}
assert l[[]] == &quot;empty&quot;
l = {0.0: &quot;a&quot;, 1.0: &quot;b&quot;} # TypeError: Float is not Hashable
</code></pre>
<p>Dictに順番は関係ありません。また、重複する要素を持つことも出来ません。この点でDictは<a href="./14_set.html">Set</a>と似ています。
Dictは値付きのSetと言うこともできるでしょう。</p>
<pre><code class="language-python compile_fail">{&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301} == {&quot;Alice&quot;: 145, &quot;Charlie&quot;: 301, &quot;Bob&quot;: 214}
</code></pre>
<p>DictリテラルからDictを生成する場合、キーの重複がないかチェックされます。
重複がある場合コンパイルエラーとなりますが、自明でない場合もあり、その場合は後に登録された方が残ります(左から順番に登録されます)。</p>
<pre><code class="language-python compile_fail">{&quot;Alice&quot;: 145, &quot;Alice&quot;: 1} # KeyError: Duplicate key &quot;Alice&quot;
x = f(...) # x == 2
{2x+2: 1, 2(x+1): 2} # {6: 2}
</code></pre>
<p>空のDictは<code>{:}</code>で生成します。<code>{}</code>は空の配列を表すことに注意してください。</p>
<pre><code class="language-python">mut_dict = !{:}
mut_dict.insert! &quot;Alice&quot;, 145
mut_dict.insert! &quot;Bob&quot;, 214
assert mut_dict[&quot;Alice&quot;] == 145
</code></pre>
<h2 id="非等質な辞書"><a class="header" href="#非等質な辞書">非等質な辞書</a></h2>
<p>キー・値の型は単一でなくてもよく、そのような辞書を <strong>非等質な辞書(heterogenous dict)</strong> といいます。</p>
<pre><code class="language-python">d: {Str: Int, Int: Str} = {&quot;a&quot;: 1, 1: &quot;a&quot;}
assert d[&quot;a&quot;] == 1
assert d[1] == &quot;a&quot;
</code></pre>
<p>しかし、違う型のキーに同じ型の値、または同じ型のキーに違う型の値をあてることはできません。
このような場合は代わりにOr型(Union)を使います。</p>
<pre><code class="language-python">invalid1 = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
invalid2 = {1: &quot;a&quot;, 2: 2}

# Ergの型推論はOr型を推論しないため、型指定が必要となる
valid1: {Int or Str: Str} = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
valid2: {Int: Int or Str} = {1: &quot;a&quot;, 2: 2}
</code></pre>
<h2 id="型表示との併用"><a class="header" href="#型表示との併用">型表示との併用</a></h2>
<p><code>{}</code>の中での<code>x: y</code>という形式は、辞書のキーと値のペアとして優先的に解釈されます。
型表示として使いたい場合は、<code>()</code>で囲む必要があります。</p>
<pre><code class="language-python">x = &quot;a&quot;
{(x: Str): 1}
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="レコード"><a class="header" href="#レコード">レコード</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/13_record.md&amp;commit_hash=96b113c47ec6ca7ad91a6b486d55758de00d557d"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/13_record.md%26commit_hash%3D96b113c47ec6ca7ad91a6b486d55758de00d557d" alt="badge" /></a></p>
<p>レコードは、キーでアクセスするDictとコンパイル時にアクセスが検査されるタプルの性質を併せ持つコレクションです。
JavaScriptをやったことがある方ならば、オブジェクトリテラル記法の(より強化された)ようなものと考えてください。</p>
<pre><code class="language-python">john = {.name = &quot;John&quot;; .age = 21}

assert john.name == &quot;John&quot;
assert john.age == 21
assert john in {.name = Str; .age = Nat}
john[&quot;name&quot;] # Error: john is not subscribable
</code></pre>
<p><code>.name</code>, <code>.age</code>の部分を属性、<code>&quot;John&quot;</code>, <code>21</code>の部分を属性値と呼びます。</p>
<p>JavaScriptのオブジェクトリテラルとの相違点は、文字列でアクセスできない点です。すなわち、属性は単なる文字列ではありません。
これは、値へのアクセスをコンパイル時に決定するためと、辞書とレコードが別物であるためといった理由があります。つまり、<code>{&quot;name&quot;: &quot;John&quot;}</code>はDict,<code>{name = &quot;John&quot;}</code>はレコードです。
では、辞書とレコードはどう使い分ければいいのでしょうか。
一般的にはレコードの使用を推奨します。レコードには、コンパイル時に要素が存在するかチェックされる、 <strong>可視性(visibility)</strong> を指定できるなどのメリットがあります。
可視性の指定は、Java言語などでみられるpublic/privateの指定に相当します。詳しくは<a href="./19_visibility.html">可視性</a>を参照してください。</p>
<pre><code class="language-python compile_fail">a = {x = 1; .y = x + 1}
assert a.y == 2
a.x # AttributeError: x is private
# Hint: declare as `.x`.
</code></pre>
<p>上の例はJavaScriptに習熟している人間からすると奇妙かもしれませんが、単に<code>x</code>と宣言すると外部からアクセスできず、<code>.</code>をつけると<code>.</code>でアクセスできるというわけです。</p>
<p>属性に対する明示的な型指定もできます。</p>
<pre><code class="language-python">anonymous = {
    .name: Option! Str = &quot;Jane Doe&quot;
    .age = 20
}
anonymous.name.set! &quot;John Doe&quot;
</code></pre>
<p>レコードはメソッドも持てます。</p>
<pre><code class="language-python">o = {
    .i = !0
    .inc! ref! self = self.i.inc!()
}

assert o.i == 0
o.inc!()
assert o.i == 1
</code></pre>
<p>レコードに関して特筆すべき文法があります。レコードの属性値が全てクラス(構造型ではダメです)のとき、そのレコード自体が、自身の属性を要求属性とする型としてふるまいます。
このような型をレコード型と呼びます。詳しくは[レコード]の項を参照してください。</p>
<pre><code class="language-python"># レコード
john = {.name = &quot;John&quot;}
# レコード型
john: {.name = Str}
Named = {.name = Str}
john: Named

greet! n: Named =
    print! &quot;Hello, I am \{n.name}&quot;
greet! john # &quot;Hello, I am John&quot;

print! Named.name # Str
</code></pre>
<h2 id="レコードの分解"><a class="header" href="#レコードの分解">レコードの分解</a></h2>
<p>レコードは以下のようにして分解できます。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x = a; y = b} = record
assert a == 1
assert b == 2

point = {x = 2; y = 3; z = 4}
match point:
    {x = 0; y = 0; z = 0} -&gt; &quot;origin&quot;
    {x = _; y = 0; z = 0} -&gt; &quot;on the x axis&quot;
    {x = 0; ...} -&gt; &quot;x = 0&quot;
    {x = x; y = y; z = z} -&gt; &quot;({x}, {y}, {z})&quot;
</code></pre>
<p>また、レコードは属性と同名の変数があるとき、例えば<code>x = x</code>または<code>x = .x</code>を<code>x</code>に、<code>.x = .x</code>または<code>.x = x</code>を<code>.x</code>に省略できます。
ただし、属性が一つのときはセットと区別するために<code>;</code>を付ける必要があります。</p>
<pre><code class="language-python">x = 1
y = 2
xy = {x; y}
a = 1
b = 2
ab = {.a; .b}
assert ab.a == 1
assert ab.b == 2

record = {x;}
tuple = {x}
assert tuple.1 == 1
</code></pre>
<p>この構文を利用して、レコードを分解して変数に代入できます。</p>
<pre><code class="language-python"># same as `{x = x; y = y} = xy`
{x; y} = xy
assert x == 1
assert y == 2
# same as `{.a = a; .b = b} = ab`
{a; b} = ab
assert a == 1
assert b == 2
</code></pre>
<h2 id="空レコード"><a class="header" href="#空レコード">空レコード</a></h2>
<p>空のレコードは<code>{=}</code>で表されます。空のレコードはUnitと同じく、自身のクラスそのものでもあります。</p>
<pre><code class="language-python">empty_record = {=}
empty_record: {=}
# Object: Type = {=}
empty_record: Object
empty_record: Structural {=}
{x = 3; y = 5}: Structural {=}
</code></pre>
<p>空のレコードは空のDict<code>{:}</code>や空のセット<code>{}</code>とは異なります。特に<code>{}</code>とは意味が正反対なので注意が必要です(Pythonでは<code>{}</code>は空の辞書となっているが、Ergでは<code>!{:}</code>です)。
列挙型としての<code>{}</code>は何も要素に含まない空虚な型です。<code>Never</code>型は、これをクラス化したものです。
逆に、レコードクラスの<code>{=}</code>は要求インスタンス属性がないので、全てのオブジェクトがこれの要素になります。<code>Object</code>は、これのエイリアスです。
<code>Object</code>(のパッチ)は<code>.__sizeof__</code>などの極めて基本的な提供メソッドを持ちます。</p>
<pre><code class="language-python">AnyPatch = Patch Structural {=}
    .__sizeof__ self = ...
    .clone self = ...
    ...
Never = Class {}
</code></pre>
<p>注意として、<code>{}</code>, <code>Never</code>型と構造的に等価な型・クラスは他に存在できず、ユーザーが<code>{}</code>, <code>Class {}</code>を右辺に指定して型を定義するとエラーとなります。
これにより、例えば<code>1..10 or -10..-1</code>とするところを<code>1..10 and -10..-1</code>としてしまうようなミスを防げます。
また、合成の結果<code>Object</code>となるような型(<code>Int and Str</code>など)を定義すると、単に<code>Object</code>とするように警告が出ます。</p>
<h2 id="インスタントブロック"><a class="header" href="#インスタントブロック">インスタントブロック</a></h2>
<p>Ergにはもう一つインスタントブロックという構文がありますが、これは単に最後に評価した値を返すだけです。属性の保持はできません。</p>
<pre><code class="language-python">x =
    x = 1
    y = x + 1
    y ** 3
assert x == 8

y =
    .x = 1 # SyntaxError: cannot define an attribute in an entity block
</code></pre>
<h2 id="データクラス"><a class="header" href="#データクラス">データクラス</a></h2>
<p>素のレコード(レコードリテラルで生成されたレコード)は、これ単体でメソッドを実装しようとすると、直接インスタンスに定義する必要があります。
これは効率が悪く、さらに属性の数が増えていくとエラー表示などが見にくくなり使いにくいです。</p>
<pre><code class="language-python compile_fail">john = {
    name = &quot;John Smith&quot;
    age = !20
    .greet! ref self = print! &quot;Hello, my name is \{self::name} and I am \{self::age} years old.&quot;
    .inc_age! ref! self = self::age.update! x -&gt; x + 1
}
print! john + 1
# TypeError: + is not implemented for {name = Str; age = Int; .greet! = Ref(Self).() =&gt; None; inc_age! = Ref!(Self).() =&gt; None}, Int
</code></pre>
<p>そこで、このような場合はレコードクラスを継承します。このようなクラスをデータクラスと呼びます。
これについては<a href="./type/04_class.html">クラス</a>の項で詳しく説明します。</p>
<pre><code class="language-python checker_ignore">Person = Inherit {name = Str; age = Nat}
Person.
    greet! ref self = print! &quot;Hello, my name is \{self::name} and I am \{self::age} years old.&quot;
    inc_age! ref! self = self::age.update! x -&gt; x + 1

john = Person.new {name = &quot;John Smith&quot;; age = 20}
print! john + 1
# TypeError: + is not implemented for Person, Int
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="セット"><a class="header" href="#セット">セット</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/14_set.md&amp;commit_hash=e86a0987ed14a4de5da770372d4f3729c7691503"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/14_set.md%26commit_hash%3De86a0987ed14a4de5da770372d4f3729c7691503" alt="badge" /></a></p>
<p>セットは集合を表し、データ構造的には重複、順序のない配列です。</p>
<pre><code class="language-python">assert Set.from([1, 2, 3, 2, 1]) == {1, 2, 3}
assert {1, 2} == {1, 1, 2} # 重複は自動で削除される
assert {1, 2} == {2, 1}
</code></pre>
<p>型や長さを指定して宣言することもできます。</p>
<pre><code class="language-python">a: {Int; 3} = {0, 1, 2} # OK
b: {Int; 3} = {0, 0, 0} # NG、重複が削除されて長さが変わる
# TypeError: the type of b is mismatched
# expected:  Set(Int, 3)
# but found: Set({0, }, 1)
</code></pre>
<p>また、<code>Eq</code>トレイトが実装されているオブジェクトのみが集合の要素になれます。</p>
<p>そのため、Floatなどを集合の要素として使用することはできません。</p>
<pre><code class="language-python compile_fail">d = {0.0, 1.0} # NG
# Error[#1366]: File &lt;stdin&gt;, line 1, &lt;module&gt;::d
#
# 1 | d = {0.0, 1.0}
#   :      --------
#   :             |- expected: Eq
#   :             |- but found: {0.0f, 1.0f, }
#   :             `- Float has no equivalence relation defined. you should use l == R instead of l - r &lt;= Float.EPSILON
#
# TypeError: the type of _ is mismatched
</code></pre>
<p>セットは集合演算を行えます。</p>
<pre><code class="language-python">assert 1 in {1, 2, 3}
assert not 1 in {}
assert {1} or {2} == {1, 2}
assert {1, 2} and {2, 3} == {2}
assert {1, 2} not {2} == {1}
</code></pre>
<p>セットは等質なコレクションです。別のクラスのオブジェクトを共存させるためには、等質化させなくてはなりません。</p>
<pre><code class="language-python">s: {Int or Str} = {&quot;a&quot;, 1, &quot;b&quot;, -1}
</code></pre>
<h2 id="型としてのセット"><a class="header" href="#型としてのセット">型としてのセット</a></h2>
<p>セットは型としても扱えます。このような型は <strong>列挙型(Enum type)</strong> と呼ばれます。</p>
<pre><code class="language-python">i: {1, 2, 3} = 1
assert i in {1, 2, 3}
</code></pre>
<p>セットの要素がそのまま型の要素になります。
セット自身は違うことに注意が必要です。</p>
<pre><code class="language-python">mut_set = {1, 2, 3}.into {Int; !3}
mut_set.insert!(4)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="型"><a class="header" href="#型">型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/15_type.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/15_type.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>型はErgにおいて非常に重要な機能ですので、<a href="./type/01_type_system.html">専用のセクション</a>を用意しています。そちらをご覧ください。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="ergの型システム"><a class="header" href="#ergの型システム">Ergの型システム</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/01_type_system.md&amp;commit_hash=f4fb25b4004bdfa96d2149fac8c4e40b84e8a45f"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/01_type_system.md%26commit_hash%3Df4fb25b4004bdfa96d2149fac8c4e40b84e8a45f" alt="badge" /></a></p>
<p>以下では、Ergの型システムを概略的に説明します。詳細については他の項で解説します。</p>
<h2 id="定義方法"><a class="header" href="#定義方法">定義方法</a></h2>
<p>Ergの特徴的な点として、(通常の)変数、関数(サブルーチン)、型(カインド)の定義にあまり大きな構文上の違いがないというところがあります。すべて、通常の変数・関数定義の文法に従って定義されます。</p>
<pre><code class="language-python">f i: Int = i + 1
f # &lt;function f&gt;
f(1) # 2
f.method self = ... # SyntaxError: cannot define a method to a subroutine

T I: Int = {...}
T # &lt;kind 'T'&gt;
T(1) # Type T(1)
T.method self = ...
D = Class {private = Int; .public = Int}
D # &lt;class 'D'&gt;
o1 = {private = 1; .public = 2} # o1はどのクラスにも属さないオブジェクト
o2 = D.new {private = 1; .public = 2} # o2はDのインスタンス
o2 = D.new {.public = 2} # InitializationError: class 'D' requires attribute 'private'(: Int) but not defined
</code></pre>
<h2 id="分類"><a class="header" href="#分類">分類</a></h2>
<p>Erg のオブジェクトは全て型付けされています。
最上位の型は<code>{=}</code>であり、<code>__repr__</code>, <code>__hash__</code>, <code>clone</code>などを実装します(要求メソッドではなく、これらの属性はオーバーライドもできません)。
Ergの型システムは構造的部分型(Structural subtyping, SST)を取り入れています。このシステムにより型付けされる型を構造型(Structural type)と呼びます。
構造型には大きく分けて3種類、Attributive(属性型)/Refinement(篩型)/Algebraic(代数演算型)があります。</p>
<table><thead><tr><th></th><th>Record</th><th>Enum</th><th>Interval</th><th>Union</th><th>Intersection</th><th>Diff</th></tr></thead><tbody>
<tr><td>kind</td><td>Attributive</td><td>Refinement</td><td>Refinement</td><td>Algebraic</td><td>Algebraic</td><td>Algebraic</td></tr>
<tr><td>generator</td><td>record</td><td>set</td><td>range operator</td><td>or operator</td><td>and operator</td><td>not operator</td></tr>
</tbody></table>
<p>記名的部分型(Nominal subtyping, NST)を使用することもでき、SST型のNST型への変換を型の記名化(Nominalization)と呼びます。こうしてできた型を記名型(Nominal type)と呼びます。
Ergでは、記名型はクラスとトレイトがそれに該当します。単にクラス/トレイトといった場合、それはレコードクラス/レコードトレイトを指す場合が多いです。</p>
<table><thead><tr><th></th><th>Type</th><th>Abstraction</th><th>Subtyping procedure</th></tr></thead><tbody>
<tr><td>NST</td><td>NominalType</td><td>Trait</td><td>Inheritance</td></tr>
<tr><td>SST</td><td>StructuralType</td><td>Structural Trait</td><td>(Implicit)</td></tr>
</tbody></table>
<p>記名型全体を表す型(<code>NominalType</code>)と構造型全体の型(<code>StructuralType</code>)は型全体の型(<code>Type</code>)のサブタイプです。</p>
<p>Ergは型定義に引数(型引数)を渡すことができます。型引数を持つ<code>Option</code>, <code>Array</code>などを多項カインドと呼びます。これら自体は型ではありませんが、引数を適用することで型となります。また、引数を持たない<code>Int</code>, <code>Str</code>型などを単純型(スカラー型)と呼びます。</p>
<p>型は集合とみなすことができ、包含関係も存在します。例えば<code>Num</code>は<code>Add</code>や<code>Sub</code>などを含んでおり、<code>Int</code>は<code>Nat</code>を含んでいます。
全てのクラスの上位クラスは<code>Object == Class {:}</code>であり、全ての型の下位クラスは<code>Never == Class {}</code>です。これについては後述します。</p>
<h2 id="型-1"><a class="header" href="#型-1">型</a></h2>
<p><code>Array T</code>のような型は型<code>T</code>を引数にとり<code>Array T</code>型を返す、つまり<code>Type -&gt; Type</code>型の関数とみなせます(型理論的にはカインドともいう)。<code>Array T</code>のような型は、特に多相型(Polymorphic Type)と呼び、<code>Array</code>そのものは1項カインドといいます。</p>
<p>引数、戻り値の型が判明している関数の型は<code>(T, U) -&gt; V</code>のように表記します。型が同じ2引数関数全体を指定したい場合は<code>|T| (T, T) -&gt; T</code>、N引数関数全体を指定したい場合、<code>Func N</code>で指定できる。ただし<code>Func N</code>型は引数の数や型に関する情報がないので、呼び出すと戻り値はすべて<code>Obj</code>型になります。</p>
<p><code>Proc</code>型は<code>() =&gt; Int</code>などのように表記します。また、<code>Proc</code>型インスタンスの名前は最後に<code>!</code>をつけなくてはなりません。</p>
<p><code>Method</code>型は第1引数に自身が属するオブジェクト<code>self</code>を(参照として)指定する 関数/プロシージャです。依存型においては、メソッド適用後の自身の型も指定できます。これは <code>T!(!N)</code>型で<code>T!(N ~&gt; N-1).() =&gt; Int</code>などのようにメソッドを指定できるということです。</p>
<p>Ergの配列(Array)はPythonでいうところのリストとなります。<code>[Int; 3]</code>は<code>Int</code>型オブジェクトが3つ入る配列クラスです。</p>
<blockquote>
<p><strong>Note</strong>: <code>(Type; N)</code>は型であり値でもあるので、このような使い方もできます。</p>
<pre><code class="language-python">Types = (Int, Str, Bool)

for! Types, T =&gt;
    print! T
# Int Str Bool
a: Types = (1, &quot;aaa&quot;, True)
</code></pre>
</blockquote>
<pre><code class="language-python">pop|T, N|(l: [T; N]): ([T; N-1], T) =
    [...l, last] = l
    (l, last)

lpop|T, N|(l: [T; N]): (T, [T; N-1]) =
    [first, ...l] = l
    (first, l)
</code></pre>
<p><code>!</code>の付く型はオブジェクトの内部構造書き換えを許可する型です。例えば<code>[T; !N]</code>クラスは動的配列となります。
<code>T</code>型オブジェクトから<code>T!</code>型オブジェクトを生成するには、単項演算子の<code>!</code>を使います。</p>
<pre><code class="language-python">i: Int! = !1
i.update! i -&gt; i + 1
assert i == 2
arr = [1, 2, 3]
arr.push! 4 # ImplError:
mut_arr = [1, 2, 3].into [Int; !3]
mut_arr.push! 4
assert mut_arr == [1, 2, 3, 4]
</code></pre>
<h2 id="型定義"><a class="header" href="#型定義">型定義</a></h2>
<p>型は以下のように定義します。</p>
<pre><code class="language-python">Point2D = {.x = Int; .y = Int}
</code></pre>
<p>なお、<code>i: Int</code>などのように<code>.</code>を省略すると、型内で使われる非公開変数になります。しかしこれも要求属性です。
型もオブジェクトなので、型自体にも属性は存在します。このような属性を型属性といいます。クラスの場合はクラス属性ともいいます。</p>
<h2 id="型クラスデータ型に相当するもの"><a class="header" href="#型クラスデータ型に相当するもの">型クラス、データ型(に相当するもの)</a></h2>
<p>先に述べたように、Ergにおける「型」とは大まかにはオブジェクトの集合を意味します。
以下は<code>+</code>(中置演算子)を要求する <code>Add</code>型の定義です。<code>R, O</code>はいわゆる型引数で、<code>Int</code>や<code>Str</code>など実装のある型(クラス)が入れられます。他の言語で型引数には特別な記法(ジェネリクス、テンプレートなど)が与えられていますが、Ergでは通常の引数と同じように定義できます。
なお型引数は型オブジェクト以外も使用できます。例えば配列型<code>[Int; 3]</code>は<code>Array Int, 3</code>の糖衣文法です。型の実装がかぶる場合、ユーザは明示的に選択しなくてはなりません。</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
</code></pre>
<p>.<code>_+_</code>は Add.<code>_+_</code>の省略形です。前置演算子の.<code>+_</code>は<code>Num</code>型のメソッドです。</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
NumImpl = Patch Num
NumImpl.
    `+_`(self): Self = self
    ...
</code></pre>
<p>多相型は関数のように扱えます。<code>Mul Int, Str</code>などのように指定して単相化します(多くの場合は指定しなくても実引数で推論されます)。</p>
<pre><code class="language-python">1 + 1
`_+_` 1, 1
Nat.`_+_` 1, 1
Int.`_+_` 1, 1
</code></pre>
<p>上の4行は同じ結果を返しますが(正確には、一番下は<code>Int</code>を返します)、一番上を使うのが一般的です。
<code>Ratio.`_+_`(1, 1)</code>とすると、エラーにはならず<code>2.0</code>が返ります。
これは、<code>Int &lt;: Ratio</code>であるために<code>1</code>が<code>Ratio</code>にダウンキャストされるからです。
しかしこれはキャストされません。</p>
<pre><code class="language-python">i = 1
if i: # TypeError: i: Int cannot cast to Bool, use Int.is_zero() instead.
    log &quot;a&quot;
    log &quot;b&quot;
</code></pre>
<p>これは、<code>Bool &lt; Int</code>であるためです(<code>True == 1</code>, <code>False == 0</code>)。サブタイプへのキャストは一般に検証が必要です。</p>
<h2 id="型推論システム"><a class="header" href="#型推論システム">型推論システム</a></h2>
<p>Ergは静的ダックタイピングを採用しており、明示的に型を指定する必要は殆どありません。</p>
<pre><code class="language-python">f x, y = x + y
</code></pre>
<p>上のコードの場合、<code>+</code>を持つ型、すなわち<code>Add</code>が自動的に推論されます。Ergはまず最小の型を推論します。<code>f 0, 1</code>とすれば<code>f x: {0}, y: {1}</code>と推論され、<code>n: Nat; f n, 1</code>の場合<code>f x: Nat, y: {1}</code>と推論されます。最小化後は実装が見つかるまで型を大きくしていきます。<code>{0}, {1}</code>の場合<code>Nat</code>が<code>+</code>の実装がある最小型なので<code>Nat</code>に単相化されます。
<code>{0}, {-1}</code>の場合は<code>Nat</code>にマッチしないので<code>Int</code>に単相化されます。部分型、上位型の関係にない場合は、濃度(インスタンス数)が低い(多相型の場合はさらに引数の少ない)方からトライされます。
<code>{0}</code>と<code>{1}</code>は<code>Int</code>や<code>Nat</code>などの部分型となる列挙型です。
列挙型などには名前を付けて要求/実装メソッドを付けられます。その型にアクセスできる名前空間では、要求を満たすオブジェクトは実装メソッドを使用できます。</p>
<pre><code class="language-python">Binary = Patch {0, 1}
Binary.
    # selfにはインスタンスが格納される。この例では0か1のどちらか。
    # selfを書き換えたい場合、型名、メソッド名に`!`を付けなければならない。
    is_zero(self) = match self:
        0 -&gt; True
        1 -&gt; False # _ -&gt; Falseとしてもよい
    is_one(self) = not self.is_zero()
    to_bool(self) = match self:
        0 -&gt; False
        1 -&gt; True
</code></pre>
<p>以降は<code>0.to_bool()</code>というコードが可能となります(もっとも<code>0 as Bool == False</code>がビルトインで定義されていますが)。
コード中に示されたように、実際に<code>self</code>を書き換える事のできる型の例を示します。</p>
<pre><code class="language-python">Binary! = Patch {0, 1}!
Binary!.
    switch! ref! self = match! self:
        0 =&gt; self = 1
        1 =&gt; self = 0

b = !1
b.switch!()
print! b # =&gt; 0
</code></pre>
<h2 id="構造型無名型"><a class="header" href="#構造型無名型">構造型(無名型)</a></h2>
<pre><code class="language-python">Binary = {0, 1}
</code></pre>
<p>上のコードでの<code>Binary</code>は、<code>0</code>および<code>1</code>が要素の型です。<code>0</code>と<code>1</code>両方を持っている<code>Int</code>型の部分型とも言えます。
<code>{}</code>のようなオブジェクトはそれ自体が型であり、上のように変数に代入して使ってもよいし、代入せずに使うこともできます。
このような型を構造型といいます。クラス(記名型)と対比して後者としての使い方を強調したいときは無名型ともいいます。<code>{0, 1}</code>のような種類の構造型は列挙型と呼ばれ、他に区間型、レコード型などがあります。</p>
<h3 id="型同一性"><a class="header" href="#型同一性">型同一性</a></h3>
<p>下のような指定はできません。<code>Add</code>はそれぞれ別のものを指すと解釈されるからです。
例えば、<code>Int</code>と<code>Str</code>はともに<code>Add</code>だが、<code>Int</code>と<code>Str</code>の加算はできません。</p>
<pre><code class="language-python">add l: Add, r: Add =
    l + r # TypeError: there is no implementation of  `_+_`: |T, U &lt;: Add| (T, U) -&gt; &lt;Failure&gt;
</code></pre>
<p>また、下の<code>A</code>, <code>B</code>は同じ型とはみなされません。しかし、型<code>O</code>は一致するとみなされます。</p>
<pre><code class="language-python">... |R1; R2, O; A &lt;: Add(R1, O); B &lt;: Add(R2, O)|
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="型に関する基本的な文法"><a class="header" href="#型に関する基本的な文法">型に関する基本的な文法</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/02_basic.md&amp;commit_hash=f4fb25b4004bdfa96d2149fac8c4e40b84e8a45f"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/02_basic.md%26commit_hash%3Df4fb25b4004bdfa96d2149fac8c4e40b84e8a45f" alt="badge" /></a></p>
<h2 id="型指定"><a class="header" href="#型指定">型指定</a></h2>
<p>Ergでは以下のように<code>:</code>の後に変数の型を指定します。代入と同時に行うこともできます。</p>
<pre><code class="language-python">i: Int # これから使う変数iはInt型であると宣言する
i: Int = 1
j = 1 # 型指定は省略できる
</code></pre>
<p>通常の式に対しても型指定することができます。</p>
<pre><code class="language-python">i = 1: Int
f([1, &quot;a&quot;]: [Int or Str])
</code></pre>
<p>単純な変数代入の場合、ほとんどの型指定は省略可能です。
型指定は単純な変数よりもサブルーチンや型の定義時に役立ちます。</p>
<pre><code class="language-python"># 引数の型指定
f x, y: Array Int = ...
T X, Y: Array Int = ...
</code></pre>
<p>上の場合、<code>x, y</code>は共に<code>Array Int</code>であることに注意して下さい。</p>
<pre><code class="language-python"># 大文字変数の値は定数式でなくてはならない
f X: Int = X
</code></pre>
<p>あるいは、型引数の情報が完全にいらない場合は<code>_</code>で省略することもできます。</p>
<pre><code class="language-python">g v: [T; _] = ...
</code></pre>
<p>ただし、型指定の箇所で<code>_</code>を指定するとそれは<code>Object</code>を意味することに注意して下さい。</p>
<pre><code class="language-python compile_fail">f x: _, y: Int = x + y # TypeError: + is not implemented between Object and Int
</code></pre>
<h2 id="型表示"><a class="header" href="#型表示">型表示</a></h2>
<p>Ergでは変数だけでなく任意の式に対して明示的に型を表示することができます。この構文を型表示(type ascription)と呼びます。</p>
<pre><code class="language-python">x = (1: Nat)
f(&quot;a&quot;: Str)
f(&quot;a&quot;): Int
&quot;a&quot;: Nat # TypeError:
</code></pre>
<h2 id="部分型指定"><a class="header" href="#部分型指定">部分型指定</a></h2>
<p>Ergでは<code>:</code>(型宣言演算子)による型と式の関係指定の他に、<code>&lt;:</code>(部分型宣言演算子)で型同士の関係を指定することもできます。
<code>&lt;:</code>の左辺はクラスしか指定できません。構造型同士の比較は<code>Subtypeof</code>などを使用して下さい。</p>
<p>これも単純な変数の指定より、サブルーチンや型の定義時に使うことが多いです。</p>
<pre><code class="language-python"># 引数の部分型指定
f X &lt;: T = ...

# 要求属性の部分型指定(.Iterator属性はIterator型のサブタイプであることを要求する)
Iterable T = Trait {
    .Iterator = {Iterator} # == {I | I &lt;: Iterator}
    .iter = Self.() -&gt; Self.Iterator T
    ...
}
</code></pre>
<p>また、クラス定義時に部分型指定を行うと、クラスが指定した型のサブタイプか静的に検査できます。</p>
<pre><code class="language-python"># クラスCはShowの部分型
C = Class Object, Impl=Show
C.show self = ... # Showの要求属性
</code></pre>
<p>特定の場合だけ部分型指定することもできます。</p>
<pre><code class="language-python">K T: Eq
K Int &lt;: Show and Eq
K T = Class Object
K(T).
    `==` self, other = ...
K(Int).
    show self = ...
</code></pre>
<p>構造型を実装する際は、部分型指定を行うことを推奨します。
構造的部分型付けの特性から、要求属性の実装をする際にタイポや型指定の間違いがあってもエラーが出ないためです。</p>
<pre><code class="language-python">C = Class Object
C.shoe self = ... # TypoのせいでShowが実装できない(単なる固有のメソッドとみなされる)
</code></pre>
<h2 id="属性定義"><a class="header" href="#属性定義">属性定義</a></h2>
<p>トレイトやクラスには、モジュール内でのみ属性を定義できます。</p>
<pre><code class="language-python">C = Class()
C.pub_attr = &quot;this is public&quot;
C::private_attr = &quot;this is private&quot;

c = C.new()
assert c.pub_attr == &quot;this is public&quot;
</code></pre>
<p><code>C.</code>か<code>C::</code>のあとに改行してインデント以下にまとめて定義する文法を一括定義(batch definition)といいます。</p>
<pre><code class="language-python">C = Class()
C.pub1 = ...
C.pub2 = ...
C::priv1 = ...
C::priv2 = ...
# これは以下と同じ
C = Class()
C.
    pub1 = ...
    pub2 = ...
C::
    priv1 = ...
    priv2 = ...
</code></pre>
<h2 id="エイリアシング"><a class="header" href="#エイリアシング">エイリアシング</a></h2>
<p>型には別名(エイリアス)を付けることができます。これにより、レコード型など長い型を短く表現できます。</p>
<pre><code class="language-python">Id = Int
Point3D = {x = Int; y = Int; z = Int}
IorS = Int or Str
Vector = Array Int
</code></pre>
<p>またエラー表示の際にも、コンパイラは複合型(上の例の場合、1番目以外の右辺型)にエイリアスが定義されている場合なるべくそれを使用するようになります。</p>
<p>ただし同じ型のエイリアスは1つのモジュールにつき1つまでで、複数のエイリアスがある場合warningが出ます。
これは、違う目的の型は別々の型として新しく定義するべき、ということです。
また、すでにエイリアスのある型に重ねてエイリアスを付けることを防ぐ目的もあります。</p>
<pre><code class="language-python compile_warn">Id = Int
UserId = Int # TypeWarning: duplicate aliases: Id and UserId

Ids = Array Id
Ints = Array Int # TypeWarning: duplicate aliases: Isd and Ints

IorS = Int or Str
IorSorB = IorS or Bool
IorSorB_ = Int or Str or Bool # TypeWarning: duplicate aliases: IorSorB and IorSorB_

Point2D = {x = Int; y = Int}
Point3D = {...Point2D; z = Int}
Point = {x = Int; y = Int; z = Int} # TypeWarning: duplicate aliases: Point3D and Point
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="トレイト"><a class="header" href="#トレイト">トレイト</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/03_trait.md&amp;commit_hash=a373185dec9bc0b1ca8e17d482336d502d714af9"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/03_trait.md%26commit_hash%3Da373185dec9bc0b1ca8e17d482336d502d714af9" alt="badge" /></a></p>
<p>トレイトは、レコード型に型属性の要求を追加した記名型です。
Pythonでいう抽象基底クラス(Abstract Base Class, ABC)に類似しますが、代数的演算を行えるという特徴があります。</p>
<pre><code class="language-python">Norm = Trait {.x = Int; .y = Int; .norm = Self.() -&gt; Int}
</code></pre>
<p>トレイトは属性とメソッドを区別しません。</p>
<p>トレイトは宣言ができるのみで実装を持てないことに注意してください(実装は後に述べるパッチという機能で実現します)。
トレイトは部分型指定でクラスに実装されているかチェックできます。</p>
<pre><code class="language-python">Point2D &lt;: Norm
Point2D = Class {.x = Int; .y = Int}
Point2D.norm self = self.x**2 + self.y**2
</code></pre>
<p>要求属性を実装していないとエラーになります。</p>
<pre><code class="language-python">Point2D &lt;: Norm # TypeError: Point2D is not a subtype of Norm
Point2D = Class {.x = Int; .y = Int}
</code></pre>
<p>トレイトは構造型と同じく合成、置換、排除などの演算を適用できます(e.g. <code>T and U</code>)。このようにしてできたトレイトをインスタントトレイトと呼びます。</p>
<pre><code class="language-python">T = Trait {.x = Int}
U = Trait {.y = Int}
V = Trait {.x = Int; y: Int}
assert Structural(T and U) == Structural V
assert Structural(V not U) == Structural T
W = Trait {.x = Ratio}
assert Structural(W) !=  Structural(T)
assert Structural(W) == Structural(T.replace {.x = Ratio})
</code></pre>
<p>トレイトは型でもあるので、通常の型指定にも使えます。</p>
<pre><code class="language-python">points: [Norm; 2] = [Point2D::new(1, 2), Point2D::new(3, 4)]
assert points.iter().map(x -&gt; x.norm()).collect(Array) == [5, 25]
</code></pre>
<h2 id="トレイトの包摂"><a class="header" href="#トレイトの包摂">トレイトの包摂</a></h2>
<p>関数<code>Subsume</code>によって、あるトレイトを上位型として含むトレイトを定義できます。これをトレイトの <strong>包摂(Subsumption)</strong> と呼びます。
下の例でいうと、<code>BinAddSub</code>は<code>BinAdd</code>と<code>BinSub</code>を包摂しています。
これはクラスにおける継承(Inheritance)に対応しますが、継承と違い複数の基底型を<code>and</code>で合成して指定できます。<code>not</code>によって一部を除外したトレイトでもOKです。</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
ClosedAdd = Subsume Add(Self)
Sub R = Trait {
    .SubO = Type
    .`_-_` = Self.(R) -&gt; O
}
ClosedSub = Subsume Sub(Self)
ClosedAddSub = Subsume ClosedAdd and ClosedSub
</code></pre>
<h2 id="構造的トレイト"><a class="header" href="#構造的トレイト">構造的トレイト</a></h2>
<p>トレイトは構造化できます。</p>
<pre><code class="language-python">SAdd = Structural Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: SAdd|は省略できない
add|A &lt;: SAdd| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

assert add(C.new(1), C.new(2)) == C.new(3)
</code></pre>
<p>記名的トレイトは単に要求メソッドを実装しただけでは使えず、実装したことを明示的に宣言する必要があります。
以下の例では明示的な実装の宣言がないため、<code>add</code>が<code>C</code>型の引数で使えません。<code>C = Class {i = Int}, Impl := Add</code>としなくてはならないのです。</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: Add|は省略できる
add|A &lt;: Add| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

add C.new(1), C.new(2) # TypeError: C is not subclass of Add
# hint: inherit or patch 'Add'
</code></pre>
<p>構造的トレイトはこの実装の宣言がなくてもよいのですが、そのかわり型推論が効きません。使う際は型指定が必要です。</p>
<h2 id="依存トレイト"><a class="header" href="#依存トレイト">依存トレイト</a></h2>
<p>トレイトは引数を取ることができます。これは依存型と同じです。</p>
<pre><code class="language-python">Mapper T: Type = Trait {
    .MapIter = {Iterator}
    .map = (self: Self, T -&gt; U) -&gt; Self.MapIter U
}

# ArrayIterator &lt;: Mapper
# ArrayIterator.MapIter == ArrayMapper
# [1, 2, 3].iter(): ArrayIterator Int
# [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;): ArrayMapper Str
assert [1, 2, 3].iter().map(x -&gt; &quot;\{x}&quot;).collect(Array) == [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]
</code></pre>
<h2 id="トレイトにおけるオーバーライド"><a class="header" href="#トレイトにおけるオーバーライド">トレイトにおけるオーバーライド</a></h2>
<p>派生トレイトでは基底トレイトの型定義をオーバーライドできます。
この場合、オーバーライドするメソッドの型は、基底メソッドの型の部分型でなければなりません。</p>
<pre><code class="language-python"># `Self.(R) -&gt; O`は`Self.(R) -&gt; O or Panic`の部分型
Div R, O: Type = Trait {
    .`/` = Self.(R) -&gt; O or Panic
}
SafeDiv R, O = Subsume Div, {
    @Override
    .`/` = Self.(R) -&gt; O
}
</code></pre>
<h2 id="apiの重複するトレイトの実装と解決"><a class="header" href="#apiの重複するトレイトの実装と解決">APIの重複するトレイトの実装と解決</a></h2>
<p>実際の<code>Add</code>, <code>Sub</code>, <code>Mul</code>の定義はこのようになっています。</p>
<pre><code class="language-python">Add R = Trait {
    .Output = Type
    .`_+_` = (Self, R) -&gt; .Output
}
Sub R = Trait {
    .Output = Type
    .`_-_` = (Self, R) -&gt; .Output
}
Mul R = Trait {
    .Output = Type
    .`*` = (Self, R) -&gt; .Output
}
</code></pre>
<p><code>.Output</code>という変数の名前が重複しています。これら複数のトレイトを同時に実装したい場合、以下のように指定します。</p>
<pre><code class="language-python">P = Class {.x = Int; .y = Int}
# P|Self &lt;: Add(P)|はP|&lt;: Add(P)|に省略できる
P|Self &lt;: Add(P)|.
    Output = P
    `_+_` self, other = P.new {.x = self.x + other.x; .y = self.y + other.y}
P|Self &lt;: Mul(Int)|.
    Output = P
    `*` self, other = P.new {.x = self.x * other; .y = self.y * other}
</code></pre>
<p>このようにして実装した重複のあるAPIは、使用時は殆どの場合型推論されますが、<code>||</code>で明示的に型指定することで解決もできます。</p>
<pre><code class="language-python">print! P.Output # TypeError: ambiguous type resolution
print! P|&lt;: Mul(Int)|.Output # &lt;class 'P'&gt;
</code></pre>
<h2 id="appendix-rustのトレイトとの違い"><a class="header" href="#appendix-rustのトレイトとの違い">Appendix: Rustのトレイトとの違い</a></h2>
<p>Ergのトレイトは<a href="https://www.ptidej.net/courses/ift6251/fall06/presentations/061122/061122.doc.pdf">Schärli et al.</a>の提唱したトレイトに忠実です。
代数演算を行えるようにするためトレイトは実装を持てないようにして、必要ならばパッチをあてる設計にしています。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="クラス"><a class="header" href="#クラス">クラス</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/04_class.md&amp;commit_hash=7078f95cecc961a65befb15929af06ae2331c934"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/04_class.md%26commit_hash%3D7078f95cecc961a65befb15929af06ae2331c934" alt="badge" /></a></p>
<p>Ergにおけるクラスは、大まかには自身の要素(インスタンス)を生成できる型と言えます。
以下は単純なクラスの例です。</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
# .newが定義されなかった場合、自動で`Person.new = Person::__new__`となる
Person.
    new name, age = Self::__new__ {.name = name; .age = age}

john = Person.new &quot;John Smith&quot;, 25
print! john # &lt;Person object&gt;
print! classof(john) # Person
</code></pre>
<p><code>Class</code>に与えられる型(通常はレコード)を要件型(この場合は<code>{.name = Str; .age = Nat}</code>)といいます。
インスタンスは<code>クラス名::__new__ {属性名 = 値; ...}</code>で生成できます。
<code>{.name = &quot;John Smith&quot;; .age = 25}</code>は単なるレコードですが、<code>Person.new</code>を通すことで<code>Person</code>インスタンスに変換されるわけです。
このようなインスタンスを生成するサブルーチンはコンストラクタと呼ばれます。
上のクラスでは、フィールド名等を省略できるように<code>.new</code>メソッドを定義しています。</p>
<p>以下のように改行せず定義すると文法エラーになるので注意してください。</p>
<pre><code class="language-python compile_fail">Person.new name, age = ... # SyntaxError: cannot define attributes directly on an object
</code></pre>
<blockquote>
<p><strong>Warning</strong>: これは最近追加された仕様なので、以降のドキュメントでは守られていない場合があります。見つけた場合は報告してください。</p>
</blockquote>
<h2 id="インスタンス属性クラス属性"><a class="header" href="#インスタンス属性クラス属性">インスタンス属性、クラス属性</a></h2>
<p>Pythonやその他の言語では、以下のようにブロック側でインスタンス属性を定義することが多いが、このような書き方はErgでは別の意味になるので注意が必要である。</p>
<pre><code class="language-python"># Python
class Person:
    name: str
    age: int
</code></pre>
<pre><code class="language-python"># Ergでこの書き方はクラス属性の宣言を意味する(インスタンス属性ではない)
Person = Class()
Person.
    name: Str
    age: Int
</code></pre>
<pre><code class="language-python"># 上のPythonコードに対応するErgコード
Person = Class {
    .name = Str
    .age = Nat
}
</code></pre>
<p>要素属性(レコード内で定義した属性)と型属性(クラスの場合は特にインスタンス属性/クラス属性とも呼ばれる)は全くの別物である。型属性は型自体の持つ属性である。型の要素は、自らの中に目当ての属性がないときに型属性を参照する。要素属性は要素が直接持つ固有の属性である。
なぜこのような区分けがされているか。仮に全てが要素属性だと、オブジェクトを生成した際に全ての属性を複製・初期化する必要があり、非効率であるためである。
また、このように分けたほうが「この属性は共用」「この属性は別々に持つ」などの役割が明確になる。</p>
<p>下の例で説明する。<code>species</code>という属性は全てのインスタンスで共通なので、クラス属性とした方が自然である。だが<code>name</code>という属性は各インスタンスが個々に持っておくべきなのでインスタンス属性とすべきなのである。</p>
<pre><code class="language-python">Person = Class {name = Str}
Person::
    species = &quot;human&quot;
Person.
    describe() =
        log &quot;species: \{Person::species}&quot;
    greet self =
        log &quot;Hello, My name is \{self::name}.&quot;

Person.describe() # species: human
Person.greet() # TypeError: unbound method Person.greet needs an argument

john = Person.new {name = &quot;John&quot;}
john.describe() # species: human
john.greet() # Hello, My name is John.

alice = Person.new {name = &quot;Alice&quot;}
alice.describe() # species: human
alice.greet() # Hello, My name is Alice.
</code></pre>
<p>因みに、インスタンス属性と型属性で同名、同型のものが存在する場合、コンパイルエラーとなる。これは混乱を避けるためである。</p>
<pre><code class="language-python">C = Class {.i = Int}
C.
    i = 1 # AttributeError: `.i` is already defined in instance fields
</code></pre>
<h2 id="class-type"><a class="header" href="#class-type">Class, Type</a></h2>
<p><code>1</code>のクラスと型が違うものであることに注意してください。
<code>1</code>の生成元であるクラスは<code>Int</code>ただひとつです。オブジェクトの属するクラスは<code>classof(obj)</code>または<code>obj.__class__</code>で取得できます。
対して<code>1</code>の型は無数にあります。例としては、<code>{1}, {0, 1}, 0..12, Nat, Int, Num</code>などです。
ただし最小の型はひとつに定めることができ、この場合は<code>{1}</code>です。オブジェクトの属する型は<code>Typeof(obj)</code>で取得できます。
これはコンパイル時関数であり、その名の通りコンパイル時に計算されます。
オブジェクトからは、クラスメソッドの他にパッチメソッドも使用可能です。
Ergではクラスメソッドを追加したりはできませんが、<a href="type/./07_patch.html">パッチ</a>で拡張可能です。</p>
<p>既存のクラスを継承することも出来ます(<a href="type/../29_decorator.html#inheritable">Inheritable</a>クラスの場合)。
<code>Inherit</code>は継承を意味します。左辺の型をサブクラス、右辺の<code>Inherit</code>の引数型をスーパークラスと言います。</p>
<pre><code class="language-python">MyStr = Inherit Str
# other: StrとしておけばMyStrでもOK
MyStr.
    `-` self, other: Str = self.replace other, &quot;&quot;

abc = MyStr.new(&quot;abc&quot;)
# ここの比較はアップキャストが入る
assert abc - &quot;b&quot; == &quot;ac&quot;
</code></pre>
<p>Pythonと違い、定義されたErgのクラスはデフォルトで<code>final</code>(継承不可)です。
継承可能にするためには<code>Inheritable</code>デコレータをクラスに付ける必要があります。
<code>Str</code>は継承可能クラスのひとつです。</p>
<pre><code class="language-python">MyStr = Inherit Str # OK
MyStr2 = Inherit MyStr # NG

@Inheritable
InheritableMyStr = Inherit Str
MyStr3 = Inherit InheritableMyStr # OK
</code></pre>
<p><code>Inherit Obj</code>と<code>Class()</code>は実用上ほぼ等価です。一般的には後者を使用します。</p>
<p>クラスは型とは同値判定の仕組みが異なります。
型は構造に基づいて同値性が判定されます。</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
Human = {.name = Str; .age = Nat}

assert Person == Human
</code></pre>
<p>クラスは同値関係が定義されていません。</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
Human = Class {.name = Str; .age = Nat}

Person == Human # TypeError: cannot compare classes
</code></pre>
<h2 id="構造型との違い"><a class="header" href="#構造型との違い">構造型との違い</a></h2>
<p>クラスは自身の要素を生成することができる型といいましたが、それだけは厳密な説明ではありません。実際はレコード型+パッチでも同じことができるからです。</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    new name, age = {.name; .age}

john = Person.new(&quot;John Smith&quot;, 25)
</code></pre>
<p>クラスを使用するメリットは4つあります。
1つはコンストラクタの正当性が検査されること、2つ目はパフォーマンスが高いこと、3つ目は記名的部分型(NST)が使用できること、4つ目は継承・オーバーライドができることです。</p>
<p>先程レコード型+パッチでもコンストラクタ(のようなもの)が定義できることを見ましたが、これはもちろん正当なコンストラクタとは言えません。<code>.new</code>と名乗っていても全く関係のないオブジェクトを返すことができるからです。クラスの場合は、<code>.new</code>が要件を満たすオブジェクトを生成するか静的に検査されます。</p>
<p>~</p>
<p>クラスの型検査は、単にオブジェクトの<code>.__class__</code>属性を見るだけで完了します。なので、オブジェクトが型に属しているかの検査が高速です。</p>
<p>~</p>
<p>ErgではクラスでNSTを実現します。NSTの利点として、堅牢性などが挙げられます。
大規模なプログラムを書いていると、オブジェクトの構造が偶然一致することはままあります。</p>
<pre><code class="language-python">Dog = {.name = Str; .age = Nat}
DogImpl = Patch Dog
DogImpl.
    bark = log &quot;Yelp!&quot;
...
Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    greet self = log &quot;Hello, my name is \{self.name}.&quot;

john = {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # &quot;Yelp!&quot;
</code></pre>
<p><code>Dog</code>と<code>Person</code>の構造は全く同一ですが、動物が挨拶したり人間が吠えたりできるようにするのは明らかにナンセンスです。
後者はともかく、前者は不可能なので適用できないようにする方が安全です。このような場合はクラスを使用すると良いでしょう。</p>
<pre><code class="language-python">Dog = Class {.name = Str; .age = Nat}
Dog.
    bark = log &quot;Yelp!&quot;
...
Person = Class {.name = Str; .age = Nat}
Person.
    greet self = log &quot;Hello, my name is \{self.name}.&quot;

john = Person.new {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # TypeError: `Person` object has no method `.bark`
</code></pre>
<p>もう一つ、パッチによって追加された型属性は仮想的なもので、実装するクラスが実体として保持している訳ではないという特徴があります。
つまり、<code>T.x</code>, <code>T.bar</code>は<code>{i = Int}</code>と互換性のある型がアクセスできる(コンパイル時に結びつける)オブジェクトであり、<code>{i =  Int}</code>や<code>C</code>に定義されているわけではありません。
対してクラス属性はクラス自身が保持しています。なので、構造が同じであっても継承関係にないクラスからはアクセスできません。</p>
<pre><code class="language-python">C = Class {i = Int}
C.
    foo self = ...
print! dir(C) # [&quot;foo&quot;, ...]

T = Patch {i = Int}
T.
    x = 1
    bar self = ...
print! dir(T) # [&quot;bar&quot;, &quot;x&quot;, ...]
assert T.x == 1
assert {i = 1}.x == 1
print! T.bar # &lt;function bar&gt;
{i = Int}.bar # TypeError: Record({i = Int}) has no method `.bar`
C.bar # TypeError: C has no method `.bar`
print! {i = 1}.bar # &lt;method bar&gt;
print! C.new({i = 1}).bar # &lt;method bar&gt;
</code></pre>
<h2 id="データクラスとの違い"><a class="header" href="#データクラスとの違い">データクラスとの違い</a></h2>
<p>クラスには、レコードを要求型とする<code>Class</code>を通した通常のクラスと、レコードを継承(<code>Inherit</code>)したデータクラスがあります。
データクラスはレコードの機能を受け継いでおり、分解代入ができる、<code>==</code>や<code>hash</code>がデフォルトで実装されているなどの特徴があります。
逆に独自の同値関係やフォーマット表示を定義したい場合は通常のクラスを使用するとよいでしょう。</p>
<pre><code class="language-python">C = Class {i = Int}
c = C.new {i = 1}
d = C.new {i = 2}
print! c # &lt;C object&gt;
c == d # TypeError: `==` is not implemented for `C`

D = Inherit {i = Int}
e = D::{i = 1} # e = D.new {i = 1}と同じ
f = D::{i = 2}
print! e # D(i = 1)
assert e != f
</code></pre>
<h2 id="enum-class"><a class="header" href="#enum-class">Enum Class</a></h2>
<p>Or型のクラスを定義しやすくするために、<code>Enum</code>が用意されています。</p>
<pre><code class="language-python">X = Class()
Y = Class()
XorY = Enum X, Y
</code></pre>
<p>それぞれの型には<code>XorY.X</code>, <code>XorY.Y</code>のようにしてアクセスでき、コンストラクタは<code>X.new |&gt; XorY.new</code>のようにして取得できます。</p>
<pre><code class="language-python">x1 = XorY.new X.new()
x2 = (X.new |&gt; XorY.new())()
x3 = (Y.new |&gt; XorY.new())()
assert x1 == x2
assert x1 != x3
</code></pre>
<h2 id="包含関係"><a class="header" href="#包含関係">包含関係</a></h2>
<p>クラスは、要件型のサブタイプです。要件型のメソッド(パッチメソッド含む)を使用できます。</p>
<pre><code class="language-python">T = Trait {.foo = Foo}
C = Class(..., Impl: T)
C.
    foo = foo
    bar x = ...
assert C &lt; T
assert C.foo == foo
assert not T &lt; C
assert T.foo == Foo
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="継承"><a class="header" href="#継承">継承</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/05_inheritance.md&amp;commit_hash=7078f95cecc961a65befb15929af06ae2331c934"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/05_inheritance.md%26commit_hash%3D7078f95cecc961a65befb15929af06ae2331c934" alt="badge" /></a></p>
<p>継承を使うと、既存のクラスに機能を加えたり特化したりした新しいクラスを定義できます。
継承はトレイトにおける包摂に似ています。継承してできたクラスは、もとのクラスのサブタイプになります。</p>
<pre><code class="language-python">NewInt = Inherit Int
NewInt.
    plus1 self = self + 1

assert NewInt.new(1).plus1() == 2
assert NewInt.new(1) + NewInt.new(1) == 2
</code></pre>
<p>新しく定義するクラスを継承可能なクラスにしたい場合は<code>Inheritable</code>デコレータを付与する必要があります。</p>
<p>オプション引数<code>additional</code>を指定すると追加のインスタンス属性を持つことができます。ただし値クラスの場合はインスタンス属性を追加できません。</p>
<pre><code class="language-python">@Inheritable
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}

john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

MailAddress = Inherit Str, additional: {owner = Str} # TypeError: instance variables cannot be added to a value class
</code></pre>
<p>Ergでは例外的に<code>Never</code>型の継承はできない設計となっている。<code>Never</code>は決してインスタンスを生成できない特異なクラスであるためである。</p>
<h2 id="列挙クラスの継承"><a class="header" href="#列挙クラスの継承">列挙クラスの継承</a></h2>
<p><a href="type/./13_algebraic.html">Or型</a>をクラス化した列挙クラスも継承ができます。この際、オプション引数<code>Excluding</code>を指定することで選択肢のどれか(<code>or</code>で複数選択可)を外せます。
なお追加はできません。選択肢を追加したクラスは、元のクラスのサブタイプとはならないからです。</p>
<pre><code class="language-python">Number = Class Int or Float or Complex
Number.
    abs(self): Float =
        match self:
            i: Int -&gt; i.abs().into Float
            f: Float -&gt; f.abs()
            c: Complex -&gt; c.abs().into Float

# matchの選択肢でc: Complexは現れ得ない
RealNumber = Inherit Number, Excluding: Complex
</code></pre>
<p>同様に、<a href="type/./12_refinement.html">篩型</a>も指定できます。</p>
<pre><code class="language-python">Months = Class 0..12
MonthsNot31Days = Inherit Months, Excluding: {1, 3, 5, 7, 8, 10, 12}

StrMoreThan3 = Class StrWithLen N | N &gt;= 3
StrMoreThan4 = Inherit StrMoreThan3, Excluding: StrWithLen N | N == 3
</code></pre>
<h2 id="オーバーライド"><a class="header" href="#オーバーライド">オーバーライド</a></h2>
<p>元の型に新しいメソッドを追加できるところはパッチと同じですが、クラスはさらに「上書き」が可能です。
この上書きをオーバーライド(override: 上書き)といいます。オーバーライドを行うには3つの条件を満たす必要があります。
まず、オーバーライドはデフォルトではエラーとなるため<code>Override</code>デコレータを付ける必要があります。
さらに、オーバーライドによってメソッドの型を変えることはできません。元の型のサブタイプである必要があります。
そして、他のメソッドから参照されているメソッドをオーバーライドする場合、参照しているメソッドも全てオーバーライドする必要があります。</p>
<p>なぜこのような条件が必要なのでしょうか。それは、オーバーライドが単に一つのメソッドの挙動を変えるだけでなく、別のメソッドの挙動に影響を及ぼす可能性があるからです。</p>
<p>まず、1つ目の条件から解説します。この条件は「不測のオーバーライド」を防ぐためです。
つまり、たまたま派生クラス側で新しく定義したつもりだったメソッドの名前が基底クラスとかちあってしまうといったことを防ぐため、<code>Override</code>デコレータで明示する必要があるのです。</p>
<p>次に、2つ目の条件について考えます。これは型の整合性を保つためです。派生クラスは基底クラスのサブタイプであるため、その振る舞いも基底クラスのものと互換性がなくてはなりません。</p>
<p>最後に、3つ目の条件について考えます。この条件はErg特有で、他のオブジェクト指向言語ではあまり見られないものですが、これも安全のためです。これがなかったとき、どんなまずいことが起こりうるか見てみましょう。</p>
<pre><code class="language-python"># Bad example
@Inheritable
Base! = Class {x = Int!}
Base!.
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!.
    @Override
    g! ref! self = self.f!() # InfiniteRecursionWarning: This code falls into an infinite loop
    # OverrideError: method `.g` is referenced by `.f` but not overridden
</code></pre>
<p>継承クラス<code>Inherited!</code>では、<code>.g!</code>メソッドをオーバーライドして処理を<code>.f!</code>に転送しています。しかし基底クラスの<code>.f!</code>メソッドはその処理を<code>.g!</code>に転送しているので、無限ループが発生してしまっています。<code>.f</code>は<code>Base!</code>クラスでは問題の無いメソッドでしたが、オーバーライドによって想定外の使われ方をされ、壊れてしまったのです。</p>
<p>なので、オーバーライドの影響を受ける可能性のあるメソッドは一般に全て書き直す必要があるわけです。Ergはこのルールを仕様に組み込んでいます。</p>
<pre><code class="language-python"># OK
@Inheritable
Base! = Class {x = Int!}
Base!.
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!.
    @Override
    f! ref! self =
        print! self::x
        self::x.update! x -&gt; x + 1
    @Override
    g! ref! self = self.f!()
</code></pre>
<p>しかし、この仕様はオーバーライドの問題を完全に解決するものではありません。コンパイラはオーバーライドで問題が修正されたか検知できないためです。
オーバーライドによる影響の修正は派生クラスを作成するプログラマの責任です。可能な限り別名のメソッドを定義するようにしましょう。</p>
<h3 id="トレイトの差し替えのように見えるもの"><a class="header" href="#トレイトの差し替えのように見えるもの">トレイトの差し替え(のように見えるもの)</a></h3>
<p>継承時にトレイトを差し替えることはできませんが、一見それを行っているようにみえる例があります。</p>
<p>例えば<code>Real</code>(<code>Add()</code>を実装する)のサブタイプである<code>Int</code>では<code>Add()</code>を再実装しているようにみえます。</p>
<pre><code class="language-python">Int = Class ..., Impl := Add() and ...
</code></pre>
<p>しかし実際は<code>Real</code>の<code>Add()</code>は<code>Add(Real, Real)</code>の略で、<code>Int</code>では<code>Add(Int, Int)</code>で上書きしているだけです。
両者は別のトレイトです(<code>Add</code>は<a href="type/./advanced/variance.html">共変</a>なので<code>Add(Real, Real) :&gt; Add(Int, Int)</code>ではありますが)。</p>
<h2 id="多重継承の禁止"><a class="header" href="#多重継承の禁止">多重継承の禁止</a></h2>
<p>Ergでは通常のクラス同士でIntersection(交差), Diff(除外), Complement(否定)が行えません。</p>
<pre><code class="language-python compile_fail">Int and Str # TypeError: cannot unite classes
</code></pre>
<p>このルールにより、複数のクラスを継承すること、すなわち多重継承が行えません。</p>
<pre><code class="language-python compile_fail">IntAndStr = Inherit Int and Str # SyntaxError: multiple inheritance of classes is not allowed
</code></pre>
<p>ただし、Pythonの多重継承されたクラスは使用可能です。</p>
<h2 id="多層多段継承の禁止"><a class="header" href="#多層多段継承の禁止">多層(多段)継承の禁止</a></h2>
<p>Ergの継承は多層継承も禁止しています。すなわち、継承して作ったクラスを更に継承したクラスを定義することはできません。
ただし、<code>Object</code>を継承している(Inheritable)クラスは例外的に継承可能です。</p>
<p>また、この場合もPythonの多層継承されたクラスは使用可能です。</p>
<h2 id="継承元属性の書き換え禁止"><a class="header" href="#継承元属性の書き換え禁止">継承元属性の書き換え禁止</a></h2>
<p>Ergでは継承元の属性を書き換えることができません。これは2つの意味があります。
1つ目は、継承元のクラス属性に対する更新操作です。再代入はもちろん、<code>.update!</code>メソッドなどによる更新もできません。</p>
<p>オーバーライドはより特化したメソッドで上書きする操作であるため書き換えとは異なります。オーバーライドの際も互換性のある型で置き換えなくてはなりません。</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!.
    var = !1
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1

Inherited! = Inherit Base!:
Inherited!.
    var.update! v -&gt; v + 1
    # TypeError: can't update base class variables
    @Override
    inc_pub! ref! self = self.pub + 1
    # OverrideError: `.inc_pub!` must be subtype of `Self!.() =&gt; ()`
</code></pre>
<p>2つ目は、継承元の(可変)インスタンス属性に対する更新操作です。これも禁止されています。基底クラスのインスタンス属性は、基底クラスの用意したメソッドからのみ更新できます。
属性の可視性にかかわらず、直接更新はできません。ただし読み取りはできます。</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!.
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1
    inc_pri! ref! self = self::pri.update! p -&gt; p + 1

Inherited! = Inherit Base!:
Inherited!.
    # OK
    add2_pub! ref! self =
        self.inc_pub!()
        self.inc_pub!()
    # NG, `Child`は`self.pub`と`self::pri`に触れられない
    add2_pub! ref! self =
        self.pub.update! p -&gt; p + 2
</code></pre>
<p>畢竟(ひっきょう)、Ergの継承ができることは新規属性の追加と基底クラスメソッドのオーバーライドのみといえるでしょう。</p>
<h2 id="継承の使い所"><a class="header" href="#継承の使い所">継承の使い所</a></h2>
<p>継承は正しく使えば強力な機能である反面、クラス同士の依存関係が複雑になりやすいという欠点もあり、特に多重継承・多層継承を使用した場合はその傾向が顕著となります。依存関係の複雑化はコードのメンテナンス性を下げる恐れがあります。
Ergが多重継承、多層継承を禁止したのはこの危険性を低減するためで、クラスパッチという機能を導入したのは、継承の「機能の追加」という側面を持ちながら依存関係の煩雑化を抑えるためです。</p>
<p>では逆に継承を使うべきところはどこでしょうか。一つの指標は、「基底クラスの意味論的なサブタイプがほしい」場合です。
Ergはサブタイプ判定の一部を型システムが自動で判定してくれます(e.g. 0以上のIntであるところのNat)。
しかし例えば、「有効なメールアドレスを表す文字列型」をErgの型システムのみに頼って作成することは困難です。通常の文字列にバリデーションを行うべきでしょう。そして、バリデーションが通った文字列オブジェクトには何らかの「保証書」を付加したいところです。それが継承クラスへのダウンキャストに相当するわけです。<code>Strオブジェクト</code>を<code>ValidMailAddressStr</code>にダウンキャストすることは、文字列が正しいメールアドレスの形式であるか検証することと一対一対応します。</p>
<pre><code class="language-python">ValidMailAddressStr = Inherit Str
ValidMailAddressStr.
    init s: Str =
        validate s # メールアドレスの有効性
        Self.new s

s1 = &quot;invalid mail address&quot;
s2 = &quot;foo@gmail.com&quot;
_ = ValidMailAddressStr.init s1 # panic: invalid mail address
valid = ValidMailAddressStr.init s2
valid: ValidMailAddressStr # 正しいメールアドレス形式であることの確認
</code></pre>
<p>もう一つの指標は、「記名的な多相=多態を実現したい」場合です。
例えば、以下に定義する<code>greet!</code>プロシージャは、<code>Named</code>型のオブジェクトならば何でも受け付けます。
しかし、明らかに<code>Dog</code>型オブジェクトを適用するのは間違えています。そこで引数の型を<code>Person</code>クラスにします。
こうすれば、引数として受け付けるのは<code>Person</code>オブジェクトとそれを継承したクラス、<code>Student</code>オブジェクトのみです。
この方が保守的で、不必要に多くの責任を負う必要がなくなります。</p>
<pre><code class="language-python">Named = {name = Str; ...}
Dog = Class {name = Str; breed = Str}
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}
structural_greet! person: Named =
    print! &quot;Hello, my name is \{person::name}.&quot;
greet! person: Person =
    print! &quot;Hello, my name is \{person::name}.&quot;

max = Dog.new {name = &quot;Max&quot;, breed = &quot;Labrador&quot;}
john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

structural_greet! max # Hello, my name is Max.
structural_greet! john # Hello, my name is John.
greet! alice # Hello, my name is Alice.
greet! max # TypeError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="記名的部分型-vs-構造的部分型"><a class="header" href="#記名的部分型-vs-構造的部分型">記名的部分型 vs. 構造的部分型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/06_nst_vs_sst.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/06_nst_vs_sst.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<pre><code class="language-python">Months = 0..12

# NST
MonthsClass = Class Months
MonthsClass.
    name self =
        match self:
            1 -&gt; &quot;January&quot;
            2 -&gt; &quot;February&quot;
            3 -&gt; &quot;March&quot;
            ...

# SST
MonthsImpl = Patch Months
MonthsImpl.
    name self =
        match self:
            1 -&gt; &quot;January&quot;
            2 -&gt; &quot;February&quot;
            3 -&gt; &quot;March&quot;
            ...

assert 12 in Months
assert 2.name() == &quot;February&quot;
assert not 12 in MonthsClass
assert MonthsClass.new(12) in MonthsClass
# クラスでラップしても構造型は使える
assert MonthsClass.new(12) in Months
# 両方ある場合クラスメソッドが優先される
assert MonthsClass.new(2).name() == &quot;february&quot;
</code></pre>
<h2 id="結局nstとsstどちらを使えばいいのか"><a class="header" href="#結局nstとsstどちらを使えばいいのか">結局、NSTとSSTどちらを使えばいいのか?</a></h2>
<p>どちらにすればよいか判断がつかないときはNSTを推奨します。
SSTはどんなユースケースでも破綻しないコードを書く抽象化能力が要求されます。よい抽象化を実現できれば高い生産性を発揮できますが、間違った抽象化(<strong>見かけによる共通化</strong>)を行うと逆効果となってしまいます。NSTは抽象性をあえて抑え、このリスクを減らすことができます。あなたがライブラリの実装者でないならば、NSTのみでコーディングを行っても悪くはないでしょう。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="パッチ"><a class="header" href="#パッチ">パッチ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/07_patch.md&amp;commit_hash=95be9a51a2d95a0dd08dca1eb520c172aed2645c"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/07_patch.md%26commit_hash%3D95be9a51a2d95a0dd08dca1eb520c172aed2645c" alt="badge" /></a></p>
<p>Ergでは、既存の型・クラスに手を加えることはできません。
クラスにメソッドを追加で定義することはできず、特殊化(specialization, 多相に宣言された型を単相化し専用のメソッドを定義する機能。C++などが持つ)も行えません。
しかし、既存の型・クラスに機能を追加したいという状況は多々あり、これを実現するためにパッチという機能があります。</p>
<pre><code class="language-python">StrReverse = Patch Str
StrReverse.
    reverse self = self.iter().rev().collect(Str)

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
</code></pre>
<p>パッチの名前は、主に追加する機能を端的に表すものがよいでしょう。
こうすると、パッチされる型(<code>Str</code>)のオブジェクトはパッチ(<code>StrReverse</code>)のメソッドを使えるようになります。
実際、<code>.reverse</code>は<code>Str</code>のメソッドではなく、<code>StrRReverse</code>に追加されたメソッドです。</p>
<p>ただし、パッチのメソッドは記名型(クラス)のメソッドより優先度が低く、既存のクラスのメソッドをオーバーライド(上書き)できません。</p>
<pre><code class="language-python">StrangeInt = Patch Int
StrangeInt.
    `_+_` = Int.`_-_` # AssignError: .`_+_` is already defined in Int
</code></pre>
<p>オーバーライドしたければ、クラスを継承する必要があります。
ただし、基本的にはオーバーライドを行わず、別の名前のメソッドを定義することを推奨します。
オーバーライドは安全のためいくつかの制約が課されており、それほど気軽に行えるものではないからです。</p>
<pre><code class="language-python">StrangeInt = Inherit Int
StrangeInt.
    # オーバーライドするメソッドにはOverrideデコレータを付与する必要がある
    # さらに、Int.`_+_`に依存するIntのメソッドすべてをオーバーライドする必要がある
    @Override
    `_+_` = Super.`_-_` # OverrideError: Int.`_+_` is referenced by ..., so these method must also be overridden
</code></pre>
<h2 id="パッチの選択"><a class="header" href="#パッチの選択">パッチの選択</a></h2>
<p>パッチは一つの型に対して複数定義し、まとめることもできます。</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
StrMultiReplace = Patch(Str)
StrMultiReverse.
    multi_replace self, pattern_and_targets: [(Pattern, Str)] = ...
StrToCamelCase = Patch(Str)
StrToCamelCase.
    to_camel_case self = ...
StrToKebabCase = Patch(Str)
StrToKebabCase.
    to_kebab_case self = ...

StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
</code></pre>
<pre><code class="language-python">{StrBoosterPack; ...} = import &quot;foo&quot;

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
assert &quot;abc&quot;.multi_replace([(&quot;a&quot;, &quot;A&quot;), (&quot;b&quot;, &quot;B&quot;)]) == &quot;ABc&quot;
assert &quot;to camel case&quot;.to_camel_case() == &quot;toCamelCase&quot;
assert &quot;to kebab case&quot;.to_kebab_case() == &quot;to-kebab-case&quot;
</code></pre>
<p>複数のパッチが定義できると、中には実装の重複が発生する可能性があります。</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
# より効率的な実装
StrReverseMk2 = Patch(Str)
StrReverseMk2.
    reverse self = ...

&quot;hello&quot;.reverse() # PatchSelectionError: multiple choices of `.reverse`: StrReverse, StrReverseMk2
</code></pre>
<p>そのような場合は、メソッド形式ではなく関連関数形式とすることで一意化できます。</p>
<pre><code class="language-python">assert StrReverseMk2.reverse(&quot;hello&quot;) == &quot;olleh&quot;
</code></pre>
<p>また、選択的にインポートすることでも一意化できます。</p>
<pre><code class="language-python">{StrReverseMk2; ...} = import &quot;foo&quot;

assert StrReverseMk2.reverse(&quot;hello&quot;) == &quot;olleh&quot;
</code></pre>
<h2 id="接着パッチglue-patch"><a class="header" href="#接着パッチglue-patch">接着パッチ(Glue Patch)</a></h2>
<p>パッチは型同士を関係付けることもできます。<code>StrReverse</code>は<code>Str</code>と<code>Reverse</code>を関係付けています。
このようなパッチは接着パッチ(Glue Patch)と呼ばれます。
<code>Str</code>は組み込みの型であるため、ユーザーがトレイトを後付けするためには接着パッチが必要なわけです。</p>
<pre><code class="language-python">Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch Str, Impl := Reverse
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>接着パッチは一つの型とトレイトのペアに対して一つまでしか定義できません。
これは、仮に複数の接着パッチが同時に「見える」場合、どの実装を選択するか一意に決められなくなるからです。
ただし、別のスコープ(モジュール)に移る際にパッチを入れ替えることはできます。</p>
<pre><code class="language-python">NumericStr = Inherit Str
NumericStr.
    ...

NumStrRev = Patch NumericStr, Impl := Reverse
NumStrRev.
    ...
# DuplicatePatchError: NumericStr is already associated with `Reverse`
# hint: `Str` (superclass of `NumericStr`) is associated with `Reverse` by `StrReverse`
</code></pre>
<h2 id="appendix-rustのトレイトとの関連"><a class="header" href="#appendix-rustのトレイトとの関連">Appendix: Rustのトレイトとの関連</a></h2>
<p>ErgのパッチはRustの(後付けの)implブロックに相当します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
trait Reverse {
    fn reverse(self) -&gt; Self;
}

impl Reverse for String {
    fn reverse(self) -&gt; Self {
        self.chars().rev().collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>RustのトレイトはErgのトレイトとパッチの機能を併せ持つ機能だと言えるでしょう。こう言うとRustのトレイトの方が便利に聞こえますが、実はそうとも限りません。</p>
<pre><code class="language-python"># Erg
Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch(Str, Impl := Reverse)
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>Ergではimplブロックがパッチとしてオブジェクト化されているため、他のモジュールから取り込む際に選択的な取り込みが可能になります。さらに副次的な効果として、外部構造体への外部トレイトの実装も可能となっています。
また、dyn traitやimpl traitといった文法も構造型によって必要なくなります。</p>
<pre><code class="language-python"># Erg
reversible: [Reverse; 2] = [[1, 2, 3], &quot;hello&quot;]

iter|T|(i: Iterable T): Iterator T = i.iter()
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
let reversible: [Box&lt;dyn Reverse&gt;; 2] = [Box::new([1, 2, 3]), Box::new(&quot;hello&quot;)];

fn iter&lt;I&gt;(i: I) -&gt; impl Iterator&lt;Item = I::Item&gt; where I: IntoIterator {
    i.into_iter()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="全称パッチ"><a class="header" href="#全称パッチ">全称パッチ</a></h2>
<p>パッチはある特定の型ひとつだけではなく、「関数の型全般」などに対しても定義できます。
この場合、自由度を与えたい項を引数にします(下の場合は<code>T: Type</code>)。このようにして定義したパッチを全称パッチといいます。
見れば分かる通り、全称パッチは正確にはパッチを返す関数ですが、それ自体もパッチとみなすことが可能です。</p>
<pre><code class="language-python">FnType T: Type = Patch(T -&gt; T)
FnType(T).
    type = T

assert (Int -&gt; Int).type == Int
</code></pre>
<h2 id="構造的パッチ"><a class="header" href="#構造的パッチ">構造的パッチ</a></h2>
<p>さらにパッチは、ある構造を満たす型すべてに定義することもできます。
ただしこれは記名的なパッチやクラスメソッドより優先度は低くなっています。</p>
<p>以下のように拡張によって成り立たなくなる性質もあるので、構造的パッチを定義する際は慎重に設計してください。</p>
<pre><code class="language-python"># これはStructuralにするべきではない
Norm = Structural Patch {x = Int; y = Int}
Norm.
    norm self = self::x**2 + self::y**2

Point2D = Class {x = Int; y = Int}
assert Point2D.new({x = 1; y = 2}).norm() == 5

Point3D = Class {x = Int; y = Int; z = Int}
assert Point3D.new({x = 1; y = 2; z = 3}).norm() == 14 # AssertionError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="値型"><a class="header" href="#値型">値型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/08_value.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/08_value.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>値型はErg組み込み型のうちコンパイル時評価が可能な型で、具体的には以下のものです。</p>
<pre><code class="language-python">Value = (
    Int
    or Nat
    or Ratio
    or Float
    or Complex
    or Bool
    or Str
    or NoneType
    or Array Const
    or Tuple Const
    or Set Const
    or ConstFunc(Const, _)
    or ConstProc(Const, _)
    or ConstMethod(Const, _)
)
</code></pre>
<p>値型のオブジェクト・定数、およびそれにコンパイル時サブルーチンを適用したものを定数式と呼びます。</p>
<pre><code class="language-python">1, 1.0, 1+2im, True, None, &quot;aaa&quot;, [1, 2, 3], Fib(12)
</code></pre>
<p>サブルーチンについては注意が必要です。サブルーチンは値型であるものとそうでないものがあります。
サブルーチンの実体は単なるポインタであるためすべて値として扱っても良い<a href="type/08_value.html#1"><sup id="f1">1</sup></a>のですが、コンパイル時サブルーチンでないものを定数文脈で使えてもあまり意味がないため、値型とはなっていません。</p>
<p>値型に分類される型は、将来的には追加される可能性があります。</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> Ergにおける値型という用語は、他の言語での定義とは異なっています。純粋なErgの意味論内でメモリという概念は存在せず、スタックに置かれるから値型であるとか、実体としてポインタだから値型ではない、といった言明は正しくありません。あくまで、値型は<code>Value</code>型もしくはそのサブタイプであるという意味しか持ちません。<a href="type/08_value.html#f1">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性型"><a class="header" href="#属性型">属性型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/09_attributive.md&amp;commit_hash=412a6fd1ea507a7afa1304bcef642dfe6b3a0872"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/09_attributive.md%26commit_hash%3D412a6fd1ea507a7afa1304bcef642dfe6b3a0872" alt="badge" /></a></p>
<p>属性型は、レコードおよびデータクラス、パッチ、モジュールなどが含まれる型です。
属性型に属する型は値型ではありません。</p>
<h2 id="レコード型の合成"><a class="header" href="#レコード型の合成">レコード型の合成</a></h2>
<p>合成されたレコード型は平坦化できます。例えば、<code>{..::{.name = Str; .age = Nat}; ..::{.name = Str; .id = Nat}}</code>は<code>{.name = Str; .age = Nat; .id = Nat}</code>となります。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="区間型"><a class="header" href="#区間型">区間型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/10_interval.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/10_interval.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p><code>Range</code>オブジェクトの最も基本的な使い方は、イテレータとしての使用です。</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>Pythonと違い、末尾の数字は含まれることに注意してください。</p>
<p>しかし、<code>Range</code>オブジェクトの使い道はこれだけではありません。型としても使うことが出来ます。このような型を区間型(Interval type)と呼びます。</p>
<pre><code class="language-python">i: 0..10 = 2
</code></pre>
<p><code>Nat</code>型は<code>0..&lt;Inf</code>と等価な型で、<code>Int</code>と<code>Ratio</code>型は<code>-Inf&lt;..&lt;Inf</code>と等価な型です。
<code>0..&lt;Inf</code>は<code>0.._</code>と書くことも出来ます。<code>_</code>は、<code>Int</code>型の任意のインスタンスを意味します。</p>
<p>イテレータとしても使えるため、<code>10..0</code>などのように逆順で指定することも出来ますが、
<code>&lt;..</code>, <code>..&lt;</code>, <code>&lt;..&lt;</code>の向きは逆転できません。</p>
<pre><code class="language-python">a = 0..10 # OK
b = 0..&lt;10 # OK
c = 10..0 # OK
d = 10&lt;..0 # Syntax error
e = 10..&lt;0 # Syntax error
f = 10&lt;..&lt;0 # Syntax error
</code></pre>
<p>範囲演算子(range operator)は、<code>Ord</code>な不変型であるならば数値以外の型にも使用できます。</p>
<pre><code class="language-python">Alphabet = &quot;A&quot;..&quot;z&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="列挙型"><a class="header" href="#列挙型">列挙型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/11_enum.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/11_enum.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>列挙型(Enum type)はSetによって生成されます。
列挙型はそのままでも型指定で使えますが、クラス化したりパッチを定義することで更にメソッドを定義できます。
列挙型による部分型システムを列挙的部分型付けといいます。</p>
<pre><code class="language-python">Bool = {True, False}
Status = {&quot;ok&quot;, &quot;error&quot;}
</code></pre>
<p><code>1..7</code>は<code>{1, 2, 3, 4, 5, 6, 7}</code>と書き換えられるので、要素が有限の場合は本質的に列挙型と区間型は等価です。</p>
<pre><code class="language-python">Binary! = Class {0, 1}!.
    invert! ref! self =
        if! self == 0:
            do!
                self.set! 1
            do!
                self.set! 0

b = Binary!.new !0
b.invert!()
</code></pre>
<p>因みに、Ergの列挙型は他言語でよくある列挙型を包摂する概念です。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
enum Status { Ok, Error }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Erg
Status = {&quot;Ok&quot;, &quot;Error&quot;}
</code></pre>
<p>Rustとの相違点は、構造的部分型(SST)を採用しているというところにあります。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// StatusとExtraStatusの間には何も関係がない
enum Status { Ok, Error }
enum ExtraStatus { Ok, Error, Unknown }

// メソッドを実装できる
impl Status {
    // ...
}
impl ExtraStatus {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Status &gt; ExtraStatusであり、Statusの要素はExtraStatusのメソッドを使える
Status = Trait {&quot;Ok&quot;, &quot;Error&quot;}
    # ...
ExtraStatus = Trait {&quot;Ok&quot;, &quot;Error&quot;, &quot;Unknown&quot;}
    # ...
</code></pre>
<p>patchingによってメソッドの追加もできます。</p>
<p>明示的に包含関係を示したい場合、または既存のEnum型に選択肢を追加したい場合は<code>or</code>演算子を使います。</p>
<pre><code class="language-python">ExtraStatus = Status or {&quot;Unknown&quot;}
</code></pre>
<p>要素の属するクラスがすべて同一である列挙型を等質(homogenous)な列挙型といいます。
デフォルトでは、等質な列挙型を要件型とするクラスは、要素が属しているクラスのサブクラスとして扱えます。
あえてそうしたくない場合は、ラッパークラスとするとよいでしょう。</p>
<pre><code class="language-python">Abc = Class {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}
Abc.new(&quot;A&quot;).is_uppercase()

OpaqueAbc = Class {inner = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}}.
    new inner: {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} = Self.new {inner;}
OpaqueAbc.new(&quot;A&quot;).is_uppercase() # TypeError
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="篩型"><a class="header" href="#篩型">篩型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/12_refinement.md&amp;commit_hash=c248056b7e0273027b3c86fb912430bbde711941"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/12_refinement.md%26commit_hash%3Dc248056b7e0273027b3c86fb912430bbde711941" alt="badge" /></a></p>
<p>Refinement type(篩型、ふるいがた)は、述語式によって制約付けられた型です。列挙型や区間型は篩型の一種です。</p>
<p>篩型の標準形は<code>{Elem: Type | (Pred)*}</code>です。これは、述語式<code>Pred</code>を満たす<code>Elem</code>を要素とする型である、という意味です。
<code>Type</code>に使えるのは<a href="type/./08_value.html">Value型</a>のみです。</p>
<pre><code class="language-python">Nat = 0.._
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N &gt;= 3}
</code></pre>
<p>複数のPredがあるとき、<code>;</code>か<code>and</code>, <code>or</code>で区切れます。<code>;</code>と<code>and</code>は同じ意味です。</p>
<p><code>Odd</code>の要素は<code>1, 3, 5, 7, 9, ...</code>です。
篩にかけるように既存の型の一部を要素とする型になることから篩型と呼ばれます。</p>
<p><code>Pred</code>は(左辺)述語式と呼ばれます。これは代入式と同じく意味のある値を返すものではなく、左辺にはパターンしか置けません。
すなわち、<code>X**2 - 5X + 6 == 0</code>のような式は篩型の述語式としては使えません。この点において、右辺式の述語式とは異なります。</p>
<pre><code class="language-python">{X: Int | X**2 - 5X + 6 == 0} # SyntaxError: the predicate form is invalid. Only names can be on the left-hand side
</code></pre>
<p>あなたが二次方程式の解法を知っているならば、上の篩型は<code>{2, 3}</code>と同等になるだろうと予想できるはずです。
しかしErgコンパイラは代数学の知識をほとんど持ち合わせていないので、右の述語式を解決できないのです。</p>
<h2 id="篩型の部分型付け規則"><a class="header" href="#篩型の部分型付け規則">篩型の部分型付け規則</a></h2>
<p>全ての篩型は、<code>Type</code>部で指定された型の部分型です。</p>
<pre><code class="language-erg">{I: Int | I &lt;= 0} &lt;: Int
</code></pre>
<p>その他、現在のErgは整数の比較に関する部分型規則を持っています。</p>
<pre><code class="language-erg">{I: Int | I &lt;= 5} &lt;: {I: Int | I &lt;= 0}
</code></pre>
<h2 id="スマートキャスト"><a class="header" href="#スマートキャスト">スマートキャスト</a></h2>
<p><code>Odd</code>を定義したのはいいですが、このままではリテラル以外ではあまり使えないようにみえます。通常の<code>Int</code>オブジェクトの中の奇数を<code>Odd</code>に昇格させる、つまり<code>Int</code>を<code>Odd</code>にダウンキャストするためには、<code>Odd</code>のコンストラクタを通す必要があります。
篩型の場合、通常のコンストラクタ<code>.new</code>はパニックする可能性があり、<code>.try_new</code>という<code>Result</code>型を返す補助的なコンストラクタもあります。</p>
<pre><code class="language-python">i = Odd.new (0..10).sample!() # i: Odd (or Panic)
</code></pre>
<p>また、<code>match</code>中で型指定として使用することもできます。</p>
<pre><code class="language-python"># i: 0..10
i = (0..10).sample!()
match i:
    o: Odd -&gt;
        log &quot;i: Odd&quot;
    n: Nat -&gt; # 0..10 &lt; Nat
        log &quot;i: Nat&quot;
</code></pre>
<p>ただし、Ergは現在のところ<code>Odd</code>でなかったから<code>Even</code>、などといった副次的な判断はできません。</p>
<h2 id="列挙型区間型と篩型"><a class="header" href="#列挙型区間型と篩型">列挙型、区間型と篩型</a></h2>
<p>今まで紹介した列挙型と区間型は、篩型の糖衣構文です。
<code>{a, b, ...}</code>は<code>{I: Typeof(a) | I == a or I == b or ... }</code>に、<code>a..b</code>は<code>{I: Typeof(a) | I &gt;= a and I &lt;= b}</code>に脱糖されます。</p>
<pre><code class="language-python">{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I &gt;= 1 and I &lt;= 10}
1..&lt;10 == {I: Int | I &gt;= 1 and I &lt; 10} == {I: Int | I &gt;= 1 and I &lt;= 9}
</code></pre>
<h2 id="篩パターン"><a class="header" href="#篩パターン">篩パターン</a></h2>
<p><code>_: {X}</code>を<code>X</code>と書き換えられるように(定数パターン)、<code>_: {X: T | Pred}</code>は<code>X: T | Pred</code>と書き換えることができます。</p>
<pre><code class="language-python"># メソッド.mは長さ3以上の配列に定義される
Array(T, N | N &gt;= 3)
    .m(ref self) = ...
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="代数演算型"><a class="header" href="#代数演算型">代数演算型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/13_algebraic.md&amp;commit_hash=d56549f5288d6c6b2bced57605ad547383963f85"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/13_algebraic.md%26commit_hash%3Dd56549f5288d6c6b2bced57605ad547383963f85" alt="badge" /></a></p>
<p>代数演算型は、型を代数のようにみなして演算することで生成される型のことです。
代数演算型が扱う演算は、Union, Intersection, Diff, Complementなどがあります。
通常のクラスはUnionのみが行えて、他の演算は型エラーになります。</p>
<h2 id="合併型"><a class="header" href="#合併型">合併型</a></h2>
<p>Union型では型について複数の可能性を与える事ができる。名前の通り、<code>or</code>演算子で生成されます。
代表的なUnionは<code>Option</code>型です。<code>Option</code>型は<code>T or NoneType</code>のpatch typeで、主に失敗するかもしれない値を表現します。</p>
<pre><code class="language-python">IntOrStr = Int or Str
assert dict.get(&quot;some key&quot;) in (Int or NoneType)

Option T = T or NoneType
</code></pre>
<p>Union型は可換ですが結合的ではないことに注意してください。すなわち、<code>X or Y or Z</code>は<code>(X or Y) or Z</code>であって<code>X or (Y or Z)</code>とはなりません。
これを認めると、例えば<code>Int or Option(Str)</code>と<code>Option(Int) or Str</code>と<code>Option(Int or Str)</code>が同じ型になってしまいます。</p>
<h2 id="交差型"><a class="header" href="#交差型">交差型</a></h2>
<p>Intersection型は型同士を<code>and</code>演算で結合して得られます。</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
</code></pre>
<p>先述したように通常のクラス同士では<code>and</code>演算で結合できません。インスタンスは唯一つのクラスに属するからです。</p>
<h2 id="除外型"><a class="header" href="#除外型">除外型</a></h2>
<p>Diff型は<code>not</code>演算で得られます。
英文に近い表記としては<code>and not</code>とした方が良いですが、<code>and</code>, <code>or</code>と並べて収まりが良いので<code>not</code>だけで使うのが推奨されます。</p>
<pre><code class="language-python">CompleteNum = Add and Sub and Mul and Div and Eq and Ord
Num = CompleteNum not Div not Ord

True = Bool not {False}
OneTwoThree = {1, 2, 3, 4, 5, 6} - {4, 5, 6, 7, 8, 9, 10}
</code></pre>
<h2 id="否定型"><a class="header" href="#否定型">否定型</a></h2>
<p>Complement型は<code>not</code>演算で得られますが、これは単項演算です。<code>not T</code>型は<code>{=} not T</code>の短縮記法です。
<code>not T</code>型によるIntersectionはDiffと同等で、<code>not T</code>型によるDiffはIntersectionと同等です。
しかしこのような書き方は推奨されません。</p>
<pre><code class="language-python"># 最も単純な非ゼロ数型の定義
NonZero = Not {0}
# 非推奨のスタイル
{True} == Bool and not {False} # 1 == 2 + - 1
Bool == {True} not not {False} # 2 == 1 - -1
</code></pre>
<h2 id="真の代数演算型"><a class="header" href="#真の代数演算型">真の代数演算型</a></h2>
<p>代数演算型には、簡約可能な見かけ上の代数演算型とそれ以上簡約できない「真の代数演算型」があります。
そうではない「見かけの代数型」には、Enum型やInterval型、レコード型の<code>or</code>や<code>and</code>があります。
これらは簡約が可能なので真の代数演算型ではなく、型指定に使うとWarningが出ます。Warningを消すためには簡約化するか型定義を行うかする必要があります。</p>
<pre><code class="language-python">assert {1, 2, 3} or {2, 3} == {1, 2, 3}
assert {1, 2, 3} and {2, 3} == {2, 3}
assert -2..-1 or 1..2 == {-2, -1, 1, 2}

i: {1, 2} or {3, 4} = 1 # TypeWarning: {1, 2} or {3, 4} can be simplified to {1, 2, 3, 4}
p: {x = Int, ...} and {y = Int; ...} = {x = 1; y = 2; z = 3}
# TypeWaring: {x = Int, ...} and {y = Int; ...} can be simplified to {x = Int; y = Int; ...}

Point1D = {x = Int; ...}
Point2D = Point1D and {y = Int; ...} # == {x = Int; y = Int; ...}
q: Point2D = {x = 1; y = 2; z = 3}
</code></pre>
<p>真の代数演算型には、<code>Or</code>型、<code>And</code>型があります。クラス同士の<code>or</code>などは<code>Or</code>型です。</p>
<pre><code class="language-python">assert Int or Str == Or(Int, Str)
assert Int and Marker == And(Int, Marker)
</code></pre>
<p>Diff, Complement型は必ず簡約できるので真の代数演算型ではありません。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="依存型"><a class="header" href="#依存型">依存型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/14_dependent.md&amp;commit_hash=00682a94603fed2b531898200a79f2b4a64d5aae"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/14_dependent.md%26commit_hash%3D00682a94603fed2b531898200a79f2b4a64d5aae" alt="badge" /></a></p>
<p>依存型はErgの最大の特徴とも言っても良い機能です。
依存型とは、値を引数に取る型です。通常の多相型は型のみを引数に取れますが、その制限を緩めたのが依存型といえます。</p>
<p>依存型は、<code>[T; N]</code>(<code>Array(T, N)</code>)などがそれに相当します。
この型は、中身の型<code>T</code>だけでなく、中身の個数<code>N</code>にも依存して決まる型です。<code>N</code>には<code>Nat</code>型のオブジェクトが入ります。</p>
<pre><code class="language-python">a1 = [1, 2, 3]
assert a1 in [Nat; 3]
a2 = [4, 5, 6, 7]
assert a1 in [Nat; 4]
assert a1 + a2 in [Nat; 7]
</code></pre>
<p>関数引数で渡した型オブジェクトが戻り値型に関連する場合は、以下のように記述します。</p>
<pre><code class="language-python">narray: |N: Nat| {N} -&gt; [{N}; N]
narray(N: Nat): [N; N] = [N; N]
assert narray(3) == [3, 3, 3]
</code></pre>
<p>依存型を定義する際は、型引数が全て定数でなくてはなりません。</p>
<p>依存型そのものは既存の言語にも存在するものですが、Ergでは依存型にプロシージャルメソッドを定義できるという特徴があります。</p>
<pre><code class="language-python">x = 1
f x =
    print! f::x, module::x

# Phantom型は型引数と同じ値になるPhantomという属性を持つ
T X: Int = Class Impl := Phantom X
T(X).
    x self = self::Phantom

T(1).x() # 1
</code></pre>
<p>可変依存型の型引数はメソッドの適用によって遷移させることができます。
遷移指定は<code>~&gt;</code>で行います。</p>
<pre><code class="language-python"># `Id`は不変型なので遷移させることはできないことに注意する
VM!(State: {&quot;stopped&quot;, &quot;running&quot;}! := _, Id: Nat := _) = Class(..., Impl := Phantom! State)
VM!().
    # 変わらない変数は`_`を渡せば省略可能, デフォルト引数にしておけば書く必要すらない
    start! ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.initialize_something!()
        self::set_phantom!(&quot;running&quot;)

# 型引数ごとに切り出すこともできる(定義されたモジュール内でのみ)
VM!.new() = VM!(!&quot;stopped&quot;, 1).new()
VM!(&quot;running&quot; ~&gt; &quot;running&quot;).stop! ref! self =
    self.close_something!()
    self::set_phantom!(&quot;stopped&quot;)

vm = VM!.new()
vm.start!()
vm.stop!()
vm.stop!() # TypeError: VM!(!&quot;stopped&quot;, 1) doesn't have .stop!()
# hint: VM!(!&quot;running&quot;, 1) has .stop!()
</code></pre>
<p>既存の型を組み込んだり継承して依存型を作ることもできます。</p>
<pre><code class="language-python">MyArray(T, N) = Inherit [T; N]

# .arrayと連動してself: Self(T, N)の型が変わる
MyStruct!(T, N: Nat!) = Class {.array: [T; !N]}
</code></pre>
<h2 id="実体指定"><a class="header" href="#実体指定">実体指定</a></h2>
<p>動的配列<code>arr: [T; !N]</code>について、処理を進めていくうちに<code>N</code>の情報が失われてしまったとします。
この情報は<code>assert arr.__len__() == X</code>とすることで回復させることができます。</p>
<pre><code class="language-erg">arr: [Int; !_]
assert arr.__len__() == 3
arr: [Int; !3]
</code></pre>
<p>これは型パラメータの <strong>実体指定</strong> によって可能となっています。配列型<code>Array(T, N)</code>は以下のように定義されています。</p>
<pre><code class="language-erg">Array T &lt;-&gt; Union Self.map(x -&gt; Typeof x), N &lt;-&gt; Self.__len__() = ...
</code></pre>
<p><code>&lt;-&gt;</code>は依存型のパラメータのみで使える特別な記号で、そのパラメータに対する実体を指示します。実体であるところの右辺式は、コンパイル時に計算可能でなくても構いません。コンパイル時情報である<code>N</code>と実行時情報である<code>Self.__len__()</code>が実体指定を通してリンクされる訳です。
実体指定に沿った方法でassertionが行われると、型パラメータの情報が復活します。すなわち、<code>assert arr.__len__() == N</code>とすると<code>N</code>の情報が復活します。ただしこの場合の<code>N</code>はコンパイル時計算可能でなくてはなりません。
実体指定は<code>assert</code>以外に<code>match</code>でも活用されます。</p>
<pre><code class="language-erg">arr: [Obj; _]
match! arr:
    pair: [Obj; 2] =&gt; ...
    ints: [Int; _] =&gt; ...
    _ =&gt; ...
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="型変数量化型"><a class="header" href="#型変数量化型">型変数、量化型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/15_quantified.md&amp;commit_hash=44d7784aac3550ba97c8a1eaf20b9264b13d4134"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/15_quantified.md%26commit_hash%3D44d7784aac3550ba97c8a1eaf20b9264b13d4134" alt="badge" /></a></p>
<p>型変数はサブルーチン引数の型指定などに使用する変数で、その型が任意である(単相化しない)ことを示します。
まず、型変数を導入するモチベーションとして、入力をそのまま返す<code>id</code>関数について考えましょう。</p>
<pre><code class="language-python">id x: Int = x
</code></pre>
<p>入力をそのまま返す<code>id</code>関数が<code>Int</code>型に対して定義されていますが、この関数は明らかに任意の型に対して定義できます。
最大のクラスを表す<code>Object</code>を使用してみましょう。</p>
<pre><code class="language-python">id x: Object = x

i = id 1
s = id &quot;foo&quot;
b = id True
</code></pre>
<p>確かに任意の型を受け付けるようになりましたが、1つ問題があります。戻り値の型が<code>Object</code>に拡大されてしまうのです。
入力が<code>Int</code>型なら<code>Int</code>型、<code>Str</code>型なら<code>Str</code>型が返るようになっていてほしいですね。</p>
<pre><code class="language-python">print! id 1 # &lt;Object object&gt;
id(1) + 1 # TypeError: cannot add `Object` and `Int`
</code></pre>
<p>入力の型と戻り値の型が同じであるようにするには、 <strong>型変数</strong> を使います。
型変数は<code>||</code>(型変数リスト)中で宣言します。</p>
<pre><code class="language-python">id|T: Type| x: T = x
assert id(1) == 1
assert id(&quot;foo&quot;) == &quot;foo&quot;
assert id(True) == True
</code></pre>
<p>これを関数の <strong>全称量化(全称化)</strong> と呼びます。細かい違いはありますが、他言語でジェネリクスと呼ばれる機能に相当します。そして全称量化された関数を <strong>多相関数</strong> と呼びます。
多相関数の定義は、全ての型に対して同じ形の関数を定義するようなものです(Ergはオーバーロードを禁止しているので、下のコードは実際には書けません)。</p>
<pre><code class="language-python">id|T: Type| x: T = x
# 疑似コード
# ==
id x: Int = x
id x: Str = x
id x: Bool = x
id x: Ratio = x
id x: NoneType = x
...
</code></pre>
<p>また、型変数<code>T</code>は型指定で使用されているため、<code>Type</code>型と推論できます。なので、<code>|T: Type|</code>は単に<code>|T|</code>に省略できます。
また、<code>|T, N| foo: [T; N]</code>など型オブジェクト以外の場合でも推論できる(<code>T: Type, N: Nat</code>)ならば省略できます。</p>
<p>また、任意の型では大きすぎる場合、制約を与えることも出来ます。
制約を与えることにはメリットもあり、例えばサブタイプ指定をすると、特定のメソッドを使えるようになります。</p>
<pre><code class="language-python"># T &lt;: Add
# =&gt; TはAddのサブクラス
# =&gt; 加算ができる
add|T &lt;: Add| l: T, r: T = l + r
</code></pre>
<p>この例では、<code>T</code>は<code>Add</code>型のサブクラスであると要求され、実際に代入される<code>l</code>と<code>r</code>の型は同じでなくてはなりません。
この場合、<code>T</code>を満たすのは<code>Int</code>や<code>Ratio</code>などです。<code>Int</code>と<code>Str</code>の加算などは定義されていないので弾かれるわけです。</p>
<p>このような型付けもできます。</p>
<pre><code class="language-python">f|
    Y, Z: Type
    X &lt;: Add Y, O1
    O1 &lt;: Add Z, O2
    O2 &lt;: Add X, _
| x: X, y: Y, z: Z  =
    x + y + z + x
</code></pre>
<p>注釈リストが長くなる場合は、事前宣言するとよいでしょう。</p>
<pre><code class="language-python">f: |Y, Z: Type, X &lt;: Add(Y, O1), O1 &lt;: Add(Z, O2), O2 &lt;: Add(X, O3)| (X, Y, Z) -&gt; O3
f|X, Y, Z| x: X, y: Y, z: Z  =
    x + y + z + x
</code></pre>
<p>ジェネリクスを持つ多くの言語と違い、宣言した型変数はすべて、仮引数リスト内(<code>x: X, y: Y, z: Z</code>の部分)か他の型変数の引数内かで使用されていなければなりません。
これは、型変数はすべて実引数から推論可能であるというErgの言語設計からの要求です。
なので、戻り値の型など推論ができない情報は、実引数から渡します。Ergは型を実引数から渡すことができるのです。</p>
<pre><code class="language-python">Iterator T = Trait {
    # 戻り値の型を引数から渡している
    # .collect: |K: Type -&gt; Type| Self(T).({K}) -&gt; K(T)
    .collect(self, K: Type -&gt; Type): K(T) = ...
    ...
}

it = [1, 2, 3].iter().map i -&gt; i + 1
it.collect(Array) # [2, 3, 4]
</code></pre>
<p>型変数が宣言できるのは<code>||</code>の間のみである。ただし、宣言した後はスコープを抜けるまで任意の場所で使用できる。</p>
<pre><code class="language-python">f|X|(x: X): () =
    y: X = x.clone()
    log X.__name__
    log X

f 1
# Int
# &lt;class Int&gt;
</code></pre>
<p>以下のようにして、使用時に明示的に単相化もできます。</p>
<pre><code class="language-python">f: Int -&gt; Int = id|Int|
</code></pre>
<p>その場合、実引数の型よりも指定された型の方が優先されます(合致していないと実引数の型が間違っているという型エラーになる)。
すなわち、実際に渡されたオブジェクトが指定された型に変換可能ならば変換され、そうでなければコンパイルエラーとなります。</p>
<pre><code class="language-python">assert id(1) == 1
assert id|Int|(1) in Int
assert id|Ratio|(1) in Ratio
# キーワード引数も使える
assert id|T: Int|(1) == 1
id|Int|(&quot;str&quot;) # TypeError: id|Int| is type `Int -&gt; Int` but got Str
</code></pre>
<p>この文法が内包表記とバッティングする際は<code>()</code>で囲む必要があります。</p>
<pre><code class="language-python"># {id|Int| x | x &lt;- 1..10}だと{id | ...}だと解釈される
{(id|Int| x) | x &lt;- 1..10}
</code></pre>
<p>既に存在する型と同名の型変数は宣言出来ません。これは、型変数がすべて定数であるためです。</p>
<pre><code class="language-python">I: Type
# ↓ invalid type variable, already exists
f|I: Type| ... = ...
</code></pre>
<h2 id="メソッド定義における型引数"><a class="header" href="#メソッド定義における型引数">メソッド定義における型引数</a></h2>
<p>左辺における型引数はデフォルトで束縛型変数として扱われます。</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(T, N).
    foo(x) = ...
</code></pre>
<p>別の型変数名を使用すると警告が出ます。</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(U, M). # Warning: K's type variable names are 'T' and 'N'
    foo(x) = ...
</code></pre>
<p>定数は定義以降すべての名前空間で同一なので、当然型変数名にも使用できません。</p>
<pre><code class="language-python">N = 1
K(N: Nat) = ... # NameError: N is already defined

L(M: Nat) = ...
# M == N == 1のときのみ定義される
L(N).
    foo(self, x) = ...
# 任意のM: Natに対して定義される
L(M).
    .bar(self, x) = ...
</code></pre>
<p>型引数ごとに多重定義することはできませんが、型引数を代入していない依存型(非原始カインド)と代入した依存型(原始カインド)は関係がないので同名のメソッドを定義できます。</p>
<pre><code class="language-python">K(I: Int) = ...
K.
    # Kは真の型(原始カインド)ではないので、メソッドを定義できない
    # これはメソッドではない(スタティックメソッドに近い)
    foo(x) = ...
K(0).
    foo(self, x): Nat = ...
</code></pre>
<h2 id="全称型"><a class="header" href="#全称型">全称型</a></h2>
<p>前章で定義した<code>id</code>関数は任意の型になれる関数です。では、「<code>id</code>関数自体の型」は何なのでしょうか?</p>
<pre><code class="language-python">print! classof(id) # |T: Type| T -&gt; T
</code></pre>
<p><code>|T: Type| T -&gt; T</code>という型が得られました。これは <strong>閉じた全称量化型/全称型(closed universal quantified type/universal type)</strong> と呼ばれるもので、MLでは<code>['a. ...]</code>、Haskellでは<code>forall t. ...</code>という形式で提供される型に相当します。なぜ「閉じた」という形容詞がつくのかは後述します。</p>
<p>閉じた全称型には制約があり、全称化できる、すなわち左の節に置けるのはサブルーチン型のみです。しかしこれで十分です。Ergではサブルーチンがもっとも基本的な制御構造ですから、「任意のXを扱いたい」というとき、すなわち「任意のXを扱えるサブルーチンがほしい」という意味になります。なので、全称型は多相関数型と同じ意味になります。以降は基本的に、この種の型を多相関数型と呼ぶことにします。</p>
<p>無名関数と同じく、多相関数型には型変数名の任意性がありますが、これらはすべて同値となります。</p>
<pre><code class="language-python">assert (|T: Type| T -&gt; T) == (|U: Type| U -&gt; U)
</code></pre>
<p>ラムダ計算でいうところのα同値であるときに等号が成立します。型上の演算にはいくつかの制約があるので、同値性の判定は(停止性を考えなければ)常に可能です。</p>
<h2 id="多相関数型の部分型付け"><a class="header" href="#多相関数型の部分型付け">多相関数型の部分型付け</a></h2>
<p>多相関数型は、任意の関数型になれます。これは、任意の関数型と部分型関係があるということです。この関係について詳しくみていきましょう。</p>
<p><code>OpenFn T: Type = T -&gt; T</code>のような「型変数が左辺で定義され、右辺で使用されている型」を <strong>開いた全称型(open universal type)</strong> と呼びます。
対して<code>ClosedFn = |T: Type| T -&gt; T</code>など「型変数が右辺で定義・使用されている型」を <strong>閉じた全称型(closed universal type)</strong> と呼びます。</p>
<p>開いた全称型は、同形な全ての「真の型」のスーパータイプになります。対して、閉じた全称型は、同形な全ての「真の型」のサブタイプになります。</p>
<pre><code class="language-python">(|T: Type| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)
</code></pre>
<p>閉じている方が小さい/開いている方が大きい、と覚えるとよいでしょう。
しかし、どうしてそうなるのでしょうか。理解を深めるため、それぞれのインスタンスを考えてみます。</p>
<pre><code class="language-python"># id: |T: Type| T -&gt; T
id|T|(x: T): T = x

# iid: Int -&gt; Int
iid(x: Int): Int = x

# 任意の関数をそのまま返す
id_arbitrary_fn|T|(f1: T -&gt; T): (T -&gt; T) = f
# id_arbitrary_fn(id) == id
# id_arbitrary_fn(iid) == iid

# 多相関数をそのまま返す
id_poly_fn(f2: (|T| T -&gt; T)): (|T| T -&gt; T) = f
# id_poly_fn(id) == id
id_poly_fn(iid) # TypeError

# Int型関数をそのまま返す
id_int_fn(f3: Int -&gt; Int): (Int -&gt; Int) = f
# id_int_fn(id) == id|Int|
# id_int_fn(iid) == iid
</code></pre>
<p><code>|T: Type| T -&gt; T</code>型である<code>id</code>は<code>Int -&gt; Int</code>型のパラメータ<code>f3</code>に代入できているため、<code>(|T| T -&gt; T) &lt; (Int -&gt; Int)</code>と考えることができそうです。
その逆、<code>Int -&gt; Int</code>型である<code>iid</code>は<code>(|T| T -&gt; T)</code>型のパラメータ<code>f2</code>に代入できていませんが、<code>T -&gt; T</code>型のパラメータ<code>f1</code>に代入できているため、<code>(Int -&gt; Int) &lt; (T -&gt; T)</code>です。
よって、確かに<code>(|T| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)</code>となっています。</p>
<h2 id="全称型と依存型"><a class="header" href="#全称型と依存型">全称型と依存型</a></h2>
<p>依存型と全称型(多相関数型)はどんな関係があり、何が違うのでしょうか。
依存型は引数を取る型であり、全称型は(全称化するサブルーチンの)引数に任意性を与える型だと言えます。</p>
<p>重要なのは、閉じた全称型自体には型引数が存在しないというところです。例えば、多相関数型<code>|T| T -&gt; T</code>は多相関数 <strong>だけ</strong> を取る型であり、その定義は閉じています。その型引数<code>T</code>を使ったメソッド等の定義はできません。</p>
<p>Ergでは型自体も値であるため、引数を取る型、例えば関数型なども須らく依存型になります。つまり、多相関数型は全称型でかつ依存型でもあるといえます。</p>
<pre><code class="language-python">PolyFn = Patch(|T| T -&gt; T)
PolyFn.
    type self = T # NameError: cannot find 'T'
DepFn T = Patch(T -&gt; T)
DepFn.
    type self =
        log &quot;by DepFn&quot;
        T

assert (Int -&gt; Int).type() == Int # by DepFn
assert DepFn(Int).type() == Int # by DepFn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="部分型付け"><a class="header" href="#部分型付け">部分型付け</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/16_subtyping.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/16_subtyping.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>Ergでは、クラス同士の包含関係は比較演算子<code>&lt;</code>, <code>&gt;</code>で判定可能です。</p>
<pre><code class="language-python">Nat &lt; Int
Int &lt; Object
1.._ &lt; Nat
{1, 2} &gt; {1}
{=} &gt; {x = Int}
{I: Int | I &gt;= 1} &lt; {I: Int | I &gt;= 0}
</code></pre>
<p><code>&lt;:</code>演算子とは別の意味を持つことに注意してください。左辺のクラスが右辺の型のサブタイプであると宣言するもので、コンパイル時にのみ意味を持ちます。</p>
<pre><code class="language-python">C &lt;: T # T: StructuralType
f|D &lt;: E| ...

assert F &lt; G
</code></pre>
<p>また、多相型の部分型指定について、例えば<code>Self(R, O) &lt;: Add(R, O)</code>などの場合、<code>Self &lt;: Add</code>と指定することもできます。</p>
<h2 id="構造型クラスの型関係"><a class="header" href="#構造型クラスの型関係">構造型、クラスの型関係</a></h2>
<p>構造型は構造的型付けを実現するための型であり、構造が同じならば同じオブジェクトとみなされます。</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}

assert T == U
t: T = {i = 1}
assert t in T
assert t in U
</code></pre>
<p>対してクラスは記名的型付けを実現するための型であり、型およびインスタンスを構造的に比較することができません。</p>
<pre><code class="language-python">C = Class {i = Int}
D = Class {i = Int}

assert C == D # TypeError: cannot compare classes
c = C.new {i = 1}
assert c in C
assert not c in D
</code></pre>
<h2 id="サブルーチンの部分型付け"><a class="header" href="#サブルーチンの部分型付け">サブルーチンの部分型付け</a></h2>
<p>サブルーチンの引数、戻り値は、単一のクラスのみを取る。
すなわち、構造型やトレイトを関数の型として直接指定することはできない。
部分型指定を使って「その型のサブタイプである単一のクラス」として指定する必要がある。</p>
<pre><code class="language-python"># OK
f1 x, y: Int = x + y
# NG
f2 x, y: Add = x + y
# OK
# Aは何らかの具体的なクラス
f3&lt;A &lt;: Add&gt; x, y: A = x + y
</code></pre>
<p>サブルーチンの型推論もこのルールに従っている。サブルーチン中の変数で型が明示されていないものがあったとき、コンパイラはまずその変数がいずれかのクラスのインスタンスでないかチェックし、そうでない場合はスコープ中のトレイトの中から適合するものを探す。それでも見つからない場合、コンパイルエラーとなる。このエラーは構造型を使用することで解消できるが、無名型を推論するのはプログラマの意図しない結果である可能性があるため、プログラマが明示的に<code>Structural</code>で指定する設計となっている。</p>
<h2 id="クラスのアップキャスト"><a class="header" href="#クラスのアップキャスト">クラスのアップキャスト</a></h2>
<pre><code class="language-python">i: Int
i as (Int or Str)
i as (1..10)
i as {I: Int | I &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="キャスト"><a class="header" href="#キャスト">キャスト</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/17_type_casting.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/17_type_casting.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<h2 id="アップキャスト"><a class="header" href="#アップキャスト">アップキャスト</a></h2>
<p>Pythonはダックタイピングを採用する言語のため、キャストという概念はありません。アップキャストはする必要がなく、ダウンキャストも基本的にはありません。
しかしErgは静的に型付けされるため、キャストを行わなければいけない場合があります。
簡単な例では、<code>1 + 2.0</code>が挙げられます。Ergの言語仕様上は<code>+</code>(Int, Ratio)、すなわちInt(&lt;: Add(Ratio, Ratio))の演算は定義されていません。というのも、<code>Int &lt;: Ratio</code>であるため、1はRatioのインスタンスである1.0にアップキャストされるからです。</p>
<p><del>Erg拡張バイトコードはBINARY_ADDに型情報を加えますが、この際の型情報はRatio-Ratioとなります。この場合はBINARY_ADD命令がIntのキャストを行うため、キャストを指定する特別な命令は挿入されません。なので、例えば子クラスでメソッドをオーバーライドしても、親を型に指定すれば型強制(type coercion)が行われ、親のメソッドで実行されます(コンパイル時に親のメソッドを参照するように名前修飾が行われます)。コンパイラが行うのは型強制の妥当性検証と名前修飾のみです。ランタイムがオブジェクトをキャストすることはありません(現在のところ。実行最適化のためにキャスト命令が実装される可能性はあります)。</del></p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    # オーバーライドする際にはOverrideデコレータが必要
    @Override
    greet!() = print! &quot;Hello from Child&quot;

greet! p: Parent = p.greet!()

parent = Parent.new()
child = Child.new()

greet! parent # &quot;Hello from Parent&quot;
greet! child # &quot;Hello from Parent&quot;
</code></pre>
<p>この挙動はPythonとの非互換性を生むことはありません。そもそもPythonでは変数に型が指定されないので、いわば全ての変数が型変数で型付けされている状態となります。型変数は適合する最小の型を選ぶので、Ergで型を指定しなければPythonと同じ挙動が達成されます。</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    greet!() = print! &quot;Hello from Child&quot;

greet! some = some.greet!()

parent = Parent.new()
child = Child.new()

greet! parent # &quot;Hello from Parent&quot;
greet! child # &quot;Hello from Child&quot;
</code></pre>
<p>継承関係にある型同士では<code>.from</code>, <code>.into</code>が自動実装されるので、それを使うこともできます。</p>
<pre><code class="language-python">assert 1 == 1.0
assert Ratio.from(1) == 1.0
assert 1.into&lt;Ratio&gt;() == 1.0
</code></pre>
<h2 id="ダウンキャスト"><a class="header" href="#ダウンキャスト">ダウンキャスト</a></h2>
<p>ダウンキャストは一般に安全ではなく、変換方法も自明ではないため、代わりに<code>TryFrom.try_from</code>の実装で実現します。</p>
<pre><code class="language-python">IntTryFromFloat = Patch Int
IntTryFromFloat.
    try_from r: Float =
        if r.ceil() == r:
            then: r.ceil()
            else: Error &quot;conversion failed&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可変型"><a class="header" href="#可変型">可変型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/18_mut.md&amp;commit_hash=60dfd8580acb1a06dec36895295f92e823931a59"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/18_mut.md%26commit_hash%3D60dfd8580acb1a06dec36895295f92e823931a59" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>: この項の情報は古く、一部に間違いを含みます。</p>
</blockquote>
<p>Ergではデフォルトですべての型が不変型、すなわち内部状態を更新できないようになっています。
しかし可変な型ももちろん定義できます。可変型は<code>!</code>を付けて宣言します。</p>
<pre><code class="language-python">Person! = Class({name = Str; age = Nat!})
Person!.
    greet! ref! self = print! &quot;Hello, my name is \{self::name}. I am \{self::age}.&quot;
    inc_age! ref! self = self::name.update! old -&gt; old + 1
</code></pre>
<p>正確には、可変型・または可変型を含む複合型を基底型とする型は型名の最後に<code>!</code>を付けなくてはなりません。<code>!</code>を付けない型も同一の名前空間に存在してよく、別の型として扱われます。
上の例では、<code>.age</code>属性は可変で、<code>.name</code>属性は不変となっています。一つでも可変な属性がある場合、全体として可変型になります。</p>
<p>可変型はインスタンスを書き換えるプロシージャルメソッドを定義できますが、プロシージャルメソッドを持つからと言って可変型になるとは限りません。例えば配列型<code>[T; N]</code>には要素をランダムに選ぶ<code>sample!</code>メソッドが実装されていますが、これはもちろん配列に破壊的変更を加えたりはしません。</p>
<p>可変型オブジェクトの破壊的操作は、主に<code>.update!</code>メソッドを介して行います。<code>.update!</code>メソッドは高階プロシージャで、<code>self</code>に関数<code>f</code>を適用して更新します。</p>
<pre><code class="language-python">i = !1
i.update! old -&gt; old + 1
assert i == 2
</code></pre>
<p><code>.set!</code>メソッドは単に古い内容を捨てて新しい値に差し替えます。<code>.set! x = .update! _ -&gt; x</code>です。</p>
<pre><code class="language-python">i = !1
i.set! 2
assert i == 2
</code></pre>
<p><code>.freeze_map</code>メソッドは値を不変化して操作を行います。</p>
<pre><code class="language-python">a = [1, 2, 3].into [Nat; !3]
x = a.freeze_map a: [Nat; 3] -&gt; a.iter().map(i -&gt; i + 1).filter(i -&gt; i % 2 == 0).collect(Array)
</code></pre>
<p>多相不変型において型の型引数<code>T</code>は暗黙に不変型であると仮定されます。</p>
<pre><code class="language-python"># ImmutType &lt; Type
K T: ImmutType = Class ...
K! T: Type = Class ...
</code></pre>
<p>標準ライブラリでは、可変型<code>(...)!</code>型は不変型<code>(...)</code>型を基底としている場合が多いです。しかし<code>T!</code>型と<code>T</code>型に言語上特別な関連はなく、そのように構成しなくても構いません<a href="type/18_mut.html#1"><sup id="f1">1</sup></a>。</p>
<p><code>T = (...)</code>のとき単に<code>T! = (...)!</code>となる型<code>(...)</code>を単純構造型と呼びます。単純構造型は(意味論上)内部構造を持たない型ともいえます。
配列、タプル、セット、辞書、レコード型は単純構造型ではありませんが、Int型やStr型は単純構造型です。</p>
<p>以上の説明から、可変型とは自身が可変であるものだけでなく、内部に持つ型が可変であるものも含まれるということになります。
<code>{x: Int!}</code>や<code>[Int!; 3]</code>などの型は、内部のオブジェクトが可変であり、インスタンス自身が可変なわけではない内部可変型です。</p>
<h2 id="cell-t"><a class="header" href="#cell-t">Cell! T</a></h2>
<p>Intや配列などの不変型に対しては、既に可変型が定義されています。しかし、このような可変型はどのようにして定義されたのでしょうか？例えば、<code>{x = Int; y = Int}</code>型に対しては<code>{x = Int!; y = Int!}</code>型などが対応する可変型です。
しかし<code>Int!</code>型はどうやって<code>Int</code>型から作られたのでしょうか？あるいは<code>Int!</code>型はどのようにして<code>Int</code>型と関係付けられているのでしょうか？</p>
<p>それらに対する答えが<code>Cell!</code>型です。<code>Cell! T</code>型は<code>T</code>型オブジェクトを格納する箱のような型です。</p>
<pre><code class="language-python">IntOrStr = Inr or Str
IntOrStr! = Cell! IntOrStr
x = IntOrStr!.new 1
assert x is! 1 # `Int or Str` cannot compare with `Int` directly, so use `is!` (this compares object IDs) instead of `==`.
x.set! &quot;a&quot;
assert x is! &quot;a&quot;
</code></pre>
<p><code>Cell! T</code>型の重要な性質として、<code>T</code>型の部分型になるというものがあります。これより、<code>Cell! T</code>型のオブジェクトは<code>T</code>型のメソッドを全て使うことができます。</p>
<pre><code class="language-python"># definition of `Int!`
Int! = Cell! Int
...

i = !1
assert i == 1 # `i` is casted to `Int`
</code></pre>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> <code>T!</code>型と<code>T</code>型に言語上の特別な関係がないのは意図的な設計です。関連があったとすると、例えば名前空間に<code>T</code>/<code>T!</code>型が存在するときに別のモジュールから<code>T!</code>/<code>T</code>型を導入できなくなるなどの不都合が生じます。また、不変型に対し可変型は一意に定まりません。<code>T = (U, V)</code>という定義があった際、<code>(U!, V)</code>と<code>(U, V!)</code>という可変サブタイプが<code>T!</code>としてあり得えます。<a href="type/18_mut.html#f1">↩</a></span></p>

<div style="break-before: page; page-break-before: always;"></div><p>以降は更に高度な型システムを解説します。入門者の方はすべての項を読まなくても問題ありません。</p>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced.md&amp;commit_hash=d15cbbf7b33df0f78a575cff9679d84c36ea3ab1"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced.md%26commit_hash%3Dd15cbbf7b33df0f78a575cff9679d84c36ea3ab1" alt="badge" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="デフォルト引数付きの関数型"><a class="header" href="#デフォルト引数付きの関数型">デフォルト引数付きの関数型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/default_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/default_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>まず、デフォルト引数の使用例を見る。</p>
<pre><code class="language-python">f: (Int, Int, z := Int) -&gt; Int
f(x, y, z := 0) = x + y + z

g: (Int, Int, z := Int, w := Int) -&gt; Int
g(x, y, z := 0, w := 1) = x + y + z + w

fold: ((Int, Int) -&gt; Int, [Int], acc := Int) -&gt; Int
fold(f, [], acc) = acc
fold(f, arr, acc := 0) = fold(f, arr[1..], f(acc, arr[0]))
assert fold(f, [1, 2, 3]) == 6
assert fold(g, [1, 2, 3]) == 8
</code></pre>
<p><code>:=</code>以降の引数はデフォルト引数である。
部分型付け規則は以下の通り。</p>
<pre><code class="language-python">((X, y := Y) -&gt; Z) &lt;: (X -&gt; Z)
((X, y := Y, ...) -&gt; Z) &lt;: ((X, ...) -&gt; Z)
</code></pre>
<p>1番目は、デフォルト引数のある関数は、ない関数と同一視できる、という意味である。
2番目は、任意のデフォルト引数は省略できる、という意味である。</p>
<p>デフォルト引数の型は、引数を渡した場合と渡さなかった場合で変えることができる。
具体的には、<code>if</code>関数の型などが良い例である。</p>
<pre><code class="language-python">if: |T: Type, U: Type|(then: () -&gt; T, else: () -&gt; U := () -&gt; NoneType) -&gt; T or U
</code></pre>
<p><code>if</code>関数は、<code>else</code>引数が与えられなければ<code>T or NoneType</code>を返す。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="型消去"><a class="header" href="#型消去">型消去</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/erasure.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/erasure.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>型消去とは、型引数に<code>_</code>を指定し、その情報をあえて捨てることです。型消去は多相型を持つ言語の多くが併せて持つ機能ですが、Ergの文法に即して言えば型引数消去といった方が正確でしょう。</p>
<p>もっともよく見られる型消去された型の例は<code>[T, _]</code>でしょう。配列はコンパイル時にその長さが分からない場合もあります。例えば、コマンドライン引数を指す<code>sys.argv</code>は<code>[Str, _]</code>型です。コマンドライン引数の長さをErgのコンパイラは知りようがないため、長さに関する情報は諦めなくてはならないのです。
しかし、型消去された型は、されていない型のスーパータイプになる(e.g. <code>[T; N] &lt; [T; _]</code>)ため、より多くのオブジェクトを受け取れるようになります。
<code>[T; N]</code>型のオブジェクトはもちろん<code>[T; _]</code>型のメソッドを使用できますが、使用後<code>n</code>の情報は消去されます。長さが変わってしまっているかもしれないからです。長さが変わらないならばシグネチャで示さなくてはなりません。</p>
<pre><code class="language-python"># 配列の長さが変わらないことが保証される関数(sortなど)
f: [T; N] -&gt; [T; N]
# 長さが保障されない関数(filterなど)
g: [T; n] -&gt; [T; _]
</code></pre>
<p>型指定自体で<code>_</code>を使うとその型は<code>Object</code>までアップキャストされます。
型でない型引数(Int, Bool型など)の場合、<code>_</code>としたパラメータは未定義になります。</p>
<pre><code class="language-python">i: _ # i: Object
[_; _] == [Object; _] == Array
</code></pre>
<p>型消去は型指定の省略とは違います。一度型引数情報を消去してしまうと、再びアサーションしなければ情報は戻りません。</p>
<pre><code class="language-python">implicit = (1..5).iter().map(i -&gt; i * 2).to_arr()
explicit = (1..5).iter().map(i -&gt; i * 2).into(Array(Nat))
</code></pre>
<p>Rustでは以下のコードに対応します。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let partial = (1..6).iter().map(|i| i * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Ergでは型の部分省略はできず、代わりに高階カインド多相を使用します。</p>
<pre><code class="language-python"># collectはカインドを受け取る高階カインドのメソッド
hk = (1..5).iter().map(i -&gt; i * 2).collect(Array)
hk: Array(Int)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存在型"><a class="header" href="#存在型">存在型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/existential.md&amp;commit_hash=44d7784aac3550ba97c8a1eaf20b9264b13d4134"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/existential.md%26commit_hash%3D44d7784aac3550ba97c8a1eaf20b9264b13d4134" alt="badge" /></a></p>
<p>∀に対応する全称型があるならば、∃に対応する存在型があると考えるのが自然です。
存在型は難しいものではありません。そうと意識していないだけで、既にあなたは存在型を知っています。</p>
<pre><code class="language-python">T: Trait
f x: T = ...
</code></pre>
<p>上のトレイト<code>T</code>は存在型として使われています。
対して下の場合の<code>T</code>はトレイトでしかなく、<code>X</code>は全称型です。</p>
<pre><code class="language-python">f|X &lt;: T| x: X = ...
</code></pre>
<p>実際、存在型は全称型に置き換えられます。ではなぜ存在型などというものが存在するのでしょうか。
まず、上で見たように存在型は型変数を伴わないので、型指定をシンプルにできます。
また、型変数を除去できるので全称型ならランク2を超えてしまうような型も構成できます。</p>
<pre><code class="language-python">show_map f: (|T| T -&gt; T), arr: [Show; _] =
    arr.map x -&gt;
        y = f x
        log y
        y
</code></pre>
<p>しかし、見ればわかるように存在型は元の型を忘却・拡大してしまうので、戻り値の型を広げたくない場合などは全称型を使う必要があります。
逆に、引数として受け取るだけで戻り値に関係のない型は存在型で記述して構いません。</p>
<pre><code class="language-python"># id(1): Intが期待される
id|T|(x: T): T = x
# |S &lt;: Show|(s: S) -&gt; ()は冗長
show(s: Show): () = log s
</code></pre>
<p>ちなみに、クラスは存在型とは呼びません。予めその要素となるオブジェクトが定められているためです。
存在型はあるトレイトを満たすすべての型という意味で、実際にどのような型が代入されるか知るところではないのです。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="一般化代数的データ型"><a class="header" href="#一般化代数的データ型">一般化代数的データ型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/GADTs.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/GADTs.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>ErgはOr型をクラス化することで一般化代数的データ型(GADTs)を作成出来ます。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
Cons T = Class {head = T; rest = List T}, Impl := Unpack
List T: Type = Class(Nil T or Cons T)
List.
    nil|T|() = Self(T).new Nil(T).new()
    cons head, rest | T = Self(T).new Cons(T).new(head, rest)
    head self = match self:
        {head; ...}: Cons _ -&gt; head
        _: Nil -&gt; panic &quot;empty list&quot;
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil.head() # RuntimeError: &quot;empty list&quot;
</code></pre>
<p><code>List(T).nil() = ...</code>ではなく<code>List.nil|T|() = ...</code>としているのは、使用時に型指定が不要になるからです。</p>
<pre><code class="language-python">i = List.nil()
_: List Int = cons 1, i
</code></pre>
<p>ここで定義した<code>List T</code>はGADTsですが、素朴な実装であり、GADTsの真価を発揮していません。
例えば、上の<code>.head</code>メソッドはもし中身が空なら実行時エラーを出しますが、この検査はコンパイル時に行うことができます。</p>
<pre><code class="language-python">List: (Type, {&quot;Empty&quot;, &quot;Nonempty&quot;}) -&gt; Type
List T, &quot;Empty&quot; = Class(Impl := Phantom T)
List T, &quot;Nonempty&quot; = Class {head = T; rest = List(T, _)}, Impl := Unpack
List.
    nil|T|() = Self(T, &quot;Empty&quot;).new Nil(T).new()
    cons head, rest | T = Self(T, &quot;Nonempty&quot;).new {head; rest}
List(T, &quot;Nonempty&quot;).
    head {head; ...} = head
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil().head() # TypeError
</code></pre>
<p>巷でよく説明されるGADTsの例は、以上のように中身が空か否か型で判定できるリストです。
Ergではさらに精密化して、長さを持つリストを定義できます。</p>
<pre><code class="language-python">List: (Type, Nat) -&gt; Type
List T, 0 = Class(Impl := Phantom T)
List T, N = Class {head = T; rest = List(T, N-1)}, Impl := Unpack
List.
    nil|T|() = Self(T, 0).new Nil(T).new()
    cons head, rest | T, N = Self(T, N).new {head; rest}
List(_, N | N &gt;= 1).
    head {head; ...} = head
List(_, N | N &gt;= 2).
    pair {head = first; rest = {head = second; ...}} = [first, second]
{nil; cons; ...} = List

print! cons(1, cons(2, nil)).pair() # [1, 2]
print! cons(1, nil).pair() # TypeError
print! cons(1, nil).head() # 1
print! nil.head() # TypeError
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="キーワード引数付き関数型"><a class="header" href="#キーワード引数付き関数型">キーワード引数付き関数型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/keyword_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/keyword_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<pre><code class="language-python">h(f) = f(y: 1, x: 2)
h: |T: Type|((y: Int, x: Int) -&gt; T) -&gt; T
</code></pre>
<p>キーワード引数付き関数の部分型付け規則は以下の通り。</p>
<pre><code class="language-python">((x: T, y: U) -&gt; V) &lt;: ((T, U) -&gt; V)  # x, yは任意のキーワードパラメータ
((y: U, x: T) -&gt; V) &lt;: ((x: T, y: U) -&gt; V)
((x: T, y: U) -&gt; V) &lt;: ((y: U, x: T) -&gt; V)
</code></pre>
<p>これは、キーワード引数は消去ないし入れ替えができるということを意味する。
しかし、両者を同時に行うことはできない。
すなわち、<code>(x: T, y: U) -&gt; V</code>を<code>(U, T) -&gt; V</code>にキャストすることはできない。
なお、キーワード引数がつくのはトップレベルのタプル内のみで、配列やネストしたタプルでキーワード引数は付かない。</p>
<pre><code class="language-python">Valid: [T, U] -&gt; V
Invalid: [x: T, y: U] -&gt; V
Valid: (x: T, ys: (U,)) -&gt; V
Invalid: (x: T, ys: (y: U,)) -&gt; V
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="カインド"><a class="header" href="#カインド">カインド</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/kind.md&amp;commit_hash=44d7784aac3550ba97c8a1eaf20b9264b13d4134"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/kind.md%26commit_hash%3D44d7784aac3550ba97c8a1eaf20b9264b13d4134" alt="badge" /></a></p>
<p>Ergでは全てが型付けられている。型自体も例外ではない。「型の型」を表すのが <strong>カインド(種)</strong> である。例えば<code>1</code>が<code>Int</code>に属しているように、<code>Int</code>は<code>Type</code>に属している。<code>Type</code>は最もシンプルなカインドである <strong>原子カインド(Atomic kind)</strong> である。型理論的の記法では、<code>Type</code>は<code>*</code>に対応する。</p>
<p>カインドという概念で実用上重要なのは1項以上のカインド(多項カインド)である。1項のカインドは、例えば<code>Option</code>などがそれに属する。1項カインドは<code>Type -&gt; Type</code>と表される<a href="type/advanced/kind.html#1"><sup id="f1">1</sup></a>。<code>Array</code>や<code>Option</code>などの <strong>コンテナ</strong> は特に型を引数に取る多項カインドのことなのである。
<code>Type -&gt; Type</code>という表記が示す通り、実は<code>Option</code>は<code>T</code>という型を受け取って<code>Option T</code>という型を返す関数である。ただし、この関数は通常の意味での関数ではないため、1項カインド(unary kind)と普通は呼称される。</p>
<p>なお、無名関数演算子である<code>-&gt;</code>自体も型を受け取って型を返す場合カインドとみることができる。</p>
<p>また、原子カインドでないカインドは型ではないことに注意してほしい。<code>-1</code>は数値だが<code>-</code>は数値ではないのと同じように、<code>Option Int</code>は型だが<code>Option</code>は型ではない。<code>Option</code>などは型構築子と呼ばれることもある。</p>
<pre><code class="language-python">assert not Option in Type
assert Option in Type -&gt; Type
</code></pre>
<p>なので、以下のようなコードはエラーになる。
Ergではメソッドを定義できるのは原子カインドのみで、メソッドの第一引数以外の場所で<code>self</code>という名前を使えない。</p>
<pre><code class="language-python"># Kは単項の一種です
K: Type -&gt; Type
K T = Class ...
K.
    foo x = ... # OK、これはいわゆるスタティックメソッドのようなもの
    bar self, x = ... # TypeError: cannot define a method to a non-type object
K(T).
    baz self, x = ... # OK
</code></pre>
<p>2項以上のカインドの例としては<code>{T: U}</code>(: <code>(Type, Type) -&gt; Type</code>), <code>(T, U, V)</code>(: <code>(Type, Type, Type) -&gt; Type</code>), ...などが挙げられる。</p>
<p>0項のカインド<code>() -&gt; Type</code>も存在する。これは型理論的には原子カインドと同一視されることもあるが、Ergでは区別される。例としては<code>Class</code>などがある。</p>
<pre><code class="language-python">Nil = Class()
</code></pre>
<h2 id="カインドの包含関係"><a class="header" href="#カインドの包含関係">カインドの包含関係</a></h2>
<p>多項カインド間にも部分型関係、もとい部分カインド関係があります。</p>
<pre><code class="language-python">K T = ...
L = Inherit K
L &lt;: K
</code></pre>
<p>すなわち、任意の<code>T</code>に対し<code>L T &lt;: K T</code>ならば<code>L &lt;: K</code>であり、その逆も成り立ちます。</p>
<pre><code class="language-python">∀T. L T &lt;: K T &lt;=&gt; L &lt;: K
</code></pre>
<h2 id="高階カインド"><a class="header" href="#高階カインド">高階カインド</a></h2>
<p>高階カインド(higher-order kind)というものもある。これは高階関数と同じコンセプトのカインドで、カインド自体を受け取るカインドである。<code>(Type -&gt; Type) -&gt; Type</code>などが高階カインドである。高階カインドに属するオブジェクトを定義してみよう。</p>
<pre><code class="language-python">IntContainerOf K: Type -&gt; Type = K Int
assert IntContainerOf Option == Option Int
assert IntContainerOf Result == Result Int
assert IntContainerOf in (Type -&gt; Type) -&gt; Type
</code></pre>
<p>多項カインドの束縛変数はK, L, ...などと表されるのが通例である(KはKindのK)。</p>
<h2 id="セットカインド"><a class="header" href="#セットカインド">セットカインド</a></h2>
<p>型理論において、レコードという概念がある。これはErgのレコードとほぼ同じものである<a href="type/advanced/kind.html#2"><sup id="f2">2</sup></a>。</p>
<pre><code class="language-python"># これは`レコード`であり、型理論でいうところの`レコード`に相当するものである
{x = 1; y = 2}
</code></pre>
<p>レコードの値が全て型であるとき、それはレコード型といって型の一種であった。</p>
<pre><code class="language-python">assert {x = 1; y = 2} in {x = Int; y = Int}
</code></pre>
<p>レコード型はレコードを型付けする。察しの良い方は、レコード型を型付けする「レコードカインド」があるはずだと考えたかもしれない。実際に、それは存在する。</p>
<pre><code class="language-python">log Typeof {x = Int; y = Int} # {{x = Int; y = Int}}
</code></pre>
<p><code>{{x = Int; y = Int}}</code>のような型がレコードカインドである。これは特別な記法ではない。単に、<code>{x = Int; y = Int}</code>のみを要素に持つ列挙型である。</p>
<pre><code class="language-python">Point = {x = Int; y = Int}
Pointy = {Point}
</code></pre>
<p>レコードカインドの重要な特性は、<code>T: |T|</code>であり、<code>U &lt;: T</code>であるとき、<code>U: |T|</code>であるという点にある。
これは列挙型が実際には篩型の糖衣構文であることからもわかる。</p>
<pre><code class="language-python"># 通常のオブジェクトでは{c} == {X: T | X == c}だが、
# 型の場合等号が定義されない場合があるので|T| == {X | X &lt;: T}となる
{Point} == {P | P &lt;: Point}
</code></pre>
<p>型制約中の<code>U &lt;: T</code>は、実は<code>U: |T|</code>の糖衣構文である。
このような型のセットであるカインドは一般にセットカインドと呼ばれる。セットカインドはIteratorパターンでも現れる。</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<h2 id="多項カインドの型推論"><a class="header" href="#多項カインドの型推論">多項カインドの型推論</a></h2>
<pre><code class="language-python">Container K: Type -&gt; Type, T: Type = Patch K(T, T)
Container(K).
    f self = ...
Option T: Type = Patch T or NoneType
Option(T).
    f self = ...
Fn T: Type = Patch T -&gt; T
Fn(T).
    f self = ...
Fn2 T, U: Type = Patch T -&gt; U
Fn2(T, U).
    f self = ...

(Int -&gt; Int).f() # どちらが選択されるだろうか?
</code></pre>
<p>上の例で、メソッド<code>f</code>はどのパッチが選ばれるのだろうか。
素朴に考えて<code>Fn T</code>が選ばれるように思われるが、<code>Fn2 T, U</code>もあり得るし、<code>Option T</code>は<code>T</code>そのままを含むので任意の型が該当し、<code>Container K, T</code>も<code> `-&gt;`(Int, Int)</code>すなわち<code>Container(`-&gt;`, Int)</code>として<code>Int -&gt; Int</code>にマッチする。なので、上の4つのパッチすべてが選択肢としてありえる。</p>
<p>この場合、以下の優先基準に従ってパッチが選択される。</p>
<ul>
<li>任意の<code>K(T)</code>(e.g. <code>T or NoneType</code>)は<code>Type</code>よりも<code>Type -&gt; Type</code>に優先的にマッチする。</li>
<li>任意の<code>K(T, U)</code>(e.g. <code>T -&gt; U</code>)は<code>Type</code>よりも<code>(Type, Type) -&gt; Type</code>に優先的にマッチする。</li>
<li>3項以上のカインドについても同様の基準が適用される。</li>
<li>置換する型変数が少なく済むものが選択される。例えば<code>Int -&gt; Int</code>は<code>K(T, T)</code>(置換する型変数: K, T)や<code>T -&gt; U</code>(置換する型変数: T, U)よりも<code>T -&gt; T</code>(置換する型変数: T)が優先的にマッチする。</li>
<li>置換数も同じ場合は選択不能としてエラー。</li>
</ul>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> 型理論の記法では<code>*=&gt;*</code> <a href="type/advanced/kind.html#f1">↩</a></span></p>
<p><span id="2" style="font-size:x-small"><sup>2</sup> 可視性などの微妙な違いはある。<a href="type/advanced/kind.html#f2">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="マーカートレイト"><a class="header" href="#マーカートレイト">マーカートレイト</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/marker_trait.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/marker_trait.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>マーカートレイトは、要求属性のないトレイトである。すなわち、メソッドを実装せずにImplすることができる。
要求属性がないと意味がないように思えるが、そのトレイトに属しているという情報が登録されるので、パッチメソッドを使ったり、コンパイラが特別扱いしたりできる。</p>
<p>すべてのマーカートレイトは<code>Marker</code>トレイトに包摂される。
標準で提供されている<code>Light</code>はマーカートレイトの一種である。</p>
<pre><code class="language-python">Light = Subsume Marker
</code></pre>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat} and Light
</code></pre>
<pre><code class="language-python">M = Subsume Marker

MarkedInt = Inherit Int, Impl := M

i = MarkedInt.new(2)
assert i + 1 == 2
assert i in M
</code></pre>
<p>マーカークラスは<code>Excluding</code>引数で外すことも可能である。</p>
<pre><code class="language-python">NInt = Inherit MarkedInt, Impl := N, Excluding: M
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可変構造型"><a class="header" href="#可変構造型">可変構造型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/mut_struct.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/mut_struct.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p><code>T!</code>型は任意の<code>T</code>型オブジェクトを入れられて差し替え可能なボックス型であると説明した。</p>
<pre><code class="language-python">Particle! State: {&quot;base&quot;, &quot;excited&quot;} = Class(..., Impl := Phantom State)
Particle!.
    # このメソッドはStateを&quot;base&quot;から&quot;excited&quot;に遷移させる
    apply_electric_field!(ref! self(&quot;base&quot; ~&gt; &quot;excited&quot;), field: Vector) = ...
</code></pre>
<p><code>T!</code>型は、データの差し替えは行えるが、その構造を変えることはできない。
より現実のプログラムの振舞いに近い言い方をすれば、(ヒープ上の)サイズを変更できない。このような型を、不変構造(可変)型と呼ぶ。</p>
<p>実は、不変構造型では表すことのできないデータ構造が存在する。
例えば、可変長配列である。<code>[T; N]!</code>型は任意の<code>[T; N]</code>であるオブジェクトを入れることができるが、<code>[T; N+1]</code>型オブジェクトなどに差し替えることはできない。</p>
<p>すなわち、長さを変えられないのである。長さを変えるためには、型自体の構造を変化させなくてはならない。</p>
<p>それを実現するのが可変構造(可変)型である。</p>
<pre><code class="language-python">v = [Str; 0]!.new()
v.push! &quot;Hello&quot;
v: [Str; 1]!
</code></pre>
<p>可変構造型では可変化する型引数に<code>!</code>を付ける。上の場合は、<code>[Str; 0]!</code>型を<code>[Str; 1]!</code>型などに変更することができる。すなわち、長さを変更できる。
因みに、<code>[T; N]!</code>型は<code>Array!(T, N)</code>型の糖衣構文である。</p>
<p>可変構造型はもちろんユーザー定義も可能である。ただし、不変構造型とは構成法に関していくつか違いがあるので注意が必要である。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List! T, 0 = Inherit Nil T
List! T, N: Nat = Class {head = T; rest = List!(T, N-1)}
List!(T, N).
    push! ref! self(N ~&gt; N+1, ...), head: T =
        self.update! old -&gt; Self.new {head; old}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幽霊型"><a class="header" href="#幽霊型">幽霊型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/phantom.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/phantom.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>幽霊型は、コンパイラに注釈を与えるためだけに存在するマーカートレイトである。
幽霊型の使い方として、リストの構成をみる。</p>
<pre><code class="language-python">Nil = Class()
List T, 0 = Inherit Nil
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>このコードはエラーとなる。</p>
<pre><code class="language-python">3 | List T, 0 = Inherit Nil
                        ^^^
TypeConstructionError: since Nil does not have a parameter T, it is not possible to construct List(T, 0) with Nil
hint: use 'Phantom' trait to consume T
</code></pre>
<p>このエラーはつまり、<code>List(_, 0).new Nil.new()</code>とされたときに<code>T</code>の型推論ができないという文句である。Ergでは型引数を未使用のままにすることができないのである。
このような場合は何でもよいので<code>T</code>型を右辺で消費する必要がある。サイズが0の型、例えば長さ0のタプルならば実行時のオーバーヘッドもなく都合がよい。</p>
<pre><code class="language-python">Nil T = Class((T; 0))
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>このコードはコンパイルを通る。だが少しトリッキーで意図が分かりづらい上に、型引数が型のとき以外では使えない。</p>
<p>このようなときにちょうどよいのが幽霊型である。幽霊型はサイズ0の型を一般化した型である。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}

nil = Nil(Int).new()
assert nil.__size__ == 0
</code></pre>
<p><code>Phantom</code>が<code>T</code>型を保持する。しかし実際には<code>Phantom T</code>型のサイズは0であり、<code>T</code>型のオブジェクトを保持してはいない。</p>
<p>また、<code>Phantom</code>は型以外にも任意の型引数を消費することができる。以下の例では<code>State</code>という<code>Str</code>のサブタイプオブジェクトである型引数を<code>Phantom</code>が保持している。
この場合も、<code>state</code>はオブジェクトの実体に現れないハリボテの型変数である。</p>
<pre><code class="language-python">VM! State: {&quot;stopped&quot;, &quot;running&quot;}! = Class(..., Impl := Phantom! State)
VM!(&quot;stopped&quot;).
    start ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.do_something!()
        self::set_phantom!(&quot;running&quot;)
</code></pre>
<p><code>state</code>は<code>update_phantom!</code>メソッドか<code>set_phantom!</code>メソッドを介して更新する。
これは<code>Phantom!</code>(<code>Phantom</code>の可変版)の標準パッチが提供するメソッドで、使い方は可変型の<code>update!</code>, <code>set!</code>と同じである。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="射影型"><a class="header" href="#射影型">射影型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/projection.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/projection.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>射影型は、次のコードにおける<code>Self.AddO</code>のような型を表します。</p>
<pre><code class="language-python">Add R = Trait {
    .`_+_` = Self, R -&gt; Self.AddO
    .AddO = Type
}

AddForInt = Patch(Int, Impl := Add Int)
AddForInt.
    AddO = Int
</code></pre>
<p><code>Add(R)</code>型は何らかのオブジェクトとの加算が定義されている型といえます。メソッドは型属性であるべきなので、<code>+</code>の型宣言はインデント以下に記述します。
<code>Add</code>型のミソとなるのが<code>.AddO = Type</code>という宣言で、射影型である<code>.AddO</code>型の実体は、<code>Add</code>のサブタイプである型が持ちます。例えば、<code>Int.AddO = Int</code>, <code>Odd.AddO = Even</code>です。</p>
<pre><code class="language-python">assert Int &lt; Add
assert Int.AddO == Int
assert Odd &lt; Add
assert Odd.AddO == Even
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量化依存型"><a class="header" href="#量化依存型">量化依存型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/quantified_dependent.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/quantified_dependent.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Ergには量化型、依存型が存在します。すると当然、その二つを組み合わせた型を作ることができます。それが量化依存型です。</p>
<pre><code class="language-python">NonNullStr = |N: Nat| StrWithLen N | N != 0 # N: Nat; S: StrWithLen N; N != 0}と同じ
NonEmptyArray = |N: Nat| [_; N | N &gt; 0] # N: Nat; A: Array(_, N); N &gt; 0}と同じ
</code></pre>
<p>量化依存型の標準形は<code>K(A, ... | Pred)</code>です。<code>K</code>は型構築子、<code>A, B</code>は型引数、<code>Pred</code>は条件式です。</p>
<p>左辺値としての量化依存型は、元の型と同じモジュール内でのみメソッドを定義出来ます。</p>
<pre><code class="language-python">K A: Nat = Class ...
K(A).
    ...
K(A | A &gt;= 1).
    method ref! self(A ~&gt; A+1) = ...
</code></pre>
<p>右辺値としての量化依存型は、使用する型変数を型変数リスト(<code>||</code>)で宣言する必要がある。</p>
<pre><code class="language-python"># Tは具体的な型
a: |N: Nat| [T; N | N &gt; 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="共有参照"><a class="header" href="#共有参照">共有参照</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/shared.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/shared.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>共有参照は気をつけて扱わねばならない言語機能の一つです。
例えばTypeScriptでは以下のようなコードが型検査を通ってしまいます。</p>
<pre><code class="language-typescript">class NormalMember {}
class VIPMember extends NormalMember {}

let vip_area: VIPMember[] = []
let normal_area: NormalMember[] = vip_area

normal_area.push(new NormalMember())
console.log(vip_area) # [NormalMember]
</code></pre>
<p>一般会員がVIPエリアに侵入してしまっています。これは明らかなバグですが、何がいけなかったのでしょうか。
原因は共有参照の<a href="type/advanced/./variance.html">変性</a>です。<code>normal_area</code>は<code>vip_area</code>をコピーして作成されていますが、その際に型が変わってしまっています。
しかし<code>VIPMember</code>は<code>NormalMember</code>を継承しているので<code>VIPMember[] &lt;: NormalMember[]</code>となり、これは問題ないとされてしまっているのです。
<code>VIPMember[] &lt;: NormalMember[]</code>という関係は、不変オブジェクトの場合は問題ありません。しかし上のように破壊的な操作を行ってしまうと、綻びが発生します。</p>
<p>Ergでは、所有権システムのおかげでこのようなコードは弾かれます。</p>
<pre><code class="language-python">NormalMember = Class()
VIPMember = Class()

vip_area = [].into [VIPMember; !_]
normal_area: [NormalMember; !_] = vip_area

normal_area.push!(NormalMember.new())
log vip_area # OwnershipError: `vip_room` was moved to `normal_room`
</code></pre>
<p>しかし、オブジェクトの所有権が一箇所にしかない状態は不便である場合もあります。
そのためにErgは<code>SharedCell! T!</code>という型があり、これが共有状態を表します。</p>
<pre><code class="language-python">$p1 = SharedCell!.new(!1)
$p2 = $p1.mirror!()
$p3 = SharedCell!.new(!1)
# $p1 == $p2とすると、中身の型Int!の比較が行われる
assert $p1 == $p2
assert $p1 == $p3
# $p1と$p2が同じものを指しているかは、`.addr!`で確認する
assert $p1.addr!() == $p2.addr!()
assert $p1.addr!() != $p3.addr!()
$p1.add! 1
assert $p1 == 2
assert $p2 == 2
assert $p3 == 1
</code></pre>
<p><code>SharedCell!</code>型のオブジェクトは先頭に<code>$</code>を付ける必要があります。また、その性質上、定数にすることはできません。</p>
<p><code>SharedCell! T!</code>型は<code>T!</code>型のサブタイプでもあり、<code>T!</code>型のメソッドを呼び出すことができます。<code>SharedCell! T!</code>型固有のメソッドは<code>.addr!</code>と<code>.mirror!</code>、<code>.try_take</code>のみです。</p>
<p>重要な事実として、<code>SharedCell! T!</code>は非変(non-variant)です。すなわち、型引数の違いによる包含関係が定義されません。</p>
<pre><code class="language-python">$vip_area = SharedCell!.new([].into [VIPMember; !_])
$normal_area: SharedCell!([NormalMember; !_]) = $vip_area.mirror!() # TypeError: expected SharedCell!([NormalMember; !_]), but got SharedCell!([VIPMember; !_])
# hint: SharedCell!(T) is non-variant, which means it cannot have a supertype or a subtype.
</code></pre>
<p>しかし、以下のコードは問題ありません。最後の行では、型変換されたのは引数の<code>VIPMember</code>の方です。</p>
<pre><code class="language-python">$normal_area = SharedCell!.new([].into [NormalMember; !_])
$normal_area.push!(NormalMember.new()) # OK
$normal_area.push!(VIPMember.new()) # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="イテレータ"><a class="header" href="#イテレータ">イテレータ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/16_iterator.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/16_iterator.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>イテレータは、コンテナの要素を取り出すためのオブジェクトです。</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>このコードは0から9までの数字を出力します。
それぞれの数字(=Intオブジェクト)は<code>i</code>に代入され、<code>=&gt;</code>以下の動作(=<code>print! i</code>)が実行されます。このような繰り返し実行のことを <strong>イテレーション</strong> といいます。</p>
<p>ではここで<code>for!</code>プロシージャの型シグネチャを見てみましょう。</p>
<pre><code class="language-python">for!: |T: Type, I &lt;: Iterable T| (I, T =&gt; None) =&gt; None
</code></pre>
<p>第一引数は<code>Iterable</code>という型のオブジェクトを受け付けるようです。</p>
<p><code>Iterable</code>は<code>.Iterator</code>属性, <code>.iter</code>メソッドを要求メソッドに持つ型です。</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<p><code>.Iterator</code>属性の型<code>{Iterator}</code>はいわゆるセットカインド(カインドは<a href="./type/advanced/kind.html">こちら</a>で説明されています)です。</p>
<pre><code class="language-python">assert [1, 2, 3] in Iterable(Int)
assert 1..3 in Iterable(Int)
assert [1, 2, 3].Iterator == ArrayIterator
assert (1..3).Iterator == RangeIterator

log [1, 2, 3].iter() # &lt;ArrayIterator object&gt;
log (1..3).iter() # &lt;RangeIterator object&gt;
</code></pre>
<p><code>ArrayIterator</code>と<code>RangeIterator</code>はどちらも<code>Iterator</code>を実装するクラスで、<code>Array</code>, <code>Range</code>にイテレーション機能を与えるためだけに存在します。
このようなデザインパターンをコンパニオンクラス<a href="16_iterator.html#1"><sup id="f1">1</sup></a>と呼びます。
そして<code>IteratorImpl</code>パッチがイテレーション機能のコアです。<code>Iterator</code>は<code>.next</code>メソッド1つだけを要求し、<code>IteratorImpl</code>は実に数十個のメソッドを提供します。<code>ArrayIterator</code>や<code>RangeIterator</code>は<code>.next</code>メソッドを実装するだけで<code>IteratorImpl</code>の実装メソッドを使うことができるわけです。この利便性から、標準ライブラリでは多数のイテレータが実装されています。</p>
<pre><code class="language-mermaid">classDiagram
    class Array~T~ {
        ...
        iter() ArrayIterator~T~
    }
    class Range~T~ {
        ...
        iter() RangeIterator~T~
    }
    class Iterable~T~ {
        &lt;&lt;trait&gt;&gt;
        iter() Iterator~T~
    }
    Iterable~T~ &lt;|.. Array~T~: Impl
    Iterable~T~ &lt;|.. Range~T~: Impl
    class ArrayIterator~T~ {
        array: Array~T~
        next() T
    }
    class RangeIterator~T~ {
        range: Range~T~
        next() T
    }
    class Iterator~T~ {
        &lt;&lt;trait&gt;&gt;
        next() T
    }
    Iterator~T~ &lt;|.. ArrayIterator~T~: Impl
    Iterator~T~ &lt;|.. RangeIterator~T~: Impl

    Array &lt;-- ArrayIterator
    Range &lt;-- RangeIterator
</code></pre>
<p><code>Iterable</code>のような、トレイト(この場合は<code>Iterator</code>)を静的ディスパッチでありながら統一的に扱えるインターフェースを提供する型をコンパニオンクラスアダプターと呼びます。</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> このパターンには統一された名前がないようであるが、Rustでは[companion struct pattern](https://gist.github.com/qnighy/be99c2ece6f3f4b1248608a04e104b38# :~:text=%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82-,companion%20struct,-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%80%81%E3%81%9D%E3%81%AE)と呼ばれており、それになぞらえて命名した。<a href="16_iterator.html#f1">↩</a> </span></p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可変性"><a class="header" href="#可変性">可変性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/17_mutability.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/17_mutability.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>すでに見たように、Ergの変数は全て不変です。しかし、Ergのオブジェクトには可変性という概念があります。
以下のコードを例にします。</p>
<pre><code class="language-python">a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>上のコードは実際にはErgでは実現できません。再代入不可だからです。
このコードは実行できます。</p>
<pre><code class="language-python">b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
</code></pre>
<p><code>a, b</code>は、最終的な結果は同じように見えますが、その意味は大きく異なります。
<code>a</code>は<code>Nat</code>の配列を示す変数ですが、1行目と2行目では指しているオブジェクトが異なります。<code>a</code>という名前が同じだけで、中身はさし変わっているのです。</p>
<pre><code class="language-python">a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
</code></pre>
<p><code>id!</code>プロシージャはオブジェクトが存在するメモリ上のアドレスを返します。</p>
<p><code>b</code>は<code>Nat</code>の「動的」配列です。オブジェクトの中身は変わりますが、変数の指すものは同じです。</p>
<pre><code class="language-python">b = [1,2,3].into [Int; !3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
</code></pre>
<pre><code class="language-python">i = !0
if! True:
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
</code></pre>
<p><code>!</code>は <strong>可変化演算子(mutation operator)</strong> とよばれる特殊な演算子です。引数の不変オブジェクトを可変化して返します。
<code>!</code>がついたオブジェクトの振る舞いはカスタム可能です。</p>
<pre><code class="language-python">Point = Class {.x = Int; .y = Int}

# この場合.xは可変化し、yは不変のまま
Point! = Class {.x = Int!; .y = Int}
Point!.inc_x! ref! self = self.x.update! x -&gt; x+1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
</code></pre>
<h2 id="定数-1"><a class="header" href="#定数-1">定数</a></h2>
<p>変数と違い、すべてのスコープで同じものを指すのが定数です。
定数は<code>=</code>演算子で宣言します。</p>
<pre><code class="language-python">PI = 3.141592653589
match! x:
    PI =&gt; print! &quot;this is pi&quot;
</code></pre>
<p>定数はグローバル以下のすべてのスコープで同一であり、上書きができません。よって、<code>=</code>による再定義はできません。この制限により、パターンマッチで使うことができます。
<code>True</code>や<code>False</code>がパターンマッチで使えるのは、この２つが定数だからなのです。
また、定数は必ず不変オブジェクトを指しています。<code>Str!</code>型などは定数となれません。
組み込み型がすべて定数なのは、コンパイル時に決定されているべきだからです。定数でない型も生成可能ですが、型指定には使えず、単なるレコードのようにしか使えません。逆に言えば、型はコンパイル時に内容が決定されているレコードとも言えるでしょう。</p>
<h2 id="変数名前識別子シンボル"><a class="header" href="#変数名前識別子シンボル">変数、名前、識別子、シンボル</a></h2>
<p>ここで、Ergでの変数に関する用語を整理しておきましょう。</p>
<p>変数(Variable)はオブジェクトに名前(Name)をつけ、再利用できるようにする仕組み(またはその名前を指す)です。
識別子(Identifier)は変数を指定する文法要素です。
シンボルは名前を表すための文法要素、トークンです。</p>
<p>記号でない文字だけがシンボルであり、記号は演算子として識別子足り得ますが、シンボルとは呼びません。
例えば、<code>x</code>は識別子でシンボルです。<code>x.y</code>も識別子ですが、これはシンボルとは言いません。<code>x</code>と<code>y</code>はシンボルです。
また<code>x</code>が何のオブジェクトに紐づけられていなかったとしても、<code>x</code>は相変わらずSymbolかつIdentifierですが、Variableとは言いません。
<code>x.y</code>という形の識別子はフィールドアクセサと言います。
また、<code>x[y]</code>という形の識別子は添字アクセサと言います。</p>
<p>変数と識別子の違いですが、Ergの文法論的な意味での変数をいうのならば、実質この二つは同じです。
変数と識別子が等価でない言語は、C言語などがあげられます。C言語では、型や関数は変数に代入できません。int, mainは識別子ですが変数ではないのです(厳密には代入出来る場合もありますが、制約があります)。
しかし、Ergでは「全てがオブジェクト」です。関数や型は勿論、演算子でさえ変数に代入可能です。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="所有権システム"><a class="header" href="#所有権システム">所有権システム</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/18_ownership.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/18_ownership.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>ErgはPythonをホスト言語にした言語であるため、メモリ管理の方法はPythonの処理系に依存しています。
しかし、意味論的にはErgのメモリ管理はPythonのそれとは別物です。顕著な違いは、所有権システムと循環参照の禁止に現れています。</p>
<h2 id="所有権"><a class="header" href="#所有権">所有権</a></h2>
<p>ErgはRustから影響を受けた所有権システムを持っています。
Rustの所有権システムは一般的に難解だと言われていますが、Ergのそれは直感的になるよう簡略化されています。
Ergでは <strong>可変オブジェクト</strong> に所有権がついており、所有権を失った後はそのオブジェクトを参照できません。</p>
<pre><code class="language-python">v = [1, 2, 3].into [Int; !3]

push! vec, x =
    vec.push!(x)
    vec

# vの中身([1, 2, 3])の所有権はwに移る
w = push! v, 4
print! v # error: v was moved
print! w # [1, 2, 3, 4]
</code></pre>
<p>所有権の移動はオブジェクトをサブルーチンに渡したときなどに発生します。
渡した後も所有権をまだ持っていたい場合は、複製(cloning)、凍結(freeze)、または借用(borrowing)をする必要があります。
ただし、後述するように借用はできる場面が限られています。</p>
<h2 id="複製"><a class="header" href="#複製">複製</a></h2>
<p>オブジェクトを複製してその所有権を移します。実引数に<code>.clone</code>メソッドを適用することで行います。
複製したオブジェクトは複製元のオブジェクトと全く同一になりますが、互いに独立しているので、変更の影響は受けません。</p>
<p>複製はPythonのディープコピーに相当し、同一のオブジェクトをまるごと作り直すので、凍結・借用と比べて一般に計算コスト、メモリコストが高くなります。
オブジェクトを複製する必要があるようなサブルーチンは、「引数を消費する」サブルーチンといいます。</p>
<pre><code class="language-python">capitalize s: Str! =
    s.capitalize!()
    s

s1 = !&quot;hello&quot;
s2 = capitalize s1.clone()
log s2, s1 # !&quot;HELLO hello&quot;
</code></pre>
<h2 id="凍結"><a class="header" href="#凍結">凍結</a></h2>
<p>不変オブジェクトは複数の場所から参照できることを利用して、可変オブジェクトを不変オブジェクトに変換します。
これを凍結といいます。凍結は可変配列からイテレータを作るときなどで使われます。
可変配列からは直接イテレータを作ることができないので、不変配列に変換します。
配列を壊したくない場合は、<a href="./type/18_mut.html"><code>.freeze_map</code>メソッド</a>等を使います。</p>
<pre><code class="language-python"># イテレータが出す値の合計を計算する
sum|T &lt;: Add + HasUnit| i: Iterator T = ...

x = [1, 2, 3].into [Int; !3]
x.push!(4)
i = x.iter()
assert sum(i) == 10
y # この後もyは触れられる
</code></pre>
<h2 id="借用"><a class="header" href="#借用">借用</a></h2>
<p>借用は複製や凍結よりも低コストです。
以下のような単純な場合では、借用を行えます。</p>
<pre><code class="language-python">peek_str ref(s: Str!) =
    log s

s = !&quot;hello&quot;
peek_str s
</code></pre>
<p>借用した値は元のオブジェクトに対する <strong>参照</strong> と呼ばれます。
参照をまた別のサブルーチンに渡す「又貸し」はできますが、借りているだけなので消費することはできません。</p>
<pre><code class="language-python compile_fail">steal_str ref(s: Str!) =
    # log関数は引数を借用するだけなので、又貸しできる
    log s
    # discard関数は引数を消費するので、エラー
    discard s # OwnershipError: cannot consume a borrowed value
    # hint: use `clone` method
</code></pre>
<pre><code class="language-python compile_fail">steal_str ref(s: Str!) =
    # これもエラー(=は右辺を消費する)
    x = s # OwnershipError: cannot consume a borrowed value
    x
</code></pre>
<p>Ergの参照はRustより制約が強いです。参照は言語上第一級のオブジェクトですが、明示的に生成することはできず、<code>ref</code>/<code>ref!</code>によって実引数の渡し方として指定できるのみです。
これは、参照を配列に詰めたり参照を属性とするクラスを作ったりはできないということを意味します。</p>
<p>とはいえ、このような制約はそもそも参照のない言語では当たり前の仕様であり、そこまで不便となることはありません。</p>
<h2 id="循環参照"><a class="header" href="#循環参照">循環参照</a></h2>
<p>Ergでは意図せずメモリリークを起こせないように設計されており、メモリーチェッカーが循環参照を検知するとエラーを出します。ほとんどの場合、このエラーは弱参照<code>Weak</code>で解消できます。しかし、これでは巡回グラフなどの循環構造を持つオブジェクトを生成できないため、unsafe操作として循環参照を生成できるAPIを実装予定です。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可視性"><a class="header" href="#可視性">可視性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/19_visibility.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/19_visibility.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>Ergの変数には <strong>可視性</strong> という概念が存在します。
今まで見てきた変数は全て <strong>プライベート変数(非公開変数)</strong> と呼ばれます。これは、外部から不可視の変数です。
例えば<code>foo</code>モジュールで定義したプライベート変数は、別のモジュールから参照できないのです。</p>
<pre><code class="language-python"># foo.er
x = &quot;this is an invisible variable&quot;
</code></pre>
<pre><code class="language-python compile_fail"># bar.er
foo = import &quot;foo&quot;
foo.x # AttributeError: Module 'foo' has no attribute 'x' ('x' is private)
</code></pre>
<p>対して、 <strong>パブリック(公開)変数</strong> というものもあり、こちらは外部から参照できます。
公開変数は<code>.</code>を付けて定義します。</p>
<pre><code class="language-python"># foo.er
.x = &quot;this is a visible variable&quot;
</code></pre>
<pre><code class="language-python checker_ignore"># bar.er
foo = import &quot;foo&quot;
assert foo.x == &quot;this is a visible variable&quot;
</code></pre>
<p>非公開変数には何も付ける必要はないのですが、非公開であることを明示するために<code>::</code>または<code>self::</code>(型などなら<code>Self::</code>)を付けることもできます。またモジュールなら<code>module::</code>とすることもできます。</p>
<pre><code class="language-python">::x = &quot;this is a invisible variable&quot;
assert ::x == x
assert self::x == ::x
assert module::x == ::x
</code></pre>
<p>単なる逐次実行の文脈では、プライベート変数はローカル変数とほぼ同義です。内側のスコープからは参照することが出来ます。</p>
<pre><code class="language-python">::x = &quot;this is a private variable&quot;
y =
    x + 1 # 正確にはmodule::x
</code></pre>
<p><code>::</code>を使うことで、スコープ内の同名変数の区別ができます。
参照したい変数のスコープを左側に指定します。トップレベルの場合は<code>module</code>を指定します。
指定しなかった場合は通常の場合と同じく最も内側の変数が参照されます。</p>
<pre><code class="language-python">::x = 0
assert x == 0
y =
    ::x = 1
    assert x == 1
    z =
        ::x = 2
        assert ::x == 2
        assert z::x == 2
        assert y::x == 1
        assert module::x == 0
</code></pre>
<p>無名サブルーチンのスコープでは<code>self</code>で自身のスコープを指定します。</p>
<pre><code class="language-python">x = 0
f = x -&gt;
    log module::x, self::x
f 1 # 0 1
</code></pre>
<p><code>::</code>は、プライベートインスタンス属性にアクセスするという役割も持っています。</p>
<pre><code class="language-python">x = 0
C = Class {x = Int}
C.
    # トップレベルのxが参照される(module::xにするようwarningが出る)
    f1 self = x
    # インスタンス属性のxが参照される
    f2 self = self::x
</code></pre>
<h2 id="外部モジュールでの可視性"><a class="header" href="#外部モジュールでの可視性">外部モジュールでの可視性</a></h2>
<p>あるモジュールで定義されたクラスは、実は外部モジュールからでもメソッドを定義できます。</p>
<pre><code class="language-python"># foo.er
.Foo = Class()
.Bar = Class()
</code></pre>
<pre><code class="language-python"># bar.er
{Foo;} = import &quot;foo&quot;

Foo::
    private self = pass
Foo.
    public self = self::private()
</code></pre>
<pre><code class="language-python compile_fail">.f() =
    foo = Foo.new()
    foo.public()
    foo::private() # AttributeError
</code></pre>
<p>ただし、そのメソッドを使えるのはどちらもそのモジュール内でのみです。
外部で定義された非公開メソッドは、定義モジュール内でのみ<code>Foo</code>クラスのメソッドから参照できます。
公開メソッドはクラスの外には公開されますが、モジュール外までは公開されません。</p>
<pre><code class="language-python"># baz.er
{Foo;} = import &quot;foo&quot;

foo = Foo.new()
foo.public() # AttributeError: 'Foo' has no attribute 'public' ('public' is defined in module 'bar')
</code></pre>
<p>また、Re-exportする型にメソッドを定義することはできません。
インポート元のモジュールによってメソッドが見つかったり見つからなかったりといった混乱を防ぐためです。</p>
<pre><code class="language-python compile_fail"># bar.er
{.Foo;} = import &quot;foo&quot;

.Foo::
    private self = pass # Error
.Foo.
    public self = self::private() # Error
</code></pre>
<p>このようなことを行いたい場合は<a href="./type/07_patch.html">パッチ</a>を定義します。</p>
<pre><code class="language-python"># bar.er
{Foo;} = import &quot;foo&quot;

FooImpl = Patch Foo
FooImpl :=:
    private self = pass
FooImpl.
    public self = self::private()
</code></pre>
<pre><code class="language-python"># baz.er
{Foo;} = import &quot;foo&quot;
{FooImpl;} = import &quot;bar&quot;

foo = Foo.new()
foo.public()
</code></pre>
<h2 id="制限公開変数"><a class="header" href="#制限公開変数">制限公開変数</a></h2>
<p>変数の可視性は完全な公開・非公開しかないわけではありません。
制限付きで公開することもできます。</p>
<pre><code class="language-python"># foo.er
.record = {
    .a = {
        .(.record)x = 0
        .(module)y = 0
        .z = 0
    }
    _ = .a.x # OK
    _ = .a.y # OK
    _ = .a.z # OK
}

_ = .record.a.x # VisibilityError
_ = .record.a.y # OK
_ = .record.a.z # OK
</code></pre>
<pre><code class="language-python">foo = import &quot;foo&quot;
_ = foo.record.a.x # VisibilityError
_ = foo.record.a.y # VisibilityError
_ = foo.record.a.z # OK
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="命名規則"><a class="header" href="#命名規則">命名規則</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/20_naming_rule.md&amp;commit_hash=603abbd5fa3f8baffe0d614758e1a554705e6732"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/20_naming_rule.md%26commit_hash%3D603abbd5fa3f8baffe0d614758e1a554705e6732" alt="badge" /></a></p>
<p>変数を定数式として使いたい場合は、必ず大文字で始めます。二文字以降は小文字でもよいです。</p>
<pre><code class="language-python">i: Option Type = Int
match i:
    t: Type -&gt; log &quot;type&quot;
    None -&gt; log &quot;None&quot;
</code></pre>
<p>副作用のあるオブジェクトは、必ず<code>!</code>で終わります。プロシージャとプロシージャルメソッド、そして可変型です。
ただし、<code>Proc</code>型自体は可変型ではありません。</p>
<pre><code class="language-python"># Callable == Func or Proc
c: Callable = print!
match c:
    p! -&gt; log &quot;proc&quot; # 自明なので`: Proc`を省略できる
    f -&gt; log &quot;func&quot;
</code></pre>
<p>属性を外部に公開したい場合は、初めに<code>.</code>をつけて定義します。<code>.</code>を初めにつけなかった場合は非公開になります。混乱を避けるため同一のスコープ内で共存はできません。</p>
<pre><code class="language-python compile_fail">o = {x = 1; .x = 2} # SyntaxError: private and public variables with the same name cannot coexist
</code></pre>
<h2 id="リテラル識別子"><a class="header" href="#リテラル識別子">リテラル識別子</a></h2>
<p>以上の規則は、文字列をシングルクォート('')で囲むと回避できます。すなわち、プロシージャルオブジェクトも<code>!</code>をつけずに代入することができます。ただしこの場合、値が定数式でも定数とはみなされません。
このようにシングルクォートで囲まれた文字列による識別子をリテラル識別子といいます。
これは、Pythonなど他言語のAPI(FFI)を呼び出す際に使います。</p>
<pre><code class="language-python">bar! = pyimport(&quot;foo&quot;).'bar'
</code></pre>
<p>Ergでも有効な識別子の場合は、''で囲む必要はありません。</p>
<p>さらに、リテラル識別子中では記号も空白も入れることができるため、通常は識別子として使えない文字列を識別子として使うことができます。</p>
<pre><code class="language-python">'∂/∂t' y
'test 1: pass x to y'()
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="無名関数"><a class="header" href="#無名関数">無名関数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/21_lambda.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/21_lambda.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>無名関数は、関数オブジェクトを名付けずその場で生成するための文法です。</p>
<pre><code class="language-python"># `-&gt;`は無名関数演算子
# same as `f x, y = x + y`
f = (x, y) -&gt; x + y
# same as `g(x, y: Int): Int = x + y`
g = (x, y: Int): Int -&gt; x + y
</code></pre>
<p>引数が1つの場合は<code>()</code>を省略できます。</p>
<pre><code class="language-python">assert [1, 2, 3].map_collect(i -&gt; i + 1) == [2, 3, 4]
assert ((i, j) -&gt; [i, j])(1, 2) == [1, 2]
</code></pre>
<p>下の場合<code>0..9, (i -&gt; ...)</code>であって<code>(0..9, i) -&gt; ...</code>ではありません。
<code>-&gt;</code>は左辺に一つだけ引数をとります。複数の引数は一つのタプルとして受け取ります。</p>
<pre><code class="language-python">for 0..9, i: Int -&gt;
    ...
</code></pre>
<p>無名関数では、空白による構文解釈の差異が存在します。</p>
<pre><code class="language-python"># この場合は`T(() -&gt; Int)`と解釈される
i: T () -&gt; Int
# この場合は(U()) -&gt; Intと解釈される
k: U() -&gt; Int
</code></pre>
<p>無名関数は引数なしでも使えます。</p>
<pre><code class="language-python"># `=&gt;`は無名プロシージャ演算子
p! = () =&gt; print! &quot;`p!` was called&quot;
# `() -&gt;`, `() =&gt;`には`do`, `do!`という糖衣構文がある
# p! = do! print! &quot;`p!` was called&quot;
p!() # `p!` was called
</code></pre>
<p>引数なし関数は遅延初期化に使えます。</p>
<pre><code class="language-python">time = import &quot;time&quot;
date = import &quot;datetime&quot;
now = if! True:
    do!:
        time.sleep! 1000
        date.now!()
    do date.new(&quot;1970&quot;, &quot;1&quot;, &quot;1&quot;, &quot;00&quot;, &quot;00&quot;)
</code></pre>
<p>型付け、パターンマッチもできます。このため、<code>match</code>関数はほとんど無名関数の力で実現されています。
<code>match</code>関数の引数に与える無名関数は上から順番にトライされます。なので、上の方は特殊なケースを、下に行くほど一般的なケースを記述する必要があります。順番を間違えると(可能な限り)コンパイラがWarningを出します。</p>
<pre><code class="language-python">n = (Complex or Ratio or Int).sample!()
i = match n:
    PI -&gt; PI # 定数PIに等しい場合
    (i: 1..10) -&gt; i # 1~10のIntの場合
    (i: Int) -&gt; i # Intの場合
    (c: Complex) -&gt; c.real() # Complexの場合。Int &lt; Complexだが、フォールバックできる
    _ -&gt; panic &quot;cannot convert to Int&quot; # 以上のいずれにも該当しない場合。matchは全パターンを網羅していなくてはならない
</code></pre>
<p>エラーハンドリングも<code>?</code>か<code>match</code>を使用して行うのが一般的です。</p>
<pre><code class="language-python">res: ParseResult Int
match res:
    i: Int -&gt; i
    err: Error -&gt; panic err.msg

res2: Result Int, Error
match res2:
    ok: Not Error -&gt; log Typeof ok
    err: Error -&gt; panic err.msg
</code></pre>
<h2 id="無名多相関数"><a class="header" href="#無名多相関数">無名多相関数</a></h2>
<pre><code class="language-python"># same as id|T| x: T = x
id = |T| x: T -&gt; x
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="サブルーチンシグネチャ"><a class="header" href="#サブルーチンシグネチャ">サブルーチンシグネチャ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/22_subroutine.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/22_subroutine.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<h2 id="関数-1"><a class="header" href="#関数-1">関数</a></h2>
<pre><code class="language-python checker_ignore">some_func(x: T, y: U) -&gt; V
some_func: (T, U) -&gt; V
</code></pre>
<h2 id="プロシージャ-1"><a class="header" href="#プロシージャ-1">プロシージャ</a></h2>
<pre><code class="language-python checker_ignore">some_proc!(x: T, y: U) =&gt; V
some_proc!: (T, U) =&gt; V
</code></pre>
<h2 id="関数メソッド"><a class="header" href="#関数メソッド">関数メソッド</a></h2>
<p>メソッド型は、外部からは<code>Self</code>で指定できません。</p>
<pre><code class="language-python checker_ignore">.some_method(self, x: T, y: U) =&gt; ()
# Self.(T, U) =&gt; ()はselfの所有権を奪う
.some_method: (Ref Self, T, U) =&gt; ()
</code></pre>
<h2 id="プロシージャメソッド依存"><a class="header" href="#プロシージャメソッド依存">プロシージャメソッド(依存)</a></h2>
<p>以下で、型<code>T!</code>は<code>N: Nat</code>という型引数を取るとします。外部から指定する場合は型変数を使用します。</p>
<pre><code class="language-python checker_ignore">K!: Nat ~&gt; Type
# ~&gt;は適用前後の型引数の状態を示す(このときselfは可変参照でなくてはならない)
K!(N).some_method!: (self: Ref!(K! N ~&gt; N+X), X: Nat) =&gt; ()
</code></pre>
<p>注意として、<code>.some_method</code>の型は<code>|N, X: Nat| (self: Ref!(K! N ~&gt; N+X), {X}) =&gt; ()</code>となります。
<code>ref!</code>がついていない、すなわち適用後所有権が奪われるメソッドでは、型引数の遷移(<code>~&gt;</code>)を使用できません。</p>
<p>所有権が奪われる場合は以下のようになります。</p>
<pre><code class="language-python"># Nを使用しないならば_で省略できる
# .some_method!: |N, X: Nat| (T!(N+X), {X}) =&gt; T!(N+X)
.some_method!|N, X: Nat|(self: T!(N), X: Nat) =&gt; T!(N+X)
</code></pre>
<h2 id="演算子-1"><a class="header" href="#演算子-1">演算子</a></h2>
<p>``で囲むことで通常の関数と同じように定義できます。
<code>and</code>や<code>or</code>などの中置アルファベット演算子は囲むことで中置演算子として定義できます。</p>
<pre><code class="language-python">and(x, y, z) = x and y and z
`_+_`(x: Foo, y: Foo) = x.a + y.a
`-_`(x: Foo) = Foo.new(-x.a)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="クロージャ"><a class="header" href="#クロージャ">クロージャ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/23_closure.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/23_closure.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>Ergのサブルーチンには、外部変数を捕捉する「クロージャ」という機能があります。</p>
<pre><code class="language-python">outer = 1
f x = outer + x
assert f(1) == 2
</code></pre>
<p>不変オブジェクトと同じく、可変オブジェクトも捕捉できます。</p>
<pre><code class="language-python">sum = !0
for! 1..10, i =&gt;
    sum.add! i
assert sum == 45

p! x =
    sum.add! x
p!(1)
assert sum == 46
</code></pre>
<p>しかし、関数は可変オブジェクトを捕捉できないので注意が必要です。
仮に可変オブジェクトが関数内で参照できると、以下のようなコードが書けてしまいます。</p>
<pre><code class="language-python compile_fail"># !!! このコードは実際にはエラーになる !!!
i = !0
f x = i + x
assert f 1 == 1
i.add! 1
assert f 1 == 2
</code></pre>
<p>関数は同じ引数に対して同じ値を返すべきですが、その前提が破れてしまっています。
<code>i</code>は呼び出し時に初めて評価されることに注意してください。</p>
<p>関数定義時点での可変オブジェクトの内容がほしい場合は<code>.clone</code>を呼び出します。</p>
<pre><code class="language-python">i = !0
immut_i = i.clone().freeze()
f x = immut_i + x
assert f 1 == 1
i.add! 1
assert f 1 == 1
</code></pre>
<h2 id="可変状態の回避関数型プログラミング"><a class="header" href="#可変状態の回避関数型プログラミング">可変状態の回避、関数型プログラミング</a></h2>
<pre><code class="language-python"># Erg
sum = !0
for! 1..10, i =&gt;
    sum.add! i
assert sum == 45
</code></pre>
<p>上と同等のプログラムは、Pythonでは以下のように記述できます。</p>
<pre><code class="language-python checker_ignore"># Python
sum = 0
# 手続き型スタイル
for i in range(1, 10):
    sum += i
assert sum == 45
</code></pre>
<p>しかし、Ergではもっとシンプルな書き方を推奨します。
サブルーチンと可変オブジェクトを使って状態を持ち回す代わりに、関数を使用する状態を局所化するスタイルを使います。これは関数型プログラミングと呼ばれます。</p>
<pre><code class="language-python"># 関数型スタイル
sum = (1..10).sum()
assert sum == 45
</code></pre>
<p>上のコードは先程と全く同じ結果になりますが、こちらのほうが遥かにシンプルであることが見て取れます。</p>
<p><code>fold</code>関数を使用すれば、合計以外にも多様な操作を行うことができます。
<code>fold</code>はイテレータのメソッドで、各イテレーションごとに引数<code>f</code>を実行します。
結果を蓄積するカウンタの初期値は<code>init</code>で指定し、<code>acc</code>に蓄積されていきます。</p>
<pre><code class="language-python"># 初期値として0から始まり、結果として45が返る
sum = (1..10).fold(init: 0, f: (acc, i) -&gt; acc + i)
assert sum == 45
</code></pre>
<p>不変オブジェクトによるプログラミングで自然と簡潔な記述となるように、Ergは設計されています。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="モジュール"><a class="header" href="#モジュール">モジュール</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/24_module.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/24_module.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>Ergでは、ファイル自体を1つのレコードとみなすことができます。これをモジュールと呼びます。</p>
<pre><code class="language-python checker_ignore"># foo.er
.i = 1
</code></pre>
<pre><code class="language-python"># fooモジュールを定義するのはこのレコードを定義するのとほとんど同じ
foo = {.i = 1}
</code></pre>
<pre><code class="language-python checker_ignore"># bar.er
foo = import &quot;foo&quot;
print! foo # &lt;module 'foo'&gt;
assert foo.i == 1
</code></pre>
<p>モジュール型はレコード型でもあるので、分解代入が可能です。
モジュールの場合は最後の<code>...</code>を省略できます。</p>
<pre><code class="language-python"># same as {sin; cos; ...} = import &quot;math&quot;
{sin; cos} = import &quot;math&quot;
</code></pre>
<h2 id="モジュールの可視性"><a class="header" href="#モジュールの可視性">モジュールの可視性</a></h2>
<p>ファイルだけでなく、ディレクトリもモジュールとなりえます。
ただしデフォルトでErgはディレクトリをErgモジュールとしては認識しません。認識させるには、<code>__init__.er</code>という名前のファイルを作成します。
<code>__init__.er</code>はPythonの<code>__init__.py</code>と同じようなものです。</p>
<pre><code class="language-console">└─┬ bar
  └─ __init__.er
</code></pre>
<p>これで、<code>bar</code>ディレクトリはモジュールとして認識されます。<code>bar</code>内にあるファイルが<code>__init__.er</code>だけならばあまりディレクトリ構造にする意味はありませんが、複数のモジュールを束ねて一つのモジュールとしたい場合は便利です。すなわち、このような場合です。</p>
<pre><code class="language-console">└─┬ bar
  ├─ __init__.er
  ├─ baz.er
  └─ qux.er
</code></pre>
<p><code>bar</code>ディレクトリの外側からは以下のようにして使用できます。</p>
<pre><code class="language-python">bar = import &quot;bar&quot;

bar.baz.p!()
bar.qux.p!()
</code></pre>
<p><code>__init__.er</code>は単にディレクトリをモジュールとして機能させるだけのマーカーではなく、モジュールの可視性を制御する役割も持ちます。</p>
<pre><code class="language-python"># __init__.er

# `./`はカレントディレクトリを指す。なくても良い
.baz = import &quot;./baz&quot;
qux = import &quot;./qux&quot;

.f x =
    .baz.f ...
.g x =
    qux.f ...
</code></pre>
<p>外から<code>bar</code>モジュールをインポートしたとき、<code>baz</code>モジュールはアクセス可能ですが、<code>qux</code>モジュールはアクセス不可能になります。</p>
<h2 id="モジュールの循環参照"><a class="header" href="#モジュールの循環参照">モジュールの循環参照</a></h2>
<p>Ergでは、モジュール間の循環的な依存関係を定義することができます。</p>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;

print! bar.g 1
.f x = x
</code></pre>
<pre><code class="language-python"># bar.er
foo = &quot;foo &quot;をインポート

print! foo.f 1
.g x = x
</code></pre>
<p>しかし、手続き呼び出しによって作られた変数は、循環参照モジュールで定義することはできません。
これは、Ergが依存関係に従って定義の順番を並べ替えるからです。</p>
<pre><code class="language-python compile_fail"># foo.er
bar = import &quot;bar&quot;

print! bar.x
.x = g!(1) # ModuleError: 手続き呼び出しで作られた変数は、循環参照モジュールで定義できない
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;

print! foo.x
.x = 0
</code></pre>
<p>また、エントリポイントであるErgモジュール（すなわち <code>__name__ == &quot;__main__&quot;</code> であるモジュール）は循環参照の対象になることはできません。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="対象体"><a class="header" href="#対象体">対象体</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/25_object_system.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/25_object_system.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>変数に代入できる全てのデータです。<code>Object</code>クラスの持つ属性は以下の通りです。</p>
<ul>
<li><code>.__repr__</code>: オブジェクトの(リッチでない)文字列表現を返します</li>
<li><code>.__sizeof__</code>: オブジェクトのサイズ(ヒープ確保分含む)を返します</li>
<li><code>.__dir__</code>: オブジェクトの属性を一覧にして返します</li>
<li><code>.__hash__</code>: オブジェクトのハッシュ値を返します</li>
<li><code>.__getattribute__</code>: オブジェクトの属性を取得して返します</li>
<li><code>.clone</code>: オブジェクトのクローン(メモリ上に独立な実体を持つ)を生成して返します</li>
<li><code>.copy</code>: オブジェクトのコピー(メモリ上で同じものをさす)を返します</li>
</ul>
<h2 id="レコード-1"><a class="header" href="#レコード-1">レコード</a></h2>
<p>レコードリテラル(<code>{attr = value; ...}</code>)で生成されるオブジェクトです。
このオブジェクトは<code>.clone</code>や<code>.__sizeof__</code>などの基本的なメソッドを持ちます。</p>
<pre><code class="language-python">obj = {.x = 1}
assert obj.x == 1

obj2 = {...x; .y = 2}
assert obj2.x == 1 and obj2.y == 2
</code></pre>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>オブジェクトと関連付けられたオブジェクトです。特に自身(<code>self</code>)を暗黙の第一引数にとるサブルーチン属性はメソッド(method)と呼ばれます。</p>
<pre><code class="language-python"># private_attrには`.`がないことに注意が必要になる
record = {.public_attr = j; private_attr = 2; .method = self -&gt; self.i + 1}
record.public_attr == 2
record.private_attr # AttributeError: private_attr is private
assert record.method() == 3
</code></pre>
<h2 id="要素"><a class="header" href="#要素">要素</a></h2>
<p>特定の型に属するオブジェクト(e.g. <code>1</code>は<code>Int</code>型の要素)です。全てのオブジェクトは、少なくとも<code>{=}</code>型の要素です。
クラスの要素の場合特にインスタンス(Instance)と呼ぶこともあります。</p>
<h2 id="サブルーチン"><a class="header" href="#サブルーチン">サブルーチン</a></h2>
<p>関数またはプロシージャのインスタンスであるオブジェクトを示す(メソッドも含む)。サブルーチンを表すクラスは<code>Subroutine</code>です。
より一般に<code>.__call__</code>を実装するオブジェクトは<code>Callable</code>(呼び出し可能オブジェクト)と呼ばれます。</p>
<h2 id="呼び出し可能オブジェクト"><a class="header" href="#呼び出し可能オブジェクト">呼び出し可能オブジェクト</a></h2>
<p><code>.__call__</code>を実装するオブジェクトです。<code>Subroutine</code>のスーパークラスでもあります。</p>
<h2 id="型-2"><a class="header" href="#型-2">型</a></h2>
<p>要求属性を定義し、オブジェクトを共通化するオブジェクトです。
大きく分けて多相型(Polymorphic Type)と単相型(Monomorphic Type)の2つがあります。典型的な単相型は<code>Int</code>, <code>Str</code>などで、多相型には<code>Option Int</code>, <code>[Int; 3]</code>などがあります。
さらにオブジェクトの状態変更をするメソッドを定義した型は可変型(Mutable type)と呼ばれ、可変な属性に<code>!</code>をつける必要があります(e.g. 動的配列: <code>[T; !_]</code>)。</p>
<h2 id="クラス-1"><a class="header" href="#クラス-1">クラス</a></h2>
<p><code>.__new__</code>, <code>.__init__</code>メソッドなどを持つ型です。クラスベースのオブジェクト指向を実現します。</p>
<h2 id="関数-2"><a class="header" href="#関数-2">関数</a></h2>
<p>外部変数(静的変数除く)のread権限はありますが、外部変数のread/write権限がないサブルーチンです。つまり、外部に副作用を及ぼせません。
Ergの関数(Function)は副作用を許さないので、Pythonのそれとは定義が異なります。</p>
<h2 id="手続き"><a class="header" href="#手続き">手続き</a></h2>
<p>外部変数のread権限および<code>self</code>、静的変数のread/write権限があり、全てのサブルーチンの使用が許可されています。外部に副作用を及ぼせます。</p>
<h2 id="メソッド-1"><a class="header" href="#メソッド-1">メソッド</a></h2>
<p>第一引数に<code>self</code>を暗黙的にとるサブルーチンです。単なる関数/プロシージャとは別の型となっています。</p>
<h2 id="エンティティ"><a class="header" href="#エンティティ">エンティティ</a></h2>
<p>サブルーチンおよび型ではないオブジェクトです。
単相型エンティティ(<code>1</code>, <code>&quot;a&quot;</code>など)は値オブジェクト、多相型エンティティ(<code>[1, 2, 3], {&quot;a&quot;: 1}</code>)はコンテナオブジェクトとも呼ばれます。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="パターンマッチ論駁可能性"><a class="header" href="#パターンマッチ論駁可能性">パターンマッチ、論駁可能性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/26_pattern_matching.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/26_pattern_matching.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<h2 id="ergで使用可能なパターン"><a class="header" href="#ergで使用可能なパターン">Ergで使用可能なパターン</a></h2>
<h3 id="変数パターン"><a class="header" href="#変数パターン">変数パターン</a></h3>
<pre><code class="language-python check_ignore"># 基本的な代入
i = 1

# function
fn x = x + 1
# (無名)関数
fn = x -&gt; x + 1
</code></pre>
<h2 id="型宣言パターン"><a class="header" href="#型宣言パターン">型宣言パターン</a></h2>
<pre><code>i: Int = 1
j: {1, 2, 3} = 2
(k: Int, s: Str) = 1, &quot;a&quot;
</code></pre>
<h3 id="リテラルパターン"><a class="header" href="#リテラルパターン">リテラルパターン</a></h3>
<pre><code class="language-python check_ignore"># もし`i`がコンパイル時に1と判断できない場合は、TypeErrorが発生する。
# `_: {1} = i`を省略したもの
1 = i

# 簡易的なパターンマッチ
match x:
    1 -&gt; &quot;1&quot;
    2 -&gt; &quot;2&quot;
    _ -&gt; &quot;other&quot;

# フィボナッチ関数
fib 0 = 0
fib 1 = 1
fib n: Nat = fib n-1 + fib n-2
</code></pre>
<h3 id="定数パターン"><a class="header" href="#定数パターン">定数パターン</a></h3>
<pre><code class="language-python check_ignore">cond = False
match! cond:
    True =&gt; print! &quot;cond is True&quot;
    _ =&gt; print! &quot;cond is False&quot;

PI = 3.141592653589793
E = 2.718281828459045
num = PI
name = match num:
    PI -&gt; &quot;pi&quot;
    E -&gt; &quot;e&quot;
    _ -&gt; &quot;unnamed&quot;
</code></pre>
<h3 id="篩パターン-1"><a class="header" href="#篩パターン-1">篩パターン</a></h3>
<pre><code class="language-python check_ignore"># この２つは同じ
Array(T, N: {N | N &gt;= 3})
Array(T, N | N &gt;= 3)

f M, N | M &gt;= 0, N &gt;= 1 = ...
f(1, 0) # TypeError: N (2nd parameter) must be 1 or more
</code></pre>
<h3 id="破棄ワイルドカードパターン"><a class="header" href="#破棄ワイルドカードパターン">破棄(ワイルドカード)パターン</a></h3>
<pre><code class="language-python check_ignore">_ = 1
_: Int = 1
zero _ = 0
right(_, r) = r
</code></pre>
<p>文脈によって制約付けられていない場合、<code>_</code>は<code>Obj</code>型となる。</p>
<h3 id="可変長パターン"><a class="header" href="#可変長パターン">可変長パターン</a></h3>
<p>後述するタプル/配列/レコードパターンと組み合わせて使います。</p>
<pre><code class="language-python check_ignore">[i, ...j] = [1, 2, 3, 4]
assert j == [2, 3, 4]
first|T|(fst: T, ...rest: T) = fst
assert first(1, 2, 3) == 1
</code></pre>
<h3 id="タプルパターン"><a class="header" href="#タプルパターン">タプルパターン</a></h3>
<pre><code class="language-python check_ignore">(i, j) = (1, 2)
((k, l), _) = ((1, 2), (3, 4))
# ネストしていないなら()を省略可能(1, 2は(1, 2)として扱われる)
m, n = 1, 2

f(x, y) = ...
</code></pre>
<h3 id="配列パターン"><a class="header" href="#配列パターン">配列パターン</a></h3>
<pre><code class="language-python check_ignore">[i, j] = [1, 2]
[[k, l], _] = [[1, 2], [3, 4]]

length [] = 0
length [_, ...rest] = 1 + length rest
</code></pre>
<h4 id="レコードパターン"><a class="header" href="#レコードパターン">レコードパターン</a></h4>
<pre><code class="language-python check_ignore">record = {i = 1; j = 2; k = 3}
{j; ...} = record # i, kが解放される

{sin; cos; tan; ...} = import &quot;math&quot;
{*} = import &quot;math&quot; # 全てインポートする

person = {name = &quot;John Smith&quot;; age = 20}
age = match person:
    {name = &quot;Alice&quot;; _} -&gt; 7
    {_; age} -&gt; age

f {x: Int; y: Int} = ...
</code></pre>
<h3 id="データクラスパターン"><a class="header" href="#データクラスパターン">データクラスパターン</a></h3>
<pre><code class="language-python check_ignore">Point = Inherit {x = Int; y = Int}
p = Point::{x = 1; y = 2}
Point::{x; y} = p

Nil T = Class Impl := Phantom T
Cons T = Inherit {head = T; rest = List T}
List T = Enum Nil(T), Cons(T)
List T.
    first self =
        match self:
            Cons::{head; ...} -&gt; x
            _ -&gt; ...
    second self =
        match self:
            Cons::{rest=Cons::{head; ...}; ...} -&gt; head
            _ -&gt; ...
</code></pre>
<h3 id="列挙パターン"><a class="header" href="#列挙パターン">列挙パターン</a></h3>
<p>※実際には単なる列挙型</p>
<pre><code class="language-python check_ignore">match x:
    i: {1, 2} -&gt; &quot;one or two: \{i}&quot;
    _ -&gt; &quot;other&quot;
</code></pre>
<h3 id="範囲パターン"><a class="header" href="#範囲パターン">範囲パターン</a></h3>
<p>※実際には単なる区間型</p>
<pre><code class="language-python check_ignore"># 0 &lt; i &lt; 1
i: 0&lt;..&lt;1 = 0.5
# 1 &lt; j &lt;= 2
_: {[I, J] | I, J: 1&lt;..2} = [1, 2]
# 1 &lt;= i &lt;= 5
match i
    i: 1..5 -&gt; ...
</code></pre>
<h3 id="パターンではないものパターン化できないもの"><a class="header" href="#パターンではないものパターン化できないもの">パターンではないもの、パターン化できないもの</a></h3>
<p>パターンは一意に指定できるものです。この点においてパターンマッチは通常の条件分岐とは異なります。</p>
<p>条件の指定は一意ではありません。例えば、数<code>n</code>が偶数か判定する場合、<code>n % 2 == 0</code>とするのがオーソドックスですが、<code>(n / 2).round() == n / 2</code>とも書けます。
一意でない形式は、正しく作動するのか、別の条件と同等であるか自明ではありません。</p>
<h4 id="セット-1"><a class="header" href="#セット-1">セット</a></h4>
<p>セットのパターンはありません。なぜなら、セットは要素を一意に取り出す方法がないからです。
イテレータで取り出すことはできますが、順番は保証されません。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="内包表記"><a class="header" href="#内包表記">内包表記</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/27_comprehension.md&amp;commit_hash=44d7784aac3550ba97c8a1eaf20b9264b13d4134"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/27_comprehension.md%26commit_hash%3D44d7784aac3550ba97c8a1eaf20b9264b13d4134" alt="badge" /></a></p>
<p><code>[expr | (name &lt;- iterable)+ (predicate)*]</code>で配列、
<code>{expr | (name &lt;- iterable)+ (predicate)*}</code>でセット、
<code>{key: value | (name &lt;- iterable)+ (predicate)*}</code>でDictが作れます。</p>
<p><code>|</code>で区切られた節のうち最初の部分をレイアウト節(配置節)といい、2番目の部分をバインド節(束縛節)、3番目の部分をガード節(条件節)という。
ガード節は省略可能ですがバインド節は省略できず、バインド節より先にガード節を置くことはできません。</p>
<p>内包表記の例</p>
<pre><code class="language-python"># レイアウト節はi
# バインド節はi &lt;- [0, 1, 2]
assert [i | i &lt;- [0, 1, 2]] == [0, 1, 2]

# レイアウト節はi / 2
# バインド節はi &lt;- 0..2
assert [i / 2 | i &lt;- 0..2] == [0.0, 0.5, 1.0]

# レイアウト節は(i, j)
# バインド節はi &lt;- 0..2, j &lt;- 0..2
# ガード節は(i + j) % 2 == 0
assert [(i, j) | i &lt;- 0..2; j &lt;- 0..2; (i + j) % 2 == 0] == [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)]

assert {i % 2 | i &lt;- 0..9} == {0, 1}
assert {k: v | k &lt;- [&quot;a&quot;, &quot;b&quot;]; v &lt;- [1, 2]} == {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<p>Ergの内包表記はHaskellに影響を受けていますが、若干の違いがあります。
Haskellのリスト内包表記の場合、変数の順番は結果に違いをもたらしますが、Ergでは関係がありません。</p>
<pre><code class="language-haskell">-- Haskell
[(i, j) | i &lt;- [1..3], j &lt;- [3..5]] == [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
[(i, j) | j &lt;- [3..5], i &lt;- [1..3]] == [(1,3),(2,3),(3,3),(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>
<pre><code class="language-python"># Erg
assert [(i, j) | i &lt;- 1..&lt;3; j &lt;- 3..&lt;5] == [(i, j) | j &lt;- 3..&lt;5; i &lt;- 1..&lt;3]
</code></pre>
<p>この仕様はPythonのものと同じです。</p>
<pre><code class="language-python"># Python
assert [(i, j) for i in range(1, 3) for j in range(3, 5)] == [(i, j) for j in range(3, 5) for i in range(1, 3)]
</code></pre>
<h2 id="篩型-1"><a class="header" href="#篩型-1">篩型</a></h2>
<p>内包表記と似たものに、篩型があります。篩型は<code>{Name: Type | Predicate}</code>という形式で作られる型(列挙型)です。
篩型の場合、Nameは1つまででレイアウトは指定できず(ただしタプル型などにすれば複数の値は扱えます)、Predicateはコンパイル時計算できるもの、つまり定数式のみが指定できます。</p>
<pre><code class="language-python">Nat = {I: Int | I &gt;= 0}
# 述語式がandだけの場合、;で代替できる
# Nat2D = {(I, J): (Int, Int) | I &gt;= 0; J &gt;= 0}
Nat2D = {(I, J): (Int, Int) | I &gt;= 0 and J &gt;= 0}
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="展開代入"><a class="header" href="#展開代入">展開代入</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/28_spread_syntax.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/28_spread_syntax.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>分解代入において、変数の前に<code>...</code>を置くと残りの要素を全てその変数に展開できます。これを展開代入と呼びます。</p>
<pre><code class="language-python">[x, ...y] = [1, 2, 3]
assert x == 1
assert y == [2, 3]
x, ...y = (1, 2, 3)
assert x == 1
assert y == (2, 3)
</code></pre>
<h2 id="抽出代入"><a class="header" href="#抽出代入">抽出代入</a></h2>
<p>抽出代入は、モジュールやレコード内にある特定の属性をローカルに持ってくる際に便利な構文です。</p>
<pre><code class="language-python">{sin; cos; tan} = import &quot;math&quot;
</code></pre>
<p>このようにすると、以降はローカルで<code>sin, cos, tan</code>が使用できます。</p>
<p>レコードでも同じようにできます。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x; y} = record
</code></pre>
<p>全て展開したい場合は<code>{*} = record</code>とします。OCamlなどでいう<code>open</code>です。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{*} = record
assert x == 1 and y == 2
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="デコレータ修飾子"><a class="header" href="#デコレータ修飾子">デコレータ(修飾子)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/29_decorator.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/29_decorator.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>デコレータは型や関数に特定の状態や振る舞いを追加したり明示するために使われます。
デコレータの文法は以下の通りです。</p>
<pre><code class="language-python">@deco
X = ...
</code></pre>
<p>デコレータは、競合しない限り複数つけることができます。</p>
<p>デコレータは特別なオブジェクトではなく、その実体は単なる1引数関数です。デコレータは以下の疑似コードと等価です。</p>
<pre><code class="language-python">X = ...
X = deco(X)
</code></pre>
<p>Ergでは変数の再代入が出来ないので、上のようなコードは通りません。
単なる変数の場合は<code>X = deco(...)</code>と同じなのですが、インスタントブロックやサブルーチンの場合はそうすることができないので、デコレータが必要になってきます。</p>
<pre><code class="language-python">@deco
f x =
    y = ...
    x + y

# コードが横長になるのを防ぐこともできる
@LongNameDeco1
@LongNameDeco2
C = Class ...
</code></pre>
<p>以下に、頻出の組み込みデコレータを紹介します。</p>
<h2 id="inheritable"><a class="header" href="#inheritable">Inheritable</a></h2>
<p>定義する型が継承可能クラスであることを示します。引数<code>scope</code>に<code>&quot;public&quot;</code>を指定すると、外部モジュールのクラスでも継承できるようになります。デフォルトでは<code>&quot;private&quot;</code>になっており、外部からは継承できません。</p>
<h2 id="final"><a class="header" href="#final">Final</a></h2>
<p>メソッドをオーバーライド不能にします。クラスに付けると継承不能クラスになりますが、デフォルトなので意味はありません。</p>
<h2 id="override"><a class="header" href="#override">Override</a></h2>
<p>属性をオーバーライドする際に使用します。Ergではデフォルトで基底クラスと同じ属性を定義しようとするとエラーになります。</p>
<h2 id="impl"><a class="header" href="#impl">Impl</a></h2>
<p>引数のトレイトを実装することを示します。</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
Sub = Trait {
    .`_-_` = Self.(Self) -&gt; Self
}

C = Class({i = Int}, Impl := Add and Sub)
C.
    @Impl Add
    `_+_` self, other = C.new {i = self::i + other::i}
    @Impl Sub
    `_-_` self, other = C.new {i = self::i - other::}
</code></pre>
<h2 id="attach"><a class="header" href="#attach">Attach</a></h2>
<p>トレイトにデフォルトで付属するアタッチメントパッチを指定します。
これによって、Rustのトレイトと同じ挙動を再現できます。</p>
<pre><code class="language-python"># foo.er
Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
@Attach AddForInt, AddForOdd
ClosedAdd = Subsume Add(Self)

AddForInt = Patch(Int, Impl := ClosedAdd)
AddForInt.AddO = Int
AddForOdd = Patch(Odd, Impl := ClosedAdd)
AddForOdd.AddO = Even
</code></pre>
<p>こうすると、他のモジュールからトレイトをインポートした際に、アタッチメントパッチが自動で適用されます。</p>
<pre><code class="language-python"># 本来IntIsBinAdd, OddIsBinAddも同時にインポートする必要があるが、アタッチメントパッチなら省略できる
{BinAdd; ...} = import &quot;foo&quot;

assert Int.AddO == Int
assert Odd.AddO == Even
</code></pre>
<p>内部的にはトレイトの<code>.attach</code>メソッドを使って結びつけているだけです。コンフリクトする場合はトレイトの<code>.detach</code>メソッドで外すことができます。</p>
<pre><code class="language-python">@Attach X
T = Trait ...
assert X in T.attaches
U = T.detach(X).attach(Y)
assert X not in U.attaches
assert Y in U.attaches
</code></pre>
<h2 id="deprecated"><a class="header" href="#deprecated">Deprecated</a></h2>
<p>変数の仕様が古く非推奨であることを示します。</p>
<h2 id="test"><a class="header" href="#test">Test</a></h2>
<p>テスト用サブルーチンであることを示します。テスト用サブルーチンは<code>erg test</code>コマンドで実行されます。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="エラーハンドリングシステム"><a class="header" href="#エラーハンドリングシステム">エラーハンドリングシステム</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/30_error_handling.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/30_error_handling.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>主にResult型を使用します。
ErgではError型オブジェクトを捨てる(トップレベルで対応しない)とエラーが発生します。</p>
<h2 id="例外pythonとの相互運用"><a class="header" href="#例外pythonとの相互運用">例外、Pythonとの相互運用</a></h2>
<p>Ergは例外機構(Exception)を持ちません。Pythonの関数をインポートする際は</p>
<ul>
<li>戻り値を<code>T or Error</code>型とする</li>
<li><code>T or Panic</code>型(実行時エラーを出す可能性がある)とする</li>
</ul>
<p>の2つの選択肢があり、<code>pyimport</code>ではデフォルトで後者となる。前者としてインポートしたい場合は、
<code>pyimport</code>の<code>exception_type</code>で<code>Error</code>を指定する(<code>exception_type: {Error, Panic}</code>)。</p>
<h2 id="例外とresult型"><a class="header" href="#例外とresult型">例外とResult型</a></h2>
<p><code>Result</code>型はエラーかもしれない値を表現します。<code>Result</code>によるエラーハンドリングはいくつかの点で例外機構よりも優れています。
まず第一に、サブルーチンがエラーを出すかもしれないと型定義から分かり、実際に使用するときも一目瞭然です。</p>
<pre><code class="language-python checker_ignore"># Python
try:
    x = foo().bar()
    y = baz()
    qux()
except e:
    print(e)
</code></pre>
<p>上の例では、例外がどの関数から送出されたものなのか、このコードだけでは分かりません。関数定義まで遡っても、その関数が例外を出すかを判別するのは難しいです。</p>
<pre><code class="language-python"># Erg
try!:
    do!:
        x = foo!()?.bar()
        y = baz!()
        qux!()?
    e =&gt;
        print! e
</code></pre>
<p>反対に、こちらの例では<code>foo!</code>と<code>qux!</code>がエラーを出しうるとわかります。
正確には<code>y</code>も<code>Result</code>型である可能性がありますが、中の値を使用するためにはいずれ対処しなくてはなりません。</p>
<p><code>Result</code>型を使用するメリットはそれだけではありません。<code>Result</code>型はスレッドセーフでもあります。これは、エラー情報を並列実行中に(容易に)受け渡しできるということを意味します。</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p><code>Error</code>/<code>Result</code>型単体では副作用が発生しないので、例外と違い送出場所などの情報(Context、文脈)を持てませんが、<code>.context</code>メソッドを使えば<code>Error</code>オブジェクトに情報を付加できます。<code>.context</code>メソッドは<code>Error</code>オブジェクト自身を消費して新しい<code>Error</code>オブジェクトを作るタイプのメソッドです。チェイン可能であり、複数のコンテクストを保持できます。</p>
<pre><code class="language-python checker_ignore">f() =
    todo() \
        .context &quot;to be implemented in ver 1.2&quot; \
        .context &quot;and more hints ...&quot;

f()
# Error: not implemented yet
# hint: to be implemented in ver 1.2
# hint: and more hints ...
</code></pre>
<p>なお、<code>.msg</code>や<code>.kind</code>などの<code>Error</code>の属性は副次的なものではないのでcontextではなく、最初に生成されたときのまま上書きできません。</p>
<h2 id="スタックトレース"><a class="header" href="#スタックトレース">スタックトレース</a></h2>
<p><code>Result</code>型はその利便性から他言語でも多く取り入れられていますが、例外機構と比較してエラーの発生元がわかりにくくなるというデメリットがあります。
そこで、Ergでは<code>Error</code>オブジェクトに<code>.stack</code>という属性を持たせており、擬似的に例外機構のようなスタックトレースを再現しています。
<code>.stack</code>は呼び出し元オブジェクトの配列です。Errorオブジェクトは<code>return</code>(<code>?</code>によるものも含む)されるたびにその呼出元サブルーチンを<code>.stack</code>に積んでいきます。
そして<code>return</code>ができないコンテクストで<code>?</code>されるなり<code>.unwrap</code>されるなりすると、トレースバックを表示しながらパニックします。</p>
<pre><code class="language-python checker_ignore">f x =
    ...
    y = foo.try_some(x)?
    ...

g x =
    y = f(x)?
    ...

i = g(1)?
# Traceback (most recent call first):
#    ...
#    Foo.try_some, line 10, file &quot;foo.er&quot;
#    10 | y = foo.try_some(x)?
#    module::f, line 23, file &quot;foo.er&quot;
#    23 | y = f(x)?
#    module::g, line 40, file &quot;foo.er&quot;
#    40 | i = g(1)?
# Error: ...
</code></pre>
<h2 id="パニック"><a class="header" href="#パニック">パニック</a></h2>
<p>Ergには回復不能なエラーへの対処として <strong>パニッキング</strong> という機構も存在します。
回復不能なエラーとは、例えばソフト/ハードウェアの不具合など外的要因によるエラーや、それ以上コードを実行し続けても意味がないほど致命的なエラー、あるいはプログラム作成者の想定だにしないエラーなどです。これが発生した場合、プログラマの努力によって正常系に復帰させることができないため、その場でプログラムを終了させます。これを「パニックさせる」といいます。</p>
<p>パニックは<code>panic</code>関数で行います。</p>
<pre><code class="language-python checker_ignore">panic &quot;something went wrong!&quot;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="パイプライン演算子"><a class="header" href="#パイプライン演算子">パイプライン演算子</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/31_pipeline.md&amp;commit_hash=5d4a2ebc57e34f3c679eb3dfe140dd4229dca7f6"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/31_pipeline.md%26commit_hash%3D5d4a2ebc57e34f3c679eb3dfe140dd4229dca7f6" alt="badge" /></a></p>
<p>パイプライン演算子は、次のように使います。</p>
<pre><code class="language-python">assert f(g(x)) == (x |&gt; g() |&gt; f())
assert f(g(x, y)) == (x |&gt; g(y) |&gt; f())
</code></pre>
<p>つまり、<code>Callable(object)</code>という順序を<code>object |&gt; Callable()</code>に変えられます。
パイプライン演算子はメソッドに対しても使えます。メソッドの場合、<code>object.method(args)</code>が<code>object |&gt;.method(args)</code>と変わります。
単に<code>|&gt;</code>が増えただけにも見えるが、結合強度が低めなので<code>()</code>の量を減らせる場合があります。</p>
<pre><code class="language-python">rand = -1.0..1.0 |&gt;.sample!()
log rand # 0.2597...

1+1*2 |&gt;.times do log(&quot;a&quot;, end := &quot;&quot;) # aaa

evens = 1..100 |&gt;.iter() |&gt;.filter i -&gt; i % 2 == 0 |&gt;.collect Array
# パイプライン演算子を使わずに実装する場合、
_evens = (1..100).iter().filter(i -&gt; i % 2 == 0).collect(Array)
# または
__evens = 1..100 \
    .iter() \
    .filter i -&gt; i % 2 == 0 \
    .collect Array
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="pythonとの連携"><a class="header" href="#pythonとの連携">Pythonとの連携</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/32_integration_with_Python.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/32_integration_with_Python.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<h2 id="pythonへのexport"><a class="header" href="#pythonへのexport">Pythonへのexport</a></h2>
<p>Ergスクリプトをコンパイルすると.pycファイルが生成されますが、これは単純にPythonのモジュールとして読み込むことができます。
ただし、Erg側で非公開に設定した変数はPythonからもアクセスできません。</p>
<pre><code class="language-python"># foo.er
.public = &quot;this is a public variable&quot;
private = &quot;this is a private variable&quot;
</code></pre>
<pre><code class="language-console">erg --compile foo.er
</code></pre>
<pre><code class="language-python checker_ignore">import foo

print(foo.public)
print(foo.private) # AttributeError:
</code></pre>
<h2 id="pythonからのimport"><a class="header" href="#pythonからのimport">Pythonからのimport</a></h2>
<p>Pythonから取り込んだオブジェクトはデフォルトですべて<code>Object</code>型になります。このままでは比較もできないので、型の絞り込みを行う必要があります。</p>
<h2 id="標準ライブラリの型指定"><a class="header" href="#標準ライブラリの型指定">標準ライブラリの型指定</a></h2>
<p>Python標準ライブラリにあるAPIはすべてErg開発チームにより型が指定されています。</p>
<pre><code class="language-python">time = pyimport &quot;time&quot;
time.sleep! 1
</code></pre>
<h2 id="ユーザースクリプトの型指定"><a class="header" href="#ユーザースクリプトの型指定">ユーザースクリプトの型指定</a></h2>
<p>Pythonの<code>foo</code>モジュールに型を付ける<code>foo.d.er</code>ファイルを作成します。
Python側でのtype hintは100%の保証にならないので無視されます。</p>
<pre><code class="language-python"># foo.py
X = ...
def bar(x):
    ...
def baz():
    ...
class C:
    ...
</code></pre>
<pre><code class="language-python"># foo.d.er
.X: Int
.bar!: Int =&gt; Int
.foo! = baz!: () =&gt; Int # aliasing
.C!: Class
</code></pre>
<p><code>d.er</code>内では宣言と定義(エイリアシング)以外の構文は使えません。</p>
<p>Pythonの関数はすべてプロシージャとして、クラスはすべて可変クラスとしてしか登録できないことに注意してください。</p>
<pre><code class="language-python">foo = pyimport &quot;foo&quot;
assert foo.bar!(1) in Int
</code></pre>
<p>これは、実行時に型チェックを行うことで型安全性を担保しています。チェック機構は概念的には以下のように動作します。</p>
<pre><code class="language-python">decl_proc proc!: Proc, T =
    x =&gt;
        assert x in T.Input
        y = proc!(x)
        assert y in T.Output
        y
</code></pre>
<p>これは実行時オーバーヘッドとなるので、PythonスクリプトをErgの型システムで静的に型解析するプロジェクトが計画されています。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="パッケージシステム"><a class="header" href="#パッケージシステム">パッケージシステム</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/33_package_system.md&amp;commit_hash=20aa4f02b994343ab9600317cebafa2b20676467"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/33_package_system.md%26commit_hash%3D20aa4f02b994343ab9600317cebafa2b20676467" alt="badge" /></a></p>
<p>Ergのパッケージはアプリケーションであるappパッケージとライブラリであるlibパッケージに大別できます。
appパッケージのエントリポイントは<code>src/app.er</code>です。<code>app.er</code>内に定義された<code>main</code>関数が実行されます。
libパッケージのエントリポイントは<code>src/lib.er</code>です。パッケージをインポートすることは<code>lib.er</code>をインポートすることと等価になります。</p>
<p>パッケージにはモジュールという下位構造があります。Ergにおいてモジュールとはすなわち、Ergファイルもしくはそれで構成されたディレクトリです。外部のErgファイル/ディレクトリはモジュールオブジェクトとして操作可能な対象になるのです。</p>
<p>ディレクトリをモジュールとして認識させるには、ディレクトリ内に<code>__init__.er</code>ファイルを置く必要があります。
これはPythonの<code>__init__.py</code>と同じようなものです。</p>
<p>例として、以下のようなディレクトリ構成を考えてみましょう。</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  └─┬ bar
    ├─ __init__.er
    ├─ baz.er
    └─ qux.er
</code></pre>
<p><code>app.er</code>では<code>foo</code>モジュールと<code>bar</code>モジュールをインポートできます。<code>bar</code>ディレクトリがモジュールとして認識できるのは<code>__init__.er</code>ファイルがあるためです。
<code>foo</code>モジュールはファイルからなるモジュールで、<code>bar</code>モジュールはディレクトリからなるモジュールです。<code>bar</code>モジュールはさらに<code>baz</code>, <code>qux</code>モジュールを内部に持ちます。
このモジュールは単に<code>bar</code>モジュールの属性であり、<code>app.er</code>からは以下のようにアクセスできます。</p>
<pre><code class="language-python"># app.er
foo = import &quot;foo&quot;
bar = import &quot;bar&quot;
baz = bar.baz
# または`baz = import &quot;bar/baz&quot;`

main args =
    ...
</code></pre>
<p>サブモジュールにアクセスするための区切り文字が<code>/</code>であることに注意してください。これは、<code>bar.baz.er</code>のようなファイル名があり得るためです。
しかしこのようなファイル名は推奨されません。Ergでは<code>.er</code>の直前の識別子、プレフィックスが意味を持つためです。
例えば、テスト用のモジュールです。<code>.test.er</code>で終わるファイルは(ホワイトボックス)テスト用のモジュールであり、テスト実行時に<code>@Test</code>でデコレーションされたサブルーチンが実行されます。</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  └─ foo.test.er
</code></pre>
<pre><code class="language-python"># app.er
foo = import &quot;foo&quot;

main args =
    ...
</code></pre>
<p>また、<code>__init__.er</code>内でre-importされていないモジュールはプライベートモジュールであり、同一ディレクトリ内のモジュールからしかアクセスできません。</p>
<pre><code class="language-console">└─┬
  ├─ foo.er
  └─┬ bar
    ├─ __init__.er
    ├─ baz.er
    └─ qux.er
</code></pre>
<pre><code class="language-python"># __init__.py
.qux = import &quot;qux&quot; # this is public
</code></pre>
<pre><code class="language-python checker_ignore"># foo.er
bar = import &quot;bar&quot;
bar.qux
bar.baz # AttributeError: module 'baz' is private
</code></pre>
<pre><code class="language-python"># qux.er
baz = import &quot;baz&quot;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="ジェネレータ"><a class="header" href="#ジェネレータ">ジェネレータ</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/34_generator.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/34_generator.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>ジェネレータは、ブロック中で<code>yield!</code>プロシージャを使う特殊なプロシージャです。</p>
<pre><code class="language-python">g!() =
    yield! 1
    yield! 2
    yield! 3
</code></pre>
<p><code>yield!</code>はサブルーチンのブロックで定義されるプロシージャで、<code>self!.yield!</code>を呼び出します。
これは<code>return</code>と同じく渡された値を戻り値として返すものですが、その時点でのブロックの実行状態を保存し、もう一度呼び出された際に続きから実行するという特徴があります。
ジェネレータはプロシージャでありながらイテレータでもあります。Pythonのジェネレータはイテレータを生成する関数ですが、Ergは直接イテレートします。プロシージャ自体は一般に可変オブジェクトではありません(<code>!</code>が付かない)が、ジェネレータは実行ごとに自身の内容が変わる得るので可変オブジェクトです。</p>
<pre><code class="language-python"># Generator! &lt; Proc
g!: Generator!((), Int)
assert g!() == 1
assert g!() == 2
assert g!() == 3
</code></pre>
<p>Pythonスタイルのジェネレータは以下のようにして定義できます。</p>
<pre><code class="language-python">make_g() = () =&gt;
    yield! 1
    yield! 2
    yield! 3
make_g: () =&gt; Generator!((), Int)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="クイックツアー"><a class="header" href="#クイックツアー">クイックツアー</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/quick_tour.md&amp;commit_hash=44d7784aac3550ba97c8a1eaf20b9264b13d4134"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/quick_tour.md%26commit_hash%3D44d7784aac3550ba97c8a1eaf20b9264b13d4134" alt="badge" /></a></p>
<p><code>syntax</code>以下のドキュメントは、概ねプログラミング初心者でも理解できることを目指して書かれています。
すでにPythonやRust, Haskellなどの言語を習得されている方にとっては、少し冗長であるかもしれません。</p>
<p>そこで以下では概説的にErgの文法を紹介します。
特に言及のない部分はPythonと同じと考えてください。</p>
<h2 id="基本的な計算"><a class="header" href="#基本的な計算">基本的な計算</a></h2>
<p>ergプログラムは、コンパイル時にすべて厳密に型付けされています。しかし、型はクラスやトレイトによって部分型であると判断できる場合には自動的にキャスティングされます(詳細については<a href="../API/types/traits/Num.html">Num</a>を参照してください)。</p>
<p>よって、例えば数値型であれば異なる型同士で計算をすることもできます。</p>
<pre><code class="language-python">a = 1 # 1: Nat(Int)
b = a - 10 # -9: Int
c = b / 2 # -4.5: Float
d = c * 0 # -0.0: Float
e = f // 2 # 0: Nat(Int)
</code></pre>
<p>これら暗黙的な型の変換を許容したくない場合には宣言時に型を指定することでコンパイル時にエラーとして検出できます。</p>
<pre><code class="language-python">a = 1
b: Int = a / 2
# error message
Error[#0047]: File &lt;stdin&gt;, line 1, in &lt;module&gt;
2│ b: Int = int / 2
   ^
TypeError: the type of ratio is mismatched:
expected:  Int
but found: Float
</code></pre>
<h2 id="真偽値型"><a class="header" href="#真偽値型">真偽値型</a></h2>
<p>True、Falseは真偽値型のシングルトンですが、整数型を汎化型として持ちます。</p>
<p>そのため、整数型や整数の部分型にあたる自然型、それらの汎化型になる有理数型や浮動小数型で比較をすることができます。</p>
<p>ただし、浮動小数型は<code>Eq</code>をsupersに持たないため、<code>==</code>を使うとコンパイルエラーになります。</p>
<pre><code class="language-python">True == 1 # OK
False == -1 # OK
True == 1.0 # OK
True &lt; 2.0f64 # OK
True == 0.0f64 # NG
True == &quot;a&quot; # NG
</code></pre>
<h2 id="変数定数"><a class="header" href="#変数定数">変数、定数</a></h2>
<p>変数は<code>=</code>で定義します。Haskellなどと同じように、一度定義した変数は書き換えられません。ただし別のスコープではシャドーイングできます。</p>
<pre><code class="language-python">i = 0
if True:
    i = 1
assert i == 0
</code></pre>
<p>大文字で始まるものは定数です。コンパイル時計算できるものだけが定数にできます。
また、定数は定義以降すべてのスコープで同一です。</p>
<pre><code class="language-python">random = import &quot;random&quot; # pythonの標準ライブラリをインポートできる
PI = 3.141592653589793
match random.random!(0..10):
    PI -&gt;
        log &quot;You get PI, it's a miracle!&quot;
</code></pre>
<h2 id="宣言-1"><a class="header" href="#宣言-1">宣言</a></h2>
<p>Pythonと違い、変数の型のみを先に宣言することが可能です。
当然、宣言の型と実際に代入されるオブジェクトの型は互換していなくてはなりません。</p>
<pre><code class="language-python">i: Int
i = 10 # OK
i = 1.0 # NG
</code></pre>
<h2 id="関数-3"><a class="header" href="#関数-3">関数</a></h2>
<p>Haskellなどと同じように定義できます。</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
fib n = fib(n - 1) + fib(n - 2)
</code></pre>
<p>無名関数は以下のように定義できます。</p>
<pre><code class="language-python">i -&gt; i + 1
assert [1, 2, 3].map(i -&gt; i + 1).to_arr() == [2, 3, 4]
</code></pre>
<h2 id="演算子-2"><a class="header" href="#演算子-2">演算子</a></h2>
<p>Erg独自の演算子は以下の通りです。</p>
<h3 id="可変化演算子"><a class="header" href="#可変化演算子">可変化演算子(!)</a></h3>
<p>Ocamlの<code>ref</code>のようなものです。</p>
<pre><code class="language-python">i = !0
i.update! x -&gt; x + 1
assert i == 1
</code></pre>
<h2 id="プロシージャ-2"><a class="header" href="#プロシージャ-2">プロシージャ</a></h2>
<p>副作用のあるサブルーチンはプロシージャと呼ばれ、<code>!</code>がついています。
プロシージャを関数中で呼び出すことはできません。</p>
<pre><code class="language-python">print! 1 # 1
</code></pre>
<h2 id="ジェネリック関数多相関数"><a class="header" href="#ジェネリック関数多相関数">ジェネリック関数(多相関数)</a></h2>
<pre><code class="language-python">id|T|(x: T): T = x
id(1): Int
id(&quot;a&quot;): Str
</code></pre>
<h2 id="レコード-2"><a class="header" href="#レコード-2">レコード</a></h2>
<p>ML系言語にあるレコード(あるいはJSのオブジェクトリテラル)に相当するものを利用できます。</p>
<pre><code class="language-python">p = {x = 1; y = 2}
assert p.x == 1
</code></pre>
<h2 id="所有権-1"><a class="header" href="#所有権-1">所有権</a></h2>
<p>Ergは可変オブジェクト(<code>!</code>演算子で可変化したオブジェクト)に所有権がついており、複数の場所から書き換えられません。</p>
<pre><code class="language-python">i = !0
j = i
assert j == 0
i # MoveError
</code></pre>
<p>対して不変オブジェクトは複数の場所から参照できます。</p>
<h2 id="可視性-1"><a class="header" href="#可視性-1">可視性</a></h2>
<p>変数の頭に<code>.</code>をつけると、その変数は公開変数となり、外部モジュールから参照できるようになります。</p>
<pre><code class="language-python"># foo.er
.x = 1
y = 1
</code></pre>
<pre><code class="language-python">foo = import &quot;foo&quot;
assert foo.x == 1
foo.y # VisibilityError
</code></pre>
<h2 id="パターンマッチ"><a class="header" href="#パターンマッチ">パターンマッチ</a></h2>
<h3 id="変数パターン-1"><a class="header" href="#変数パターン-1">変数パターン</a></h3>
<pre><code class="language-python"># 基本的な代入
i = 1
# 型注釈付き
i: Int = 1
# 関数の場合
fn x = x + 1
fn: Int -&gt; Int = x -&gt; x + 1
</code></pre>
<h3 id="リテラルパターン-1"><a class="header" href="#リテラルパターン-1">リテラルパターン</a></h3>
<pre><code class="language-python"># もし`i`がコンパイル時に1であることが確定していないならば、TypeErrorが発生する。
# `_: {1} = i`の省略形
1 = i
# 簡単なパターンマッチング
match x:
    1 -&gt; &quot;1&quot;
    2 -&gt; &quot;2&quot;
    _ -&gt; &quot;other&quot;
# フィボナッチ関数
fib 0 = 0
fib 1 = 1
fib n: Nat = fib n-1 + fib n-2
</code></pre>
<h3 id="定数パターン-1"><a class="header" href="#定数パターン-1">定数パターン</a></h3>
<pre><code class="language-python">PI = 3.141592653589793
E = 2.718281828459045
num = PI
name = match num:
    PI -&gt; &quot;pi&quot;
    E -&gt; &quot;e&quot;
    _ -&gt; &quot;unnamed&quot;
</code></pre>
<h3 id="破棄ワイルドカードパターン-1"><a class="header" href="#破棄ワイルドカードパターン-1">破棄(ワイルドカード)パターン</a></h3>
<pre><code class="language-python">_ = 1
_: Int = 1
right(_, r) = r
</code></pre>
<h3 id="可変長パターン-1"><a class="header" href="#可変長パターン-1">可変長パターン</a></h3>
<p>後述するタプル/配列/レコードパターンと組み合わせて使う。</p>
<pre><code class="language-python">[i, ...j] = [1, 2, 3, 4]
assert j == [2, 3, 4]
first|T|(fst: T, ...rest: T) = fst
assert first(1, 2, 3) == 1
</code></pre>
<h3 id="タプルパターン-1"><a class="header" href="#タプルパターン-1">タプルパターン</a></h3>
<pre><code class="language-python">(i, j) = (1, 2)
((k, l), _) = ((1, 2), (3, 4))
# ネストしていないなら()を省略可能(1, 2は(1, 2)として扱われる)
m, n = 1, 2
</code></pre>
<h3 id="配列パターン-1"><a class="header" href="#配列パターン-1">配列パターン</a></h3>
<pre><code class="language-python">length [] = 0
length [_, ...rest] = 1 + length rest
</code></pre>
<h4 id="レコードパターン-1"><a class="header" href="#レコードパターン-1">レコードパターン</a></h4>
<pre><code class="language-python">{sin; cos; tan; ...} = import &quot;math&quot;
{*} = import &quot;math&quot; # 全てインポートする

person = {name = &quot;John Smith&quot;; age = 20}
age = match person:
    {name = &quot;Alice&quot;; _} -&gt; 7
    {_; age} -&gt; age
</code></pre>
<h3 id="データクラスパターン-1"><a class="header" href="#データクラスパターン-1">データクラスパターン</a></h3>
<pre><code class="language-python">Point = Inherit {x = Int; y = Int}
p = Point::{x = 1; y = 2}
Point::{x; y} = p
</code></pre>
<h2 id="内包表記-1"><a class="header" href="#内包表記-1">内包表記</a></h2>
<pre><code class="language-python">odds = [i | i &lt;- 1..100; i % 2 == 0]
</code></pre>
<h2 id="クラス-2"><a class="header" href="#クラス-2">クラス</a></h2>
<p>Ergでは多重・多段継承をサポートしていません。</p>
<h2 id="トレイト-1"><a class="header" href="#トレイト-1">トレイト</a></h2>
<p>Rustのトレイトと似ていますが、より本来の意味に近いもので、合成や分離ができ、属性とメソッドは対等に扱われます。
また、実装を伴いません。</p>
<pre><code class="language-python">XY = Trait {x = Int; y = Int}
Z = Trait {z = Int}
XYZ = XY and Z
Show = Trait {show: Self.() -&gt; Str}

@Impl XYZ, Show
Point = Class {x = Int; y = Int; z = Int}
Point.
    ...
</code></pre>
<h2 id="パッチ-1"><a class="header" href="#パッチ-1">パッチ</a></h2>
<p>クラスやトレイトに実装を与えたりできます。</p>
<h2 id="篩型-2"><a class="header" href="#篩型-2">篩型</a></h2>
<p>述語式で型に制限をかけられます。</p>
<pre><code class="language-python">Nat = {I: Int | I &gt;= 0}
</code></pre>
<h2 id="値を含むパラメトリック型依存型"><a class="header" href="#値を含むパラメトリック型依存型">値を含むパラメトリック型(依存型)</a></h2>
<pre><code class="language-python">a: [Int; 3]
b: [Int; 4]
a + b: [Int; 7]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="索引"><a class="header" href="#索引">索引</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/indexes.md&amp;commit_hash=96b113c47ec6ca7ad91a6b486d55758de00d557d"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/indexes.md%26commit_hash%3D96b113c47ec6ca7ad91a6b486d55758de00d557d" alt="badge" /></a></p>
<p>この索引にないAPIについては<a href="../API/index.html">こちら</a>を参照してください。</p>
<p>用語の意味については<a href="../terms.html">こちら</a>を参照。</p>
<h2 id="記号"><a class="header" href="#記号">記号</a></h2>
<ul>
<li>! → <a href="./07_side_effect.html">side effect</a>
<ul>
<li>!-type → <a href="./type/18_mut.html">mutable type</a></li>
</ul>
</li>
<li>? → <a href="./30_error_handling.html">error handling</a></li>
<li># → <a href="./00_basic.html">Str</a></li>
<li>$ → <a href="./type/advanced/shared.html">shared</a></li>
<li>%</li>
<li>&amp;
<ul>
<li>&amp;&amp;</li>
</ul>
</li>
<li><a href="./20_naming_rule.html">′ (single quote)</a></li>
<li><a href="./01_literal.html">&quot; (double quote)</a></li>
<li>() → <a href="./11_tuple.html">Tuple</a></li>
<li>*
<ul>
<li>* → <a href="./01_literal.html">*-less multiplication</a></li>
</ul>
</li>
<li>+ (前置) → <a href="./06_operator.html">operator</a>
<ul>
<li>+_ → + (前置)</li>
</ul>
</li>
<li>+ (中置) → <a href="./06_operator.html">operator</a></li>
<li>+ (中置) → <a href="./type/03_trait.html">Trait</a></li>
<li>,</li>
<li>− (前置)
<ul>
<li>−_ → − (前置)</li>
</ul>
</li>
<li>− (中置) → <a href="./06_operator.html">operator</a></li>
<li>− (中置) → <a href="./type/03_trait.html">Trait</a>
<ul>
<li>−&gt; → <a href="./21_lambda.html">anonymous function</a></li>
</ul>
</li>
<li>. → <a href="./19_visibility.html">Visibility</a>
<ul>
<li><a href="./28_spread_syntax.html">... assignment</a></li>
<li><a href="./28_spread_syntax.html">... Extract assignment</a></li>
<li><a href="./04_function.html">... function</a></li>
</ul>
</li>
<li>/</li>
<li>:
<ul>
<li>: → <a href="./04_function.html">Colon application style</a></li>
<li>: → <a href="./03_declaration.html">Declaration</a></li>
<li>: → <a href="./04_function.html">Keyword Arguments</a></li>
<li>:: → <a href="./19_visibility.html">visibility</a></li>
<li>:= → <a href="./04_function.html">default parameters</a></li>
</ul>
</li>
<li>;</li>
<li>&lt;
<ul>
<li>&lt;: → <a href="./type/02_basic.html">Subtype specification</a></li>
<li>&lt;&lt;</li>
<li>&lt;=</li>
</ul>
</li>
<li>= → <a href="./19_visibility.html">Variable</a>
<ul>
<li>==</li>
<li>=&gt; → <a href="./08_procedure.html">procedure</a></li>
</ul>
</li>
<li>&gt;
<ul>
<li>&gt;&gt;</li>
<li>&gt;=</li>
</ul>
</li>
<li>@ → <a href="./29_decorator.html">decorator</a></li>
<li>[] → <a href="./10_array.html">Array</a></li>
<li>\ → <a href="./00_basic.html">Indention</a></li>
<li>\ → <a href="./01_literal.html">Str</a></li>
<li>^
<ul>
<li>^^</li>
</ul>
</li>
<li>_ → <a href="./type/advanced/erasure.html">Type erasure</a>
<ul>
<li>_+_ → + (infix)</li>
<li>_-_ → − (infix)</li>
</ul>
</li>
<li><a href="./22_subroutine.html">`` (back quote)</a></li>
<li>{}
<ul>
<li><a href="./type/01_type_system.html">{} type</a></li>
</ul>
</li>
<li>{:}</li>
<li>{=} → <a href="./type/01_type_system.html">Type System</a>
<ul>
<li><a href="./13_record.html">{=} type</a></li>
</ul>
</li>
<li>|
<ul>
<li>|| → <a href="./type/advanced/">Type variable list</a></li>
</ul>
</li>
<li>~</li>
</ul>
<h2 id="アルファベット"><a class="header" href="#アルファベット">アルファベット</a></h2>
<h3 id="a"><a class="header" href="#a">A</a></h3>
<ul>
<li>[Add]</li>
<li><a href="type/02_basic.html">alias</a></li>
<li><a href="./type/02_basic.html">Aliasing</a></li>
<li><a href="./type/13_algebraic.html">algebraic type</a></li>
<li>[And]</li>
<li>[and]</li>
<li><a href="./21_lambda.html">anonymous function</a></li>
<li><a href="./21_lambda.html">Anonymous polycorrelation coefficient</a></li>
<li>anonymous type → <a href="./type/01_type_system.html">Type System</a></li>
<li><a href="./10_array.html">Array</a></li>
<li>[assert]</li>
<li><a href="./29_decorator.html">Attach</a></li>
<li><a href="type/09_attributive.html">attribute</a></li>
<li><a href="./type/02_basic.html">Attribute definitions</a></li>
<li><a href="./type/09_attributive.html">Attribute Type</a></li>
</ul>
<h3 id="b"><a class="header" href="#b">B</a></h3>
<ul>
<li><a href="./01_literal.html">Bool, Boolean</a></li>
<li><a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./18_ownership.html">borrow</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li><a href="./type/17_type_casting.html">Cast</a></li>
<li><a href="./00_basic.html">Comments</a></li>
<li><a href="./01_literal.html">Complex Object</a></li>
<li><a href="./04_function.html">Compile-time functions</a></li>
<li><a href="./18_ownership.html">circular references</a></li>
<li><a href="./type/04_class.html">Class</a></li>
<li><a href="./type/04_class.html">Class Relationship</a></li>
<li><a href="./type/16_subtyping.html">Class upcasting</a></li>
<li><a href="./04_function.html">Colon application style</a></li>
<li><a href="./23_closure.html">Closure</a></li>
<li><a href="./01_literal.html">Compound Literals</a></li>
<li><a href="./type/13_algebraic.html">Complement</a></li>
<li><a href="./27_comprehension.html">Comprehension</a></li>
<li><a href="./17_mutability.html">constant</a></li>
<li><a href="./02_name.html">Constants</a></li>
<li><a href="./30_error_handling.html">Context</a></li>
</ul>
<h3 id="d"><a class="header" href="#d">D</a></h3>
<ul>
<li><a href="./type/01_type_system.html">Data type</a></li>
<li><a href="./03_declaration.html">Declaration</a></li>
<li><a href="./29_decorator.html">decorator</a></li>
<li><a href="./04_function.html">Default parameters</a></li>
<li><a href="./02_name.html">Del</a></li>
<li><a href="./type/14_dependent.html">Dependent Type</a></li>
<li><a href="13_record.html">Deconstructing a record</a></li>
<li>Deprecated</li>
<li><a href="./12_dict.html">Dict</a></li>
<li><a href="./type/13_algebraic.html">Diff</a></li>
<li><a href="./type/04_class.html">Difference from Data Class</a></li>
<li><a href="type/04_class.html">Difference from structural types</a></li>
<li>distinct</li>
<li><a href="./type/17_type_casting.html">Downcasting</a></li>
</ul>
<h3 id="e"><a class="header" href="#e">E</a></h3>
<ul>
<li><a href="./13_record.html">Empty Record</a></li>
<li><a href="./type/04_class.html">Enum Class</a></li>
<li><a href="./type/11_enum.html">Enum type</a></li>
<li><a href="./type/12_refinement.html">Enumerated, Interval and Refinement Types</a></li>
<li><a href="./30_error_handling.html">error handling</a></li>
<li><a href="./type/advanced/existential.html">Existential type</a></li>
<li><a href="./01_literal.html">Exponential Literal</a></li>
<li><a href="./28_spread_syntax.html">Extract assignment</a></li>
</ul>
<h3 id="f"><a class="header" href="#f">F</a></h3>
<ul>
<li>False → <a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./01_literal.html">Float&amp;sbsp;Object</a></li>
<li><a href="./05_builtin_funcs.html">for</a></li>
<li><a href="./type/07_patch.html">For-All Patch</a></li>
<li><a href="./type/15_quantified.html">For all types</a></li>
<li><a href="./18_ownership.html">freeze</a></li>
<li><a href="./04_function.html">Function</a></li>
<li><a href="./04_function.html">Function definition with multiple patterns</a></li>
</ul>
<h3 id="g"><a class="header" href="#g">G</a></h3>
<ul>
<li><a href="./type/advanced/GADTs.html">GADTs(Generalized Algebraic Data Types)</a></li>
<li><a href="./34_generator.html">Generator</a></li>
<li><a href="./type/07_patch.html">Glue Patch</a></li>
</ul>
<h3 id="h"><a class="header" href="#h">H</a></h3>
<ul>
<li><a href="/04_function.html">High-order function</a></li>
</ul>
<h3 id="i"><a class="header" href="#i">I</a></h3>
<ul>
<li><a href="./09_builtin_procs.html">id</a></li>
<li><a href="./05_builtin_funcs.html">if</a></li>
<li><a href="./33_package_system.html">import</a></li>
<li><a href="./29_decorator.html">impl</a></li>
<li>[in]</li>
<li><a href="./00_basic.html">Indention</a></li>
<li><a href="./13_record.html">Instant Block</a></li>
<li><a href="./type/04_class.html">Instance and class attributes</a></li>
<li><a href="type/03_trait.html">Implementing and resolving duplicate traits in the API</a></li>
<li><a href="./29_decorator.html">inheritable</a></li>
<li><a href="./type/05_inheritance.html">inheritance</a></li>
<li><a href="./type/05_inheritance.html">Inheritance of Enumerated Classes</a></li>
<li><a href="./01_literal.html">Int</a></li>
<li><a href="./32_integration_with_Python.html">Integration with Python</a></li>
<li><a href="./type/10_interval.html">Interval Type</a></li>
<li><a href="./type/13_algebraic.html">Intersection</a></li>
<li><a href="./16_iterator.html">Iterator</a></li>
</ul>
<h3 id="j"><a class="header" href="#j">J</a></h3>
<h3 id="k"><a class="header" href="#k">K</a></h3>
<ul>
<li><a href="./04_function.html">Keyword arguments</a></li>
<li><a href="./type/advanced/kind.html">Kind</a></li>
</ul>
<h3 id="l"><a class="header" href="#l">L</a></h3>
<ul>
<li>lambda → <a href="./21_lambda.html">anonymous function</a></li>
<li>let-polymorphism → [rank 1 polymorphism]</li>
<li><a href="./20_naming_rule.html">Literal Identifiers</a></li>
<li>log → <a href="./07_side_effect.html">side effect</a></li>
</ul>
<h3 id="m"><a class="header" href="#m">M</a></h3>
<ul>
<li>[match]</li>
<li><a href="./type/advanced/marker_trait.html">Marker Trait</a></li>
<li><a href="./07_side_effect.html">Method</a></li>
<li>Modifier → <a href="./29_decorator.html">decorator</a></li>
<li><a href="./24_module.html">module</a></li>
<li><a href="type/05_inheritance.html">Multiple Inheritance</a></li>
<li><a href="type/05_inheritance.html">Multi-layer (multi-level) Inheritance</a></li>
<li><a href="./type/18_mut.html">Mutable Type</a></li>
<li><a href="./type/advanced/mut_struct.html">Mutable Structure Type</a></li>
<li><a href="./17_mutability.html">Mutability</a></li>
</ul>
<h3 id="n"><a class="header" href="#n">N</a></h3>
<ul>
<li><a href="./01_literal.html">Nat</a></li>
<li>[Never]</li>
<li><a href="./type/advanced/newtype.html">New type</a></li>
<li><a href="./12_dict.html">Heterogeneous Dict</a></li>
<li>None → [None Object]</li>
<li>[None Object]</li>
<li>Nominal Subtyping → <a href="./type/04_class.html">Class</a></li>
<li>[Not]</li>
<li>[not]</li>
</ul>
<h3 id="o"><a class="header" href="#o">O</a></h3>
<ul>
<li><a href="./25_object_system.html">Object</a></li>
<li>[Option]</li>
<li>[Or]</li>
<li>[or]</li>
<li>[Ord]</li>
<li><a href="./18_ownership.html">ownership system</a></li>
<li><a href="./type/advanced/overloading.html">Overloading</a></li>
<li><a href="./type/05_inheritance.html">Overriding</a></li>
<li><a href="./type/03_trait.html">Override in Trait</a></li>
</ul>
<h3 id="p"><a class="header" href="#p">P</a></h3>
<ul>
<li><a href="./30_error_handling.html">Panic</a></li>
<li><a href="./type/07_patch.html">Patch</a></li>
<li><a href="./26_pattern_matching.html">Pattern match</a></li>
<li><a href="./type/advanced/phantom.html">Phantom class</a></li>
<li><a href="./31_pipeline.html">pipeline operator</a></li>
<li><a href="./type/19_bound.html">Predicate</a></li>
<li>[print!]</li>
<li><a href="./08_procedure.html">Procedures</a></li>
<li><a href="./type/advanced/projection.html">Projection Type</a></li>
<li>Python → <a href="./32_integration_with_Python.html">Integration with Python</a></li>
</ul>
<h3 id="q"><a class="header" href="#q">Q</a></h3>
<ul>
<li><a href="./type/15_quantified.html">Quantified Type</a></li>
<li><a href="./type/advanced/quantified_dependent.html">Quantified Dependent Type</a></li>
<li><a href="./type/15_quantified.html">Quantified Types and Dependent Types</a></li>
</ul>
<h3 id="r"><a class="header" href="#r">R</a></h3>
<ul>
<li><a href="./01_literal.html">Range Object</a></li>
<li>[ref]</li>
<li>[ref!]</li>
<li><a href="./13_record.html">Record</a></li>
<li><a href="./type/09_attributive.mda12_refinement.html">Record Type Composite</a></li>
<li><a href="./04_function.html">Recursive functions</a></li>
<li><a href="./type/12_refinement.html">Refinement pattern</a></li>
<li><a href="./type/12_refinement.html">Refinement Type</a></li>
<li><a href="./18_ownership.html">replication</a></li>
<li><a href="./type/05_inheritance.html">Replacing Traits</a></li>
<li>Result → <a href="./30_error_handling.html">error handling</a></li>
<li><a href="./type/05_inheritance.html">Rewriting Inherited Attributes</a></li>
<li>rootobj</li>
</ul>
<h3 id="s"><a class="header" href="#s">S</a></h3>
<ul>
<li><a href="./00_basic.html">Script</a></li>
<li><a href="./type/07_patch.html">Selecting Patches</a></li>
<li>self</li>
<li><a href="./type/advanced/special.html">Self</a></li>
<li><a href="./type/advanced/shared.html">Shared Reference</a></li>
<li><a href="./07_side_effect.html">side-effect</a></li>
<li><a href="./type/12_refinement.html">Smart Cast</a></li>
<li><a href="./28_spread_syntax.html">Spread assignment</a></li>
<li><a href="./type/advanced/special.html">special type variables</a></li>
<li><a href="30_error_handling.html">Stack trace</a></li>
<li><a href="./type/01_type_system.html">Structure type</a></li>
<li><a href="./type/07_patch.html">Structural Patch</a></li>
<li><a href="./type/03_trait.html">Structural Trait</a></li>
<li><a href="./type/01_type_system.html">Structural Subtyping</a></li>
<li><a href="./type/16_subtyping.html">Structural types and class type relationships</a></li>
<li><a href="./01_literal.html">Str</a></li>
<li><a href="./type/16_subtyping.html">Subtyping</a></li>
<li><a href="./type/16_subtyping.html">Subtyping of subroutines</a></li>
<li><a href="./type/02_basic.html">Subtype specification</a></li>
<li><a href="./type/15_quantified.html">Subtyping of Polymorphic Function Types</a></li>
<li><a href="./22_subroutine.html">Subroutine Signatures</a></li>
</ul>
<h3 id="t"><a class="header" href="#t">T</a></h3>
<ul>
<li><a href="./29_decorator.html">Test</a></li>
<li><a href="./type/03_trait.html">Traits</a></li>
<li><a href="./type/03_trait.html">Trait inclusion</a></li>
<li>True → <a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./type/13_algebraic.html">True Algebraic type</a></li>
<li>[Type]</li>
<li><a href="./15_type.html">type</a></li>
<li><a href="./type/15_quantified.html">Type arguments in method definitions</a></li>
<li><a href="./type/19_bound.html">Type Bound</a></li>
<li><a href="./type/01_type_system.html">Type Definitions</a></li>
<li><a href="./type/advanced/erasure.html">Type erasure</a></li>
<li><a href="./type/01_type_system.html">Type Inference System</a></li>
<li><a href="./type/02_basic.html">Type specification</a></li>
<li><a href="./type/01_type_system.html">Type System</a></li>
<li><a href="./type/advanced/widening.html">Type Widening</a></li>
<li><a href="./11_tuple.html">Tuple</a></li>
</ul>
<h3 id="u"><a class="header" href="#u">U</a></h3>
<ul>
<li><a href="type/13_algebraic.html">union</a></li>
<li><a href="./11_tuple.html">Unit</a></li>
<li><a href="type/17_type_casting.html">Upcasting</a></li>
<li><a href="./type/05_inheritance.html">Usage of Inheritance</a></li>
</ul>
<h3 id="v"><a class="header" href="#v">V</a></h3>
<ul>
<li><a href="./type/08_value.html">Value Type</a></li>
<li><a href="./02_name.html">Variable</a></li>
<li><a href="./04_function.html">variable-length arguments</a></li>
</ul>
<h3 id="w"><a class="header" href="#w">W</a></h3>
<ul>
<li>[while]</li>
</ul>
<h3 id="x"><a class="header" href="#x">X</a></h3>
<h3 id="y"><a class="header" href="#y">Y</a></h3>
<h3 id="z"><a class="header" href="#z">Z</a></h3>
<h2 id="あ行"><a class="header" href="#あ行">あ行</a></h2>
<ul>
<li>[アサーション]</li>
<li>値オブジェクト</li>
<li><a href="./29_decorator.html#attach">アタッチメントパッチ</a></li>
<li>アドホック多相 → <a href="./type/overloading.html">オーバーロードの禁止</a></li>
<li>アトリビュート → [属性]</li>
<li>アリティ</li>
<li><a href="./type/dependent_type.html">依存型</a></li>
<li>イミュータブル → [不変]</li>
<li>引数(いんすう) → [引数(ひきすう)]</li>
<li>インスタンス</li>
<li><a href="./00_basic.html#%E5%BC%8F%E3%82%BB%E3%83%91%E3%83%AC%E3%83%BC%E3%82%BF">インスタントブロック</a></li>
<li>インデックス</li>
<li><a href="./00_basic.html#%E3%82%A4%E3%83%B3%E3%83%87%E3%83%B3%E3%83%88">インデント</a></li>
<li>エイリアス</li>
<li>エラー
<ul>
<li>[エラーハンドリング]</li>
</ul>
</li>
<li><a href="./06_operator.html">演算子</a>
<ul>
<li>[演算子の結合強度]</li>
</ul>
</li>
<li>オーバーライド</li>
<li><a href="./type/overloading.html">オーバーロードの禁止</a></li>
<li>オフサイドルール → <a href="./00_basic.html#%E3%82%A4%E3%83%B3%E3%83%87%E3%83%B3%E3%83%88">インデント</a></li>
<li>[オブジェクト]
<ul>
<li>オブジェクト指向</li>
</ul>
</li>
<li>オペランド → <a href="./06_operator.html">被演算子</a></li>
<li>オペレーター → <a href="./06_operator.html">演算子</a></li>
</ul>
<h2 id="か行"><a class="header" href="#か行">か行</a></h2>
<ul>
<li><a href="./type/advanced/kind.html">カインド</a></li>
<li>[可視性]</li>
<li>[型]
<ul>
<li>[型指定]</li>
<li><a href="./type/advanced/erasure.html">型消去</a></li>
<li>[型推論]</li>
<li><a href="./type/conv_type.html">型注釈</a></li>
<li>[型引数]</li>
<li><a href="./type/advanced/erasure.html">型付加</a></li>
<li><a href="./type/type_variable.html">型変数</a></li>
<li>[型制約]</li>
</ul>
</li>
<li>[ガード]</li>
<li>カプセル化</li>
<li>[可変]
<ul>
<li>[可変オブジェクト]</li>
<li>[可変型]</li>
<li>[可変参照]</li>
<li>[可変配列]</li>
<li>[可変長引数]</li>
</ul>
</li>
<li><a href="./04_function.html">関数</a>
<ul>
<li><a href="./23_scope.html#%E5%8F%AF%E5%A4%89%E7%8A%B6%E6%85%8B%E3%81%AE%E5%9B%9E%E9%81%BF%E9%96%A2%E6%95%B0%E5%9E%8B%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0">関数型プログラミング</a></li>
</ul>
</li>
<li>基底型</li>
<li>記名
<ul>
<li>[記名型] → <a href="./type/04_class.html">クラス</a></li>
<li>[記名化]</li>
<li><a href="./type/05_nst_vs_sst.html">記名的部分型</a></li>
</ul>
</li>
<li>キャプチャ → [クロージャ]</li>
<li>[共変]</li>
<li>[キーワード引数]</li>
<li>空集合 → [{}]</li>
<li>区間
<ul>
<li><a href="./type/11_interval.html">区間型</a></li>
<li>区間演算子</li>
</ul>
</li>
<li>組み込み
<ul>
<li>[組み込み型]</li>
<li><a href="./05_builtin_funcs.html">組み込み関数</a></li>
<li><a href="./09_builtin_procs.html">組み込みプロシージャ</a></li>
</ul>
</li>
<li><a href="./type/04_class.html">クラス</a></li>
<li>[クロージャ]</li>
<li>[グローバル変数]</li>
<li>[クローン]</li>
<li><a href="./type/07_inheritance.html">継承</a></li>
<li>高階
<ul>
<li><a href="./type/advanced/kind.html">高階カインド</a></li>
<li>高階型</li>
<li>高階関数</li>
</ul>
</li>
<li>[公開変数]</li>
<li>[構造的部分型]</li>
<li><del>後方参照</del> → [前方参照]</li>
<li>[コピー]</li>
<li>コメント</li>
<li><a href="./10_array.html">コレクション</a></li>
<li>コロン → [:]</li>
<li><a href="./type/04_class.html">コンストラクタ</a></li>
<li>コンテナ</li>
<li>コンパイラ</li>
<li><a href="./04_function.html#%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%99%82%E9%96%A2%E6%95%B0">コンパイル時計算</a></li>
<li>コンマ → [,]</li>
</ul>
<h2 id="さ行"><a class="header" href="#さ行">さ行</a></h2>
<ul>
<li>再帰
<ul>
<li>再帰型</li>
<li><a href="./04_function.html#%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0">再帰関数</a></li>
</ul>
</li>
<li>サブスクリプト → [インデックス]</li>
<li><a href="./type/overloading.html">サブタイピング多相</a></li>
<li>サブルーチン</li>
<li><a href="./18_memory_management.html#%E5%80%9F%E7%94%A8">参照</a>
<ul>
<li>参照オブジェクト</li>
<li><a href="./18_memory_management.html#%E3%83%A1%E3%83%A2%E3%83%AA%E7%AE%A1%E7%90%86">参照カウント(RC)</a></li>
<li>参照等価性 → <a href="./07_side_effect.html">副作用</a></li>
</ul>
</li>
<li><a href="./02_variable.html">識別子</a></li>
<li>シグネチャ
<ul>
<li>型シグネチャ</li>
</ul>
</li>
<li><a href="./11_dict.html">辞書</a></li>
<li>[自然数] → [Nat]</li>
<li>ジェネリクス → [全称型]</li>
<li>ジェネレータ</li>
<li>[射影型]</li>
<li>借用 → <a href="./18_memory_management.html#%E5%80%9F%E7%94%A8">参照</a></li>
<li><a href="./02_name.html#%E5%A4%89%E6%95%B0">シャドーイング</a></li>
<li>種 → <a href="./type/advanced/kind.html">カインド</a></li>
<li>[集合] → [セット]</li>
<li>述語
<ul>
<li>[述語関数]</li>
</ul>
</li>
<li>条件分岐</li>
<li>[所有権]</li>
<li>真偽型 → [Bool]</li>
<li>シングルトン</li>
<li>[シンボル] → <a href="./02_name.html">識別子</a>
<ul>
<li>[シンボル化]</li>
</ul>
</li>
<li><a href="./00_basic.html#%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88">スクリプト</a></li>
<li>スコープ</li>
<li>スプレッド演算子 → [展開代入]</li>
<li><a href="./10_array.html#%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">スライス</a></li>
<li>制御文字</li>
<li>[整数] → [Int]</li>
<li><a href="./12_set.html">セット</a></li>
<li>セミコロン → [;]</li>
<li><a href="./03_declaration.html">宣言</a></li>
<li>全称
<ul>
<li>全称型 → <a href="./type/quantified.html">多相型</a>
<ul>
<li>閉じた全称型</li>
<li>開いた全称型</li>
</ul>
</li>
<li>全称関数 → 多相関数</li>
<li>全称量化</li>
</ul>
</li>
<li>前置演算子</li>
<li>相互再帰</li>
<li>添字 → [インデックス]</li>
<li>[属性]
<ul>
<li>[属性的部分型]</li>
</ul>
</li>
</ul>
<h2 id="た行"><a class="header" href="#た行">た行</a></h2>
<ul>
<li><a href="./02_name.html">代数</a>
<ul>
<li><a href="./type/13_algebraic.html">代数演算型</a></li>
<li>代数的データ型</li>
</ul>
</li>
<li><a href="./02_variable.html">代入</a></li>
<li>多重
<ul>
<li><a href="./type/07_inheritance.html">多重継承</a></li>
<li>多重代入</li>
<li>多重定義 → [オーバーロードの禁止]</li>
</ul>
</li>
<li>多相
<ul>
<li><a href="./type/quantified.html">多相型</a></li>
<li>多相関数</li>
</ul>
</li>
<li>多態 → [ポリモーフィズム]</li>
<li>ダックタイピング</li>
<li><a href="./11_tuple.html">タプル</a></li>
<li>単相
<ul>
<li>単相化</li>
<li>単相型</li>
<li>単相関数</li>
</ul>
</li>
<li>[遅延初期化]</li>
<li>抽出代入</li>
<li>抽象構文木 → [AST]</li>
<li>中置演算子</li>
<li><a href="./02_name.html">定数</a>
<ul>
<li><a href="./type/advanced/const.html">定数型</a></li>
<li><a href="./type/advanced/const.html">定数式</a></li>
</ul>
</li>
<li>[定義]</li>
<li>提供属性</li>
<li>[適用]</li>
<li><a href="./29_decorator.html">デコレータ</a></li>
<li>デストラクタ</li>
<li>手続き → <a href="./08_procedure.html">プロシージャ</a></li>
<li><a href="./04_function.html">デフォルト引数</a></li>
<li>展開
<ul>
<li>[展開演算子]</li>
<li>[展開代入]</li>
</ul>
</li>
<li><a href="./../API/special.html">特殊形式</a></li>
<li>匿名関数 → <a href="./20_lambda.html">無名関数</a></li>
<li>ドット演算子(<code>.</code>) → [属性参照]</li>
<li>トップ
<ul>
<li>トップ型 → [Structural Object]</li>
<li>トップクラス → [Object]</li>
</ul>
</li>
<li><a href="./type/03_trait.html">トレイト</a></li>
</ul>
<h2 id="な行"><a class="header" href="#な行">な行</a></h2>
<ul>
<li><a href="./27_comprehension.html">内包表記</a></li>
<li><del>中置(なかおき)演算子</del> → [中置(ちゅうち)演算子]</li>
<li>[名前空間]</li>
</ul>
<h2 id="は行"><a class="header" href="#は行">は行</a></h2>
<ul>
<li><a href="./10_array.html">配列</a></li>
<li><a href="./type/variances.html">派生型</a></li>
<li><a href="./26_pattern_matching.html">パターン(マッチ)</a></li>
<li><a href="./33_package_system.html">パッケージ</a></li>
<li>ハッシュマップ → <a href="./11_dict.html">辞書</a></li>
<li><a href="./type/07_patch.html">パッチ</a></li>
<li>パブリック変数 → <a href="./19_visibility.html">公開変数</a></li>
<li>パラメーター → <a href="./04_function.html">引数</a></li>
<li><a href="./type/overloading.html">パラメトリック多相</a></li>
<li><a href="./type/advanced/variance.html">反変</a></li>
<li>比較
<ul>
<li>[比較演算子]</li>
<li>[比較可能型]</li>
</ul>
</li>
<li><a href="./19_visibility.html">非公開変数</a></li>
<li>標準
<ul>
<li>標準出力</li>
<li>標準入力</li>
<li>標準ライブラリ</li>
</ul>
</li>
<li><a href="./07_side_effect.html">副作用</a></li>
<li>複素数 → [Complex]</li>
<li>[浮動小数点数] → [Float]</li>
<li>プライベート変数 → [非公開変数]</li>
<li>ブール代数 → [Bool]</li>
<li><a href="./08_procedure.html">プロシージャ</a></li>
<li><a href="./04_function.html">引数</a></li>
<li>部分型付け → [サブタイピング]</li>
<li>[不変]
<ul>
<li>[不変オブジェクト]</li>
<li>[不変型]</li>
<li>[不変参照]</li>
</ul>
</li>
<li><a href="./type/12_refinement.html">篩型</a></li>
<li>[ブロック]</li>
<li>分解代入</li>
<li><a href="./02_variable.html">変数</a></li>
<li>ボトム
<ul>
<li>ボトム型 → [{}]</li>
<li>ボトムクラス → [Never]</li>
</ul>
</li>
<li>[ポリモーフィズム]</li>
</ul>
<h2 id="ま行"><a class="header" href="#ま行">ま行</a></h2>
<ul>
<li><del>前置(まえおき)演算子</del> → 前置(ぜんち)演算子</li>
<li><a href="./type/advanced/marker_trait.html">マーカー型</a></li>
<li><a href="./21_lambda.html">無名関数</a></li>
<li>ミュータブル → [可変性]</li>
<li>[ムーブ]</li>
<li>メソッド</li>
<li>メタキャラクタ</li>
<li><a href="./24_module.html">モジュール</a></li>
<li>[文字列] → [Str]
<ul>
<li><a href="./01_literal.html">文字列補間</a></li>
</ul>
</li>
<li>戻り値</li>
</ul>
<h2 id="や行"><a class="header" href="#や行">や行</a></h2>
<ul>
<li><a href="./type/advanced/phantom.html">幽霊型</a></li>
<li>要求属性</li>
<li>[要素]</li>
<li>[呼び出し]</li>
</ul>
<h2 id="ら行"><a class="header" href="#ら行">ら行</a></h2>
<ul>
<li>[ライブラリ]</li>
<li>ラムダ式 → <a href="./20_lambda.html">無名関数</a></li>
<li>ランク
<ul>
<li><a href="./type/advanced/rank2type.html">ランク2多相</a></li>
</ul>
</li>
<li><a href="./01_literal.html">リテラル</a>
<ul>
<li><a href="./18_naming_rule.html">リテラル識別子</a></li>
</ul>
</li>
<li><a href="./type/quantified.html">量化</a></li>
<li><a href="./type/mut.html">レイアウト</a></li>
<li><a href="./type/10_enum.html">列挙型</a></li>
<li><a href="./12_record.html">レコード</a>
<ul>
<li>[レコード型]</li>
<li>レコード多相 → [列多相]</li>
</ul>
</li>
<li>[列多相]</li>
<li><a href="./19_visibility.html">ローカル変数</a></li>
</ul>
<h2 id="わ行"><a class="header" href="#わ行">わ行</a></h2>
<ul>
<li>ワイルドカード</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
