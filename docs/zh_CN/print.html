<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Erg Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_basic.html"><strong aria-hidden="true">1.</strong> 基础</a></li><li class="chapter-item expanded "><a href="01_literal.html"><strong aria-hidden="true">2.</strong> 文字</a></li><li class="chapter-item expanded "><a href="02_name.html"><strong aria-hidden="true">3.</strong> 名称</a></li><li class="chapter-item expanded "><a href="03_declaration.html"><strong aria-hidden="true">4.</strong> 声明</a></li><li class="chapter-item expanded "><a href="04_function.html"><strong aria-hidden="true">5.</strong> 函数</a></li><li class="chapter-item expanded "><a href="05_builtin_funcs.html"><strong aria-hidden="true">6.</strong> 内置函数</a></li><li class="chapter-item expanded "><a href="06_operator.html"><strong aria-hidden="true">7.</strong> 操作员</a></li><li class="chapter-item expanded "><a href="07_side_effect.html"><strong aria-hidden="true">8.</strong> 副作用</a></li><li class="chapter-item expanded "><a href="08_procedure.html"><strong aria-hidden="true">9.</strong> 程序</a></li><li class="chapter-item expanded "><a href="09_builtin_procs.html"><strong aria-hidden="true">10.</strong> 内置程序</a></li><li class="chapter-item expanded "><a href="10_array.html"><strong aria-hidden="true">11.</strong> 数组</a></li><li class="chapter-item expanded "><a href="11_tuple.html"><strong aria-hidden="true">12.</strong> 元组</a></li><li class="chapter-item expanded "><a href="12_dict.html"><strong aria-hidden="true">13.</strong> 字典</a></li><li class="chapter-item expanded "><a href="13_record.html"><strong aria-hidden="true">14.</strong> 记录</a></li><li class="chapter-item expanded "><a href="14_set.html"><strong aria-hidden="true">15.</strong> 设置</a></li><li class="chapter-item expanded "><a href="15_type.html"><strong aria-hidden="true">16.</strong> 类型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/01_type_system.html"><strong aria-hidden="true">16.1.</strong> 类型系统</a></li><li class="chapter-item expanded "><a href="type/02_basic.html"><strong aria-hidden="true">16.2.</strong> 基础</a></li><li class="chapter-item expanded "><a href="type/03_trait.html"><strong aria-hidden="true">16.3.</strong> 特质</a></li><li class="chapter-item expanded "><a href="type/04_class.html"><strong aria-hidden="true">16.4.</strong> 类</a></li><li class="chapter-item expanded "><a href="type/05_inheritance.html"><strong aria-hidden="true">16.5.</strong> 继承</a></li><li class="chapter-item expanded "><a href="type/06_nst_vs_sst.html"><strong aria-hidden="true">16.6.</strong> NST 与 SST</a></li><li class="chapter-item expanded "><a href="type/07_patch.html"><strong aria-hidden="true">16.7.</strong> 补丁</a></li><li class="chapter-item expanded "><a href="type/08_value.html"><strong aria-hidden="true">16.8.</strong> 值类型</a></li><li class="chapter-item expanded "><a href="type/09_attributive.html"><strong aria-hidden="true">16.9.</strong> 属性类型</a></li><li class="chapter-item expanded "><a href="type/10_interval.html"><strong aria-hidden="true">16.10.</strong> 间隔类型</a></li><li class="chapter-item expanded "><a href="type/11_enum.html"><strong aria-hidden="true">16.11.</strong> 枚举类型</a></li><li class="chapter-item expanded "><a href="type/12_refinement.html"><strong aria-hidden="true">16.12.</strong> 细化类型</a></li><li class="chapter-item expanded "><a href="type/13_algebraic.html"><strong aria-hidden="true">16.13.</strong> 代数类型</a></li><li class="chapter-item expanded "><a href="type/14_dependent.html"><strong aria-hidden="true">16.14.</strong> 依赖类型</a></li><li class="chapter-item expanded "><a href="type/15_quantified.html"><strong aria-hidden="true">16.15.</strong> 量化类型</a></li><li class="chapter-item expanded "><a href="type/16_subtyping.html"><strong aria-hidden="true">16.16.</strong> 子类型</a></li><li class="chapter-item expanded "><a href="type/17_type_casting.html"><strong aria-hidden="true">16.17.</strong> 类型转换</a></li><li class="chapter-item expanded "><a href="type/18_mut.html"><strong aria-hidden="true">16.18.</strong> 可变类型</a></li><li class="chapter-item expanded "><a href="type/advanced.html"><strong aria-hidden="true">16.19.</strong> 高级</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/advanced/default_param.html"><strong aria-hidden="true">16.19.1.</strong> 默认参数</a></li><li class="chapter-item expanded "><a href="type/advanced/erasure.html"><strong aria-hidden="true">16.19.2.</strong> 类型擦除</a></li><li class="chapter-item expanded "><a href="type/advanced/existential.html"><strong aria-hidden="true">16.19.3.</strong> 存在</a></li><li class="chapter-item expanded "><a href="type/advanced/GADTs.html"><strong aria-hidden="true">16.19.4.</strong> GADTs</a></li><li class="chapter-item expanded "><a href="type/advanced/keyword_param.html"><strong aria-hidden="true">16.19.5.</strong> 关键字参数</a></li><li class="chapter-item expanded "><a href="type/advanced/kind.html"><strong aria-hidden="true">16.19.6.</strong> 种类</a></li><li class="chapter-item expanded "><a href="type/advanced/marker_trait.html"><strong aria-hidden="true">16.19.7.</strong> 标记特征</a></li><li class="chapter-item expanded "><a href="type/advanced/mut_struct.html"><strong aria-hidden="true">16.19.8.</strong> 可变结构</a></li><li class="chapter-item expanded "><a href="type/advanced/phantom.html"><strong aria-hidden="true">16.19.9.</strong> 幻象类型</a></li><li class="chapter-item expanded "><a href="type/advanced/projection.html"><strong aria-hidden="true">16.19.10.</strong> 投影类型</a></li><li class="chapter-item expanded "><a href="type/advanced/quantified_dependent.html"><strong aria-hidden="true">16.19.11.</strong> 量化依赖类型</a></li><li class="chapter-item expanded "><a href="type/advanced/shared.html"><strong aria-hidden="true">16.19.12.</strong> 共享</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="16_iterator.html"><strong aria-hidden="true">17.</strong> 迭代器</a></li><li class="chapter-item expanded "><a href="17_mutability.html"><strong aria-hidden="true">18.</strong> 可变性</a></li><li class="chapter-item expanded "><a href="18_ownership.html"><strong aria-hidden="true">19.</strong> 所有权</a></li><li class="chapter-item expanded "><a href="19_visibility.html"><strong aria-hidden="true">20.</strong> 可见性</a></li><li class="chapter-item expanded "><a href="20_naming_rule.html"><strong aria-hidden="true">21.</strong> 命名规则</a></li><li class="chapter-item expanded "><a href="21_lambda.html"><strong aria-hidden="true">22.</strong> Lambda</a></li><li class="chapter-item expanded "><a href="22_subroutine.html"><strong aria-hidden="true">23.</strong> 子程序</a></li><li class="chapter-item expanded "><a href="23_closure.html"><strong aria-hidden="true">24.</strong> 关闭</a></li><li class="chapter-item expanded "><a href="24_module.html"><strong aria-hidden="true">25.</strong> 模块</a></li><li class="chapter-item expanded "><a href="25_object_system.html"><strong aria-hidden="true">26.</strong> 对象系统</a></li><li class="chapter-item expanded "><a href="26_pattern_matching.html"><strong aria-hidden="true">27.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="27_comprehension.html"><strong aria-hidden="true">28.</strong> 理解</a></li><li class="chapter-item expanded "><a href="28_spread_syntax.html"><strong aria-hidden="true">29.</strong> 扩展语法</a></li><li class="chapter-item expanded "><a href="29_decorator.html"><strong aria-hidden="true">30.</strong> 装饰器</a></li><li class="chapter-item expanded "><a href="30_error_handling.html"><strong aria-hidden="true">31.</strong> 错误处理</a></li><li class="chapter-item expanded "><a href="31_pipeline.html"><strong aria-hidden="true">32.</strong> 管道</a></li><li class="chapter-item expanded "><a href="32_integration_with_python.html"><strong aria-hidden="true">33.</strong> 与 Python 集成</a></li><li class="chapter-item expanded "><a href="33_package_system.html"><strong aria-hidden="true">34.</strong> 包系统</a></li><li class="chapter-item expanded "><a href="34_generator.html"><strong aria-hidden="true">35.</strong> 发电机</a></li><li class="chapter-item expanded "><a href="indexes.html"><strong aria-hidden="true">36.</strong> 索引</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Erg Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本"><a class="header" href="#基本">基本</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/00_basic.md&amp;commit_hash=31ccb6924c3051f73458c69ca2c7f2cc5a93a694"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/00_basic.md%26commit_hash%3D31ccb6924c3051f73458c69ca2c7f2cc5a93a694" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>：本文档不完整。 它未经校对(样式、正确链接、误译等)。 此外，Erg 的语法可能在版本 0.* 期间发生破坏性更改，并且文档可能没有相应更新。 请事先了解这一点。
如果您在本文档中发现任何错误，请报告至 <a href="https://forms.gle/HtLYRfYzWCAaeTGb6">此处的表单</a> 或 <a href="https://github.com/mtshiba/TheErgBook/issues/new">GitHub repo</a>。 我们将不胜感激您的建议。</p>
</blockquote>
<p>本文档描述 Erg 的基本语法。 <a href="../API/index.html">标准 API</a> 和 <a href="../dev_guide/index.html">Erg 贡献者的内部文档</a> 位于另一个目录中。</p>
<h2 id="你好世界"><a class="header" href="#你好世界">你好，世界!</a></h2>
<p>首先，让我们做&quot;Hello World&quot;。</p>
<pre><code class="language-python">print!(&quot;Hello, World!&quot;)
</code></pre>
<p>这与 Python 和同一家族中的其他语言几乎相同。 最显着的特征是<code>!</code>，后面会解释它的含义。
在 Erg 中，括号 <code>()</code> 可以省略，除非在解释上有一些混淆。
括号的省略与 Ruby 类似，但不能省略可以以多种方式解释的括号。</p>
<pre><code class="language-python">print! &quot;Hello, World!&quot; # OK
print! &quot;Hello,&quot;, &quot;World!&quot; # OK
print!() # OK
print! # OK, 但这并不意味着调用，只是将 `print!` 作为可调用对象

print! f x # OK, 解释为 `print!(f(x))`
print!(f(x, y)) # OK
print! f(x, y) # OK
print! f(x, g y) # OK
print! f x, y # NG, 可以理解为 `print!(f(x), y)` 或 `print!(f(x, y))` print!
print!(f x, y) # NG, 可以表示&quot;print！(f(x)，y)&quot;或&quot;print！(f(x，y))&quot;
print! f(x, g y, z) # NG, 可以表示&quot;print！(x，g(y)，z)&quot;或&quot;print！(x，g(y，z))&quot;
</code></pre>
<h2 id="脚本"><a class="header" href="#脚本">脚本</a></h2>
<p>Erg 代码称为脚本。 脚本可以以文件格式 (.er) 保存和执行。</p>
<h2 id="repl文件执行"><a class="header" href="#repl文件执行">REPL/文件执行</a></h2>
<p>要启动 REPL，只需键入：</p>
<pre><code class="language-sh">&gt; erg
</code></pre>
<p><code>&gt;</code> mark is a prompt, just type <code>erg</code>.
Then the REPL should start.</p>
<pre><code class="language-sh">&gt; erg
Starting the REPL server...
Connecting to the REPL server...
Erg interpreter 0.2.4 (tags/?:, 2022/08/17  0:55:12.95) on x86_64/windows
&gt;&gt;&gt;
</code></pre>
<p>Or you can compile from a file.</p>
<pre><code class="language-sh">&gt; 'print! &quot;hello, world!&quot;' &gt;&gt; hello.er

&gt; erg hello.er
hello, world!
</code></pre>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<p><code>#</code> 之后的代码作为注释被忽略。 使用它来解释代码的意图或暂时禁用代码。</p>
<pre><code class="language-python"># Comment
# `#` and after are ignored until a new line is inserted
#[
Multi-line comment
Treated as a comment all the way up to the corresponding `]#`
]#
</code></pre>
<h2 id="表达式分隔符"><a class="header" href="#表达式分隔符">表达式，分隔符</a></h2>
<p>脚本是一系列表达式。 表达式是可以计算或评估的东西，在 Erg 中几乎所有东西都是表达式。
每个表达式由分隔符分隔 - 新行或分号 <code>;</code>-。
Erg 脚本基本上是从左到右、从上到下进行评估的。</p>
<pre><code class="language-python">n = 1 # 赋值表达式
f(1, 2) # 函数调用表达式
1 + 1 # 运算符调用表达式
f(1, 2); 1 + 1
</code></pre>
<p>如下所示，有一种称为 Instant block 的语法，它将块中评估的最后一个表达式作为变量的值。
这与没有参数的函数不同，它不添加 <code>()</code>。 请注意，即时块仅在运行中评估一次</p>
<pre><code class="language-python">i =
    x = 1
    x + 1
assert i == 2
</code></pre>
<p>这不能用分号 (<code>;</code>) 完成。</p>
<pre><code class="language-python">i = (x = 1; x + 1) # 语法错误：不能在括号中使用 `;`
</code></pre>
<h2 id="缩进"><a class="header" href="#缩进">缩进</a></h2>
<p>Erg 和 Python 一样，使用缩进来表示块。 有五个运算符(特殊形式)触发块的开始：<code>=</code>、<code>-&gt;</code>、<code>=&gt;</code>、<code>do</code> 和 <code>do!</code>(此外，<code>:</code> 和 <code>|</code> ，虽然不是运算符，但也会产生缩进)。 每个的含义将在后面描述。</p>
<pre><code class="language-python">f x, y =
    x + y

for! 0..9, i =&gt;
    print!

for! 0..9, i =&gt;
    print! i; print! i

ans = match x:
    0 -&gt; &quot;zero&quot;
    _: 0..9 -&gt; &quot;1 dight&quot;
    _: 10..99 -&gt; &quot;2 dights&quot;
    _ -&gt; &quot;unknown&quot;
</code></pre>
<p>如果一行太长，可以使用 <code>\</code> 将其断开</p>
<pre><code class="language-python"># 这不是表示 `x + y + z` 而是表示 `x; +y; +z`
X
+ y
+ z

# 这意味着`x + y + z`
x \
+ y \
+ z
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量"><a class="header" href="#字面量">字面量</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/01_literal.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/01_literal.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="基本字面量"><a class="header" href="#基本字面量">基本字面量</a></h2>
<h3 id="整数字面量"><a class="header" href="#整数字面量">整数字面量</a></h3>
<pre><code class="language-python">0, -0, 1, -1, 2, -2, 3, -3, ...
</code></pre>
<h3 id="比率文字"><a class="header" href="#比率文字">比率文字</a></h3>
<pre><code class="language-python">0.00, -0.0, 0.1, 400.104, ...
</code></pre>
<p>如果&quot;比率&quot;文字的整数或小数部分为<code>0</code>，则可以省略<code>0</code></p>
<pre><code class="language-python">assert 1.0 == 1.
assert 0.5 == .5
</code></pre>
<blockquote>
<p><strong>注意</strong>：这个函数 <code>assert</code> 用于表明 <code>1.0</code> 和 <code>1.</code> 相等。
后续文档可能会使用 <code>assert</code> 来表示结果是相等的。</p>
</blockquote>
<h3 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h3>
<p>可以使用任何 Unicode 可表示的字符串。
与 Python 不同，引号不能包含在 <code>'</code> 中。 如果要在字符串中使用 <code>&quot;</code>，请使用 <code>\&quot;</code>。</p>
<pre><code class="language-python">&quot;&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;111&quot;, &quot;1# 3f2-3*8$&quot;, &quot;こんにちは&quot;, &quot;السَّلَامُ عَلَيْكُمْ&quot;, ...
</code></pre>
<p><code>{}</code> 允许您在字符串中嵌入表达式。 这称为字符串插值。
如果要输出 <code>{</code>、<code>}</code> 本身，请使用 <code>\{</code>、<code>\}</code>。</p>
<pre><code class="language-python">assert &quot;1 + 1 is 2&quot; == &quot;{1} + {1} is {1+1}&quot;
s = &quot;1+1&quot;
assert &quot;\{1+1}\&quot; == &quot;\{{s}\}&quot;
</code></pre>
<h3 id="指数字面量"><a class="header" href="#指数字面量">指数字面量</a></h3>
<p>这是学术计算中常用的表示指数符号的文字。 它是&quot;比率&quot;类型的一个实例。
该符号与 Python 中的符号相同。</p>
<pre><code class="language-python">1e-34, 0.4e-10, 2.455+e5, 245e5, 25E5, ...
</code></pre>
<pre><code class="language-python">assert 1e-10 == 0.0000000001
</code></pre>
<h2 id="复合字面量"><a class="header" href="#复合字面量">复合字面量</a></h2>
<p>这些文字中的每一个都有自己的文档分别描述它们，因此请参阅该文档以获取详细信息。</p>
<h3 id="a-href10_arrayhtml数组字面量a"><a class="header" href="#a-href10_arrayhtml数组字面量a"><a href="./10_array.html">数组字面量</a></a></h3>
<pre><code class="language-python">[], [1], [1, 2, 3], [&quot;1&quot;, &quot;2&quot;,], [1, &quot;1&quot;, True, [1]], ...
</code></pre>
<h3 id="a-href11_tuplehtml元组字面量a"><a class="header" href="#a-href11_tuplehtml元组字面量a"><a href="./11_tuple.html">元组字面量</a></a></h3>
<pre><code class="language-python">(), (1, 2, 3), (1, &quot;hello&quot;, True), ...
</code></pre>
<h3 id="a-href12_dicthtml字典字面量a"><a class="header" href="#a-href12_dicthtml字典字面量a"><a href="./12_dict.html">字典字面量</a></a></h3>
<pre><code class="language-python">{:}, {&quot;one&quot;: 1}, {&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;1&quot;: 1, &quot;2&quot;: 2}, {1: &quot;1&quot;, 2: True, &quot;three&quot;: [1]}, ...
</code></pre>
<h3 id="a-href13_recordhtmlrecord-字面量a"><a class="header" href="#a-href13_recordhtmlrecord-字面量a"><a href="./13_record.html">Record 字面量</a></a></h3>
<pre><code class="language-python">{=}, {one = 1}, {one = 1; two = 2}, {.name = &quot;John&quot;; .age = 12}, {.name = Str; .age = Nat}, ...
</code></pre>
<h3 id="a-href14_sethtmlset-字面量a"><a class="header" href="#a-href14_sethtmlset-字面量a"><a href="./14_set.html">Set 字面量</a></a></h3>
<pre><code class="language-python">{}, {1}, {1, 2, 3}, {&quot;1&quot;, &quot;2&quot;, &quot;1&quot;}, {1, &quot;1&quot;, True, [1]} ...
</code></pre>
<p>与 <code>Array</code> 字面量不同的是，<code>Set</code> 中删除了重复元素</p>
<pre><code class="language-python">assert {1, 2, 1} == {1, 2}
</code></pre>
<h3 id="看起来像文字但不是"><a class="header" href="#看起来像文字但不是">看起来像文字但不是</a></h3>
<h2 id="布尔对象"><a class="header" href="#布尔对象">布尔对象</a></h2>
<pre><code class="language-python">True, False
</code></pre>
<h3 id="none-对象"><a class="header" href="#none-对象">None 对象</a></h3>
<pre><code class="language-python">None
</code></pre>
<h2 id="range-对象"><a class="header" href="#range-对象">Range 对象</a></h2>
<pre><code class="language-python">assert 0..5 == {1, 2, 3, 4, 5}
assert 0..10 in 5
assert 0..&lt;10 notin 10
assert 0..9 == 0..&lt;10
</code></pre>
<h2 id="float-对象"><a class="header" href="#float-对象">Float 对象</a></h2>
<pre><code class="language-python">assert 0.0f64 == 0
assert 0.0f32 == 0.0f64
</code></pre>
<p>浮点对象是通过将 <code>Ratio</code> 对象乘以 <code>f64</code> 构造的，后者是 <code>Float 64</code> 单位对象</p>
<h2 id="complex-对象"><a class="header" href="#complex-对象">Complex 对象</a></h2>
<pre><code class="language-python">1+2im, 0.4-1.2im, 0im, im
</code></pre>
<p>一个&quot;复杂&quot;对象只是一个虚数单位对象<code>im</code>的算术组合</p>
<h2 id="-less-乘法"><a class="header" href="#-less-乘法">*-less 乘法</a></h2>
<p>在 Erg 中，您可以省略 <code>*</code> 来表示乘法，只要解释上没有混淆即可。 但是，运算符的组合强度设置为强于 <code>*</code>。</p>
<pre><code class="language-python"># same as `assert (1*m) / (1*s) == 1*(m/s)`
assert 1m / 1s == 1 (m/s)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="多变的"><a class="header" href="#多变的">多变的</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/02_name.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/02_name.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>变量是一种代数； Erg 中的代数 - 如果没有混淆，有时简称为变量 - 指的是命名对象并使它们可从代码的其他地方引用的功能。</p>
<p>变量定义如下。
<code>n</code> 部分称为变量名(或标识符)，<code>=</code> 是赋值运算符，<code>1</code> 部分是赋值。</p>
<pre><code class="language-python">n = 1
</code></pre>
<p>以这种方式定义的&quot;n&quot;此后可以用作表示整数对象&quot;1&quot;的变量。 该系统称为分配(或绑定)。
我们刚刚说过<code>1</code>是一个对象。 稍后我们将讨论对象是什么，但现在我们假设它是可以赋值的，即在赋值运算符的右侧(<code>=</code> 等)。</p>
<p>如果要指定变量的&quot;类型&quot;，请执行以下操作。 类型大致是一个对象所属的集合，后面会解释。
这里我们指定<code>n</code>是自然数(<code>Nat</code>)类型。</p>
<pre><code class="language-python">n: Nat = 1
</code></pre>
<p>请注意，与其他语言不同，不允许多次分配</p>
<pre><code class="language-python"># NG
l1 = l2 = [1, 2, 3] # 语法错误：不允许多重赋值
# OK
l1 = [1, 2, 3]
l2 = l1.clone()
</code></pre>
<p>也不能重新分配给变量。 稍后将描述可用于保存可变状态的语法</p>
<pre><code class="language-python">i = 1
i = i + 1 # 分配错误：不能分配两次
</code></pre>
<p>您可以在内部范围内定义具有相同名称的变量，但您只是覆盖它，而不是破坏性地重写它的值。 如果您返回外部范围，该值也会返回。
请注意，这是与 Python &quot;语句&quot;范围不同的行为。
这种功能通常称为阴影。 但是，与其他语言中的阴影不同，您不能在同一范围内进行阴影。</p>
<pre><code class="language-python">x = 0
# x = 1 # 赋值错误：不能赋值两次
if x.is_zero(), do:
    x = 1 # 与同名的外部 x 不同
    assert x == 1
assert x == 0
</code></pre>
<p>乍一看，以下内容似乎可行，但仍然不可能。 这是一个设计决定，而不是技术限制。</p>
<pre><code class="language-python">x = 0
if x.is_zero(), do:
    x = x + 1 # 名称错误：无法定义变量引用同名变量
    assert x == 1
assert x == 0
</code></pre>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常数也是一种代数。 如果标识符以大写字母开头，则将其视为常量。 它们被称为常量，因为一旦定义，它们就不会改变。
<code>N</code> 部分称为常量名(或标识符)。 否则，它与变量相同。</p>
<pre><code class="language-python">N = 0
if True, do:
    N = 1 # 赋值错误：常量不能被遮蔽
    pass()
</code></pre>
<p>常量在定义的范围之外是不可变的。 他们不能被遮蔽。 由于这个属性，常量可以用于模式匹配。 模式匹配在后面解释。</p>
<p>例如，常量用于数学常量、有关外部资源的信息和其他不可变值。</p>
<p>除了 <a href="./type/01_type_system.html">types</a> 之外的对象标识符使用全大写(所有字母大写的样式)是常见的做法。</p>
<pre><code class="language-python">PI = 3.141592653589793
URL = &quot;https://example.com&quot;
CHOICES = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<pre><code class="language-python">PI = 3.141592653589793
match! x:
    PI =&gt; print! &quot;π&quot;
    other =&gt; print! &quot;other&quot;
</code></pre>
<p>当 <code>x</code> 为 <code>3.141592653589793</code> 时，上面的代码会打印 <code>π</code>。 如果 <code>x</code> 更改为任何其他数字，它会打印 <code>other</code>。</p>
<p>有些对象不能绑定为常量。 例如，可变对象。 可变对象是其状态可以改变的对象，后面会详细介绍。
这是因为只有常量表达式才能分配给常量的规则。 常量表达式也将在后面讨论。</p>
<pre><code class="language-python">X = 1 # OK
X = !1 # 类型错误：无法定义 Int！ 对象作为常量
</code></pre>
<h2 id="删除变量"><a class="header" href="#删除变量">删除变量</a></h2>
<p>您可以使用 <code>Del</code> 函数删除变量。 依赖于变量的所有其他变量(即直接引用变量值的变量)也将被删除。</p>
<pre><code class="language-python">x = 1
y = 2
Z = 3
f a = x + a

assert f(2) == 3
Del x
Del y, Z

f(2) # 名称错误：f 未定义(在第 6 行中删除)
</code></pre>
<p>注意 <code>Del</code> 只能删除用户自定义模块中定义的变量。 无法删除诸如&quot;True&quot;之类的内置常量。</p>
<pre><code class="language-python">Del True # 类型错误：无法删除内置常量
Del print! # TypeError: 无法删除内置变量
</code></pre>
<h2 id="附录赋值和等价"><a class="header" href="#附录赋值和等价">附录：赋值和等价</a></h2>
<p>请注意，当 <code>x = a</code> 时，<code>x == a</code> 不一定为真。 一个例子是<code>Float.NaN</code>。 这是 IEEE 754 定义的浮点数的正式规范。</p>
<pre><code class="language-python">x = Float.NaN
assert x ! = NaN
assert x ! = x
</code></pre>
<p>还有其他对象首先没有定义等价关系。</p>
<pre><code class="language-python">f = x -&gt; x**2 + 2x + 1
g = x -&gt; (x + 1)**2
f == g # 类型错误：无法比较函数对象

C = Class {i: Int}
D = Class {i: Int}
C == D # 类型错误：无法比较类对象
</code></pre>
<p>严格来说，<code>=</code> 不会将右侧的值直接分配给左侧的标识符。
在函数和类对象的情况下，执行&quot;修改&quot;，例如将变量名称信息赋予对象。 但是，结构类型并非如此。</p>
<pre><code class="language-python">f x = x
print! f # &lt;函数 f&gt;
g x = x + 1
print! g # &lt;函数 g&gt;

C = Class {i: Int}
print! C # &lt;类 C&gt;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="宣言declaration"><a class="header" href="#宣言declaration">宣言(Declaration)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/03_declaration.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/03_declaration.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>声明是用于指定要使用的变量类型的语法。
可以在代码中的任何地方进行声明，但单独的声明并不引用变量。 它们必须被初始化。
分配后，可以检查声明以确保类型与分配它的对象兼容。</p>
<pre><code class="language-python">i: Int
# 可以与赋值同时声明，如 i: Int = 2
i = 2
i: Num
i: Nat
i: -2..2
i: {2}
</code></pre>
<p>赋值后的声明类似于<code>assert</code>的类型检查，但具有在编译时检查的特点。
在运行时通过<code>assert</code>进行类型检查可以检查&quot;可能是Foo类型&quot;，但是在编译时通过<code>:</code>进行类型检查是严格的：如果类型未确定为&quot;类型Foo&quot;，则不会通过 检查会出现错误。</p>
<pre><code class="language-python">i = (-1..10).sample!
assert i in Nat # 这可能会通过
i: Int # 这会通过
i: Nat # 这不会通过(-1 不是 Nat 的元素)
</code></pre>
<p>函数可以用两种不同的方式声明。</p>
<pre><code class="language-python">f: (x: Int, y: Int) -&gt; Int
f: (Int, Int) -&gt; Int
</code></pre>
<p>如果显式声明参数名称，如果在定义时名称不同，则会导致类型错误。 如果你想给参数名称任意命名，你可以用第二种方式声明它们。 在这种情况下，类型检查只会看到方法名称及其类型。</p>
<pre><code class="language-python">T = Trait {
    .f = (x: Int, y: Int): Int
}

C = Class(U, Impl := T)
C.f(a: Int, b: Int): Int = ... # 类型错误：`.f` 必须是 `(x: Int, y: Int) -&gt; Int` 的类型，而不是 `(a: Int, b: Int) -&gt; Int`
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="功能"><a class="header" href="#功能">功能</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/04_function.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/04_function.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>函数是一个块，它接受一个&quot;参数&quot;，对其进行处理，并将其作为&quot;返回值&quot;返回。 定义如下。</p>
<pre><code class="language-python">add x, y = x + y
# 或者
add(x, y) = x + y
</code></pre>
<p>在函数名之后指定的名称称为参数。
相反，传递给函数的对象称为参数。
函数 <code>add</code> 是一个以 <code>x</code> 和 <code>y</code> 作为参数并返回它们之和的函数，<code>x + y</code>。
可以按如下方式调用(应用/调用)定义的函数。</p>
<pre><code class="language-python">add 1, 2
# or
add(1, 2)
</code></pre>
<h2 id="冒号应用风格"><a class="header" href="#冒号应用风格">冒号应用风格</a></h2>
<p>函数像<code>f x, y, ...</code>一样被调用，但是如果单行参数太多，可以使用<code>:</code>(冒号)来应用它们。</p>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2, some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2:
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python">f:
    some_long_name_variable_1 + some_long_name_variable_2
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<p>以上三个代码的含义相同。 例如，这种风格在使用 <code>if</code> 函数时也很有用</p>
<pre><code class="language-python">result = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
</code></pre>
<p>在 <code>:</code> 之后，除了注释之外，不得编写任何代码，并且必须始终在新行上</p>
<h2 id="关键字参数"><a class="header" href="#关键字参数">关键字参数</a></h2>
<p>如果使用大量参数定义函数，则存在以错误顺序传递参数的危险。
在这种情况下，使用关键字参数调用函数是安全的。</p>
<pre><code class="language-python">f x, y, z, w, v, u: Int = ...
</code></pre>
<p>上面定义的函数有很多参数，并且排列顺序混乱。 您不应该创建这样的函数，但是在使用别人编写的代码时可能会遇到这样的代码。 因此，我们使用关键字参数。 如果使用关键字参数，则值会从名称传递到正确的参数，即使它们的顺序错误。</p>
<pre><code class="language-python">f u: 6, v: 5, w: 4, x: 1, y: 2, z: 3
</code></pre>
<p>请注意，紧跟在 <code>:</code> 之后的关键字参数和新行被视为冒号调用样式</p>
<pre><code class="language-python"># 意思是 `f(x: y)`
f x: y

# 意思是 `f(x, y)`
f x:
    y
</code></pre>
<h2 id="定义错误参数"><a class="header" href="#定义错误参数">定义错误参数</a></h2>
<p>当某些参数大部分是固定的并且您希望能够省略它们时，使用默认参数。</p>
<p>默认参数由<code>:=</code>(walrus运算符)指定。 如果未指定 <code>base</code>，则将 <code>math.E</code> 分配给 <code>base</code>。</p>
<pre><code class="language-python">math_log x: Ratio, base := math.E = ...

assert math_log(100, 10) == 2
assert math_log(100) == math_log(100, math.E)
</code></pre>
<p>请注意，不指定参数和指定<code>None</code>是有区别的</p>
<pre><code class="language-python">p! x := 0 = print!
p!(2) # 2
p!() # 0
p!(None) # None
</code></pre>
<p>也可以与类型规范和模式一起使用</p>
<pre><code class="language-python">math_log x, base: Ratio := math.E = ...
f [x, y] := [1, 2] = ...
</code></pre>
<p>但是，在默认参数中，不能调用过程(稍后描述)或分配可变对象</p>
<pre><code class="language-python">f x := p! 1 = ... # NG
</code></pre>
<p>此外，刚刚定义的参数不能用作传递给默认参数的值</p>
<pre><code class="language-python">f x := 1, y := x = ... # NG
</code></pre>
<h2 id="可变长度参数"><a class="header" href="#可变长度参数">可变长度参数</a></h2>
<p>输出其参数的日志(记录)的 <code>log</code> 函数可以采用任意数量的参数。</p>
<pre><code class="language-python">记录&quot;你好&quot;、&quot;世界&quot;、&quot;！&quot; # 你好世界 ！
</code></pre>
<p>要定义这样的函数，请将 <code>...</code> 添加到参数中。 这样，函数将参数作为可变长度数组接收</p>
<pre><code class="language-python">f ...x =
    for x, i -&gt;
        log i

# x == [1, 2, 3, 4, 5]
f 1, 2, 3, 4, 5
</code></pre>
<h2 id="具有多种模式的函数定义"><a class="header" href="#具有多种模式的函数定义">具有多种模式的函数定义</a></h2>
<pre><code class="language-python">fib n: Nat =
    match n:
        0 -&gt; 0
        1 -&gt; 1
        n -&gt; fib(n - 1) + fib(n - 2)
</code></pre>
<p>像上面这样的函数，其中 <code>match</code> 直接出现在定义下，可以重写如下</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
fib(n: Nat): Nat = fib(n - 1) + fib(n - 2)
</code></pre>
<p>注意一个函数定义有多个模式不是所谓的重载(multiple definition)； 一个函数只有一个定义。 在上面的示例中，&quot;n&quot;必须与&quot;0&quot;或&quot;1&quot;属于同一类型。 此外，与 <code>match</code> 一样，模式匹配是从上到下完成的。</p>
<p>如果不同类的实例混合在一起，最后一个定义必须指定函数参数的类型为<code>Or</code></p>
<pre><code class="language-python">f &quot;aa&quot; = ...
f 1 = ...
# `f x = ... ` 无效
f x: Int or Str = ...
</code></pre>
<p>此外，像 <code>match</code> 一样，它也必须是详尽的。</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
# 模式错误：fib 参数的模式并不详尽
</code></pre>
<p>但是，可以通过使用稍后描述的 <a href="./type/12_refinement.html">refinement type</a> 显式指定类型来使其详尽无遗。</p>
<pre><code class="language-python">fib: 0..1 -&gt; 0..1
fib 0 = 0
fib 1 = 1
# OK
</code></pre>
<h2 id="递归函数"><a class="header" href="#递归函数">递归函数</a></h2>
<p>递归函数是在其定义中包含自身的函数。</p>
<p>作为一个简单的例子，让我们定义一个执行阶乘计算的函数<code>factorial</code>。 阶乘是&quot;将所有小于或等于的正数相乘&quot;的计算。
5 的阶乘是 <code>5*4*3*2*1 == 120</code>。</p>
<pre><code class="language-python">factorial 0 = 1
factorial 1 = 1
factorial(n: Nat): Nat = n * factorial(n - 1)
</code></pre>
<p>首先，从阶乘的定义来看，0和1的阶乘都是1。
反过来，2的阶乘是<code>2*1 == 2</code>，3的阶乘是<code>3*2*1 == 6</code>，4的阶乘是<code>4*3*2*1 == 24 </code>。
如果我们仔细观察，我们可以看到一个数 n 的阶乘是前一个数 n-1 乘以 n 的阶乘。
将其放入代码中，我们得到 <code>n * factorial(n - 1)</code>。
由于 <code>factorial</code> 的定义包含自身，<code>factorial</code> 是一个递归函数。</p>
<p>提醒一下，如果您不添加类型规范，则会这样推断。</p>
<pre><code class="language-python">factorial: |T &lt;: Sub(Int, T) and Mul(Int, Int) and Eq(Int)| T -&gt; Int
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial(n - 1)
</code></pre>
<p>但是，即使您可以推理，您也应该明确指定递归函数的类型。 在上面的例子中，像&quot;factorial(-1)&quot;这样的代码可以工作，但是</p>
<pre><code class="language-python">factorial(-1) == -1 * factorial(-2) == -1 * -2 * factorial(-3) == ...
</code></pre>
<p>并且这种计算不会停止。 递归函数必须仔细定义值的范围，否则您可能会陷入无限循环。
所以类型规范也有助于避免接受意外的值。</p>
<h2 id="编译时函数"><a class="header" href="#编译时函数">编译时函数</a></h2>
<p>函数名以大写字母开头，表示编译时函数。 用户定义的编译时函数必须将所有参数作为常量，并且必须指定它们的类型。
编译时函数的功能有限。 在编译时函数中只能使用常量表达式，即只有一些运算符(例如求积、比较和类型构造操作)和编译时函数。 要传递的参数也必须是常量表达式。
作为回报，优点是计算可以在编译时完成。</p>
<pre><code class="language-python">Add(X, Y: Nat): Nat = X + Y
assert Add(1, 2) == 3

Factorial 0 = 1
Factorial(X: Nat): Nat = X * Factorial(X - 1)
assert Factorial(10) == 3628800

math = import &quot;math&quot;
Sin X = math.sin X # 常量错误：此函数在编译时不可计算
</code></pre>
<p>编译时函数也用于多态类型定义。</p>
<pre><code class="language-python">Option T: Type = T or NoneType
Option: Type -&gt; Type
</code></pre>
<h2 id="附录功能对比"><a class="header" href="#附录功能对比">附录：功能对比</a></h2>
<p>Erg 没有为函数定义 <code>==</code>。 这是因为通常没有函数的结构等价算法。</p>
<pre><code class="language-python">f = x: Int -&gt; (x + 1)**2
g = x: Int -&gt; x**2 + 2x + 1

assert f == g # 类型错误：无法比较函数
</code></pre>
<p>尽管 <code>f</code> 和 <code>g</code> 总是返回相同的结果，但要做出这样的决定是极其困难的。 我们必须向编译器教授代数。
所以 Erg 完全放弃了函数比较，并且 <code>(x -&gt; x) == (x -&gt; x)</code> 也会导致编译错误。 这是与 Python 不同的规范，应该注意</p>
<pre><code class="language-python"># Python，奇怪的例子
f = lambda x: x
assert f == f
assert (lambda x: x) ! = (lambda x: x)
</code></pre>
<h2 id="appendix2--completion"><a class="header" href="#appendix2--completion">Appendix2: ()-completion</a></h2>
<pre><code class="language-python">f x: Object = ...
# 将完成到
f(x: Object) = ...

f a
# 将完成到
f(a)

f a, b # 类型错误：f() 接受 1 个位置参数，但给出了 2 个
f(a, b) # # 类型错误：f() 接受 1 个位置参数，但给出了 2 个
f((a, b)) # OK
</code></pre>
<p>函数类型<code>T -&gt; U</code>实际上是<code>(T,) -&gt; U</code>的语法糖。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="内置函数"><a class="header" href="#内置函数">内置函数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/05_builtin_funcs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/05_builtin_funcs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="如果"><a class="header" href="#如果">如果</a></h2>
<p><code>if</code> 是一个根据条件改变处理的函数。</p>
<pre><code class="language-python">result: Option Int = if! Bool.sample!(), do:
    log &quot;True was chosen&quot;
    1
print! result # None (or 1)
</code></pre>
<p><code>.sample!()</code> 返回一组随机值。 如果返回值为真，<code>print! &quot;真&quot;</code>被执行。
如果条件为假，您还可以指定要执行的操作； 第二个 do 块称为 else 块。</p>
<pre><code class="language-python">result: Nat = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
print! result # 1 (or 0)
</code></pre>
<p>如果进程是单行，则可以省略缩进。</p>
<pre><code class="language-python">result = if Bool.sample!():
    do 1
    do 0
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>你可以使用 <code>for</code> 来编写一个重复的过程。</p>
<pre><code class="language-python">match_s(ss: Iterator(Str), pat: Pattern): Option Str =
    for ss, s -&gt;
        if pat.match(s).is_some():
            break s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="运算符"><a class="header" href="#运算符">运算符</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/06_operator.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/06_operator.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>运算符是表示操作的符号。 操作数是运算符(左)右侧的东西。</p>
<p>运算符是一种函数，因此它们本身就是可以绑定到变量的一流对象。 绑定时，需要用```括起来。
对于<code>+</code>(和<code>-</code>)，有一元和二元运算符，所以必须指定<code>_+_</code>(二元运算)/<code>+_</code>(一元运算)。</p>
<pre><code class="language-python">add = `+` # 语法错误：指定 `_+_` 或 `+_`
add=`_+_`
assert f(1, 2) == 3
assert f(&quot;a&quot;, &quot;b&quot;) == &quot;ab&quot;

g = `*` # OK, 这只是二进制
assert g(1, 2) == 2
</code></pre>
<p>一些称为特殊形式的基本运算符不能被绑定。</p>
<pre><code class="language-python">def = `=` # 语法错误：无法绑定 `=` 运算符，这是一种特殊形式
# NG: def x, 1
function = `-&gt;` # 语法错误：无法绑定 `-&gt;` 运算符，这是一种特殊形式
# NG: function x, x + 1
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="副作用和程序"><a class="header" href="#副作用和程序">副作用和程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/07_side_effect.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/07_side_effect.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>我们一直忽略了解释&quot;！&quot;的含义，但现在它的含义终于要揭晓了。 这个 <code>!</code> 表示这个对象是一个带有&quot;副作用&quot;的&quot;过程&quot;。 过程是具有副作用的函数。</p>
<pre><code class="language-python">f x = print! x # EffectError: 不能为函数分配有副作用的对象
# 提示：将名称更改为 'f!'
</code></pre>
<p>上面的代码会导致编译错误。 这是因为您在函数中使用了过程。 在这种情况下，您必须将其定义为过程。</p>
<pre><code class="language-python">p! x = print! x
</code></pre>
<p><code>p!</code>, <code>q!</code>, ... 是过程的典型变量名。
以这种方式定义的过程也不能在函数中使用，因此副作用是完全隔离的。</p>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>函数和过程中的每一个都可以是方法。 函数式方法只能对<code>self</code>进行不可变引用，而程序性方法可以对<code>self</code>进行可变引用。
<code>self</code> 是一个特殊的参数，在方法的上下文中是指调用对象本身。 引用 <code>self</code> 不能分配给任何其他变量。</p>
<pre><code class="language-python">C!.
    method ref self =
        x = self # 所有权错误：无法移出`self`
        x
</code></pre>
<p>程序方法也可以采取 <code>self</code> 的 <a href="./18_ownership.html">ownership</a>。 从方法定义中删除 <code>ref</code> 或 <code>ref!</code></p>
<pre><code class="language-python">n = 1
s = n.into(Str) # '1'
n # 值错误：n 被 .into 移动(第 2 行)
</code></pre>
<p>在任何给定时间，只有一种程序方法可以具有可变引用。 此外，在获取可变引用时，不能从原始对象获取更多可变引用。 从这个意义上说，<code>ref!</code> 会对<code>self</code> 产生副作用。</p>
<p>但是请注意，可以从可变引用创建(不可变/可变)引用。 这允许在程序方法中递归和 <code>print!</code> 的<code>self</code>。</p>
<pre><code class="language-python">T -&gt; T # OK (move)
T -&gt; Ref T # OK (move)
T =&gt; Ref! T # OK (only once)
Ref T -&gt; T # NG
Ref T -&gt; Ref T # OK
Ref T =&gt; Ref!
T -&gt; Ref T # NG
T -&gt; Ref T # OK
T =&gt; Ref!
</code></pre>
<h2 id="附录副作用的严格定义"><a class="header" href="#附录副作用的严格定义">附录：副作用的严格定义</a></h2>
<p>代码是否具有副作用的规则无法立即理解。
直到你能理解它们，我们建议你暂时把它们定义为函数，如果出现错误，添加<code>！</code>将它们视为过程。
但是，对于那些想了解该语言的确切规范的人，以下是对副作用的更详细说明。</p>
<p>首先，必须声明返回值的等价与 Erg 中的副作用无关。
有些过程对于任何给定的 <code>x</code> 都会导致 <code>p!(x) == p!(x)</code>(例如，总是返回 <code>None</code>)，并且有些函数会导致 <code>f(x) ！ = f(x)</code>。</p>
<p>前者的一个例子是<code>print!</code>，后者的一个例子是下面的函数。</p>
<pre><code class="language-python">nan _ = Float.NaN
assert nan(1) ! = nan(1)
</code></pre>
<p>还有一些对象，例如类，等价确定本身是不可能的</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}
assert T == U

C = Class {i = Int}
D = Class {i = Int}
assert C == D # 类型错误：无法比较类
</code></pre>
<p>言归正传：Erg 中&quot;副作用&quot;的准确定义是</p>
<ul>
<li>访问可变的外部信息。</li>
</ul>
<p>&quot;外部&quot;一般是指外部范围； Erg 无法触及的计算机资源和执行前/执行后的信息不包含在&quot;外部&quot;中。 &quot;访问&quot;包括阅读和写作。</p>
<p>例如，考虑 <code>print!</code> 过程。 乍一看，<code>print!</code> 似乎没有重写任何变量。 但如果它是一个函数，它可以重写外部变量，例如，使用如下代码：</p>
<pre><code class="language-python">camera = import &quot;some_camera_module&quot;
ocr = import &quot;some_ocr_module&quot;

n = 0
_ =
    f x = print x # 假设我们可以使用 print 作为函数
    f(3.141592)
cam = camera.new() # 摄像头面向 PC 显示器
image = cam.shot!()
n = ocr.read_num(image) # n = 3.141592
</code></pre>
<p>将&quot;camera&quot;模块视为为特定相机产品提供 API 的外部库，将&quot;ocr&quot;视为用于 OCR(光学字符识别)的库。
直接的副作用是由 <code>cam.shot!()</code> 引起的，但显然这些信息是从 <code>f</code> 泄露的。 因此，<code>print!</code> 本质上不可能是一个函数。</p>
<p>然而，在某些情况下，您可能希望临时检查函数中的值，而不想为此目的在相关函数中添加 <code>!</code>。 在这种情况下，可以使用 <code>log</code> 函数。
<code>log</code> 打印整个代码执行后的值。 这样，副作用就不会传播。</p>
<pre><code class="language-python">log &quot;this will be printed after execution&quot;
print! &quot;this will be printed immediately&quot;
# 这将立即打印
# 这将在执行后打印
</code></pre>
<p>如果没有反馈给程序，或者换句话说，如果没有外部对象可以使用内部信息，那么信息的&quot;泄漏&quot;是可以允许的。 只需要不&quot;传播&quot;信息。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="程序"><a class="header" href="#程序">程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/08_procedure.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/08_procedure.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>处理可变对象时需要过程，但将可变对象作为参数并不一定使其成为过程。
这是一个函数接受一个可变对象(不是过程)。</p>
<pre><code class="language-python">peek_str s: Str! = log s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="内置程序"><a class="header" href="#内置程序">内置程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/09_builtin_procs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/09_builtin_procs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="id"><a class="header" href="#id">id！</a></h2>
<p>返回对象的唯一标识号。
尽管在纯 Erg 语义中，结构相同的对象之间没有区别，但实际上对象在内存中具有不同的位置。
<code>id!</code> 返回一个代表这个位置的数字。</p>
<pre><code class="language-python"></code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/10_array.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/10_array.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>数组是最基本的__collection(聚合)__。
集合是一个可以在其中包含多个对象的对象。</p>
<pre><code class="language-python">a = [1, 2, 3]
a: [Int; 3] # 类型说明：分号后的数字为元素个数
# 如果元素个数未知，可以省略
a: [Int]

mut_a = [!1, !2, !3]
mut_a[0].inc!()
assert mut_a == [2, 2, 3]
</code></pre>
<p>通常，数组不能包含不同类型的对象。</p>
<pre><code class="language-python.">[1, &quot;a&quot;] # 类型错误：第一个元素是 Int，但第二个元素是 Str
</code></pre>
<p>但是，您可以通过像这样显式指定类型来绕过限制。</p>
<pre><code class="language-python">[1, &quot;a&quot;]: [Int or Str].
</code></pre>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<p>一个数组也可以同时取出多个值。 这称为切片。</p>
<pre><code class="language-python">l = [1, 2, 3, 4]
# 与 Python 中的 l[1:3] 相同
assert l[1.. &lt;3] == [2, 3]
assert l[1..2] == [2, 3]
# 与 l[1] 相同
assert l[1..1] == [2]
# 与 Python 中的 l[::2] 相同
assert l[..].step(2) == [2, 4]
</code></pre>
<p>通过切片获得的对象是数组的(不可变的)副本</p>
<pre><code class="language-python">print! Typeof l[1..2] # [Int; 4]
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/11_tuple.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/11_tuple.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>元组类似于数组，但可以保存不同类型的对象。
这样的集合称为不等集合。 相比之下，同构集合包括数组、集合等。</p>
<pre><code class="language-python">t = (1, True, &quot;a&quot;)
(i, b, s) = t
assert(i == 1 and b == True and s == &quot;a&quot;)
</code></pre>
<p>元组<code>t</code>可以以<code>t.n</code>的形式检索第n个元素； 请注意，与 Python 不同，它不是 <code>t[n]</code>。
这是因为访问元组元素更像是一个属性(在编译时检查元素的存在，并且类型可以根据 <code>n</code> 改变)而不是方法(数组的 <code>[]</code> 是一种方法)。</p>
<pre><code class="language-python">assert t.0 == 1
assert t.1 == True
assert t.2 == &quot;a&quot;
</code></pre>
<p>括号 <code>()</code> 在不嵌套时是可选的。</p>
<pre><code class="language-python">t = 1, True, &quot;a&quot;
i, b, s = t
</code></pre>
<p>元组可以保存不同类型的对象，因此它们不能像数组一样被迭代。</p>
<pre><code class="language-python">t: ({1}, {2}, {3}) = (1, 2, 3)
(1, 2, 3).iter().map(x -&gt; x + 1) # 类型错误：类型 ({1}, {2}, {3}) 没有方法 `.iter()`
# 如果所有类型都相同，则可以像数组一样用`(T; n)`表示，但这仍然不允许迭代
t: (Int; 3) = (1, 2, 3)
assert (Int; 3) == (Int, Int, Int)
</code></pre>
<p>但是，非同质集合(如元组)可以通过向上转换、相交等方式转换为同质集合(如数组)。
这称为均衡。</p>
<pre><code class="language-python">(Int, Bool, Str) can be [T; 3] where T :&gt; Int, T :&gt; Bool, T :&gt; Str
</code></pre>
<pre><code class="language-python">t: (Int, Bool, Str) = (1, True, &quot;a&quot;) # 非同质
a: [Int or Bool or Str; 3] = [1, True, &quot;a&quot;] # 同质的
_a: [Show; 3] = [1, True, &quot;a&quot;] # 同质的
_a.iter().map(x -&gt; log x) # OK
t.try_into([Show; 3])? .iter().map(x -&gt; log x) # OK
</code></pre>
<h2 id="单元"><a class="header" href="#单元">单元</a></h2>
<p>零元素的元组称为 <strong>unit</strong>。 一个单元是一个值，但也指它自己的类型。</p>
<pre><code class="language-python">unit = ()
(): ()
</code></pre>
<p>Unit 是所有元素 0 元组的父类。</p>
<pre><code class="language-python">() &gt; (Int; 0)
() &gt; (Str; 0)
</code></pre>
<p>该对象的用途是用于没有参数和没有返回值的过程等。Erg 子例程必须有参数和返回值。 但是，在某些情况下，例如过程，可能没有有意义的参数或返回值，只有副作用。 在这种情况下，我们将单位用作&quot;无意义的正式值&quot;</p>
<pre><code class="language-python"># ↓ Actually, this parenthesis is a unit
p!() =.
    # `print!` does not return a meaningful value
    print! &quot;Hello, world!&quot;
p!: () =&gt; ()
</code></pre>
<p>但是，在这种情况下，Python 倾向于使用&quot;无&quot;而不是单位。
在 Erg 中，当您从一开始就确定操作不会返回有意义的值(例如在过程中)时，您应该使用 <code>()</code>，并且当操作可能失败并且您可能会返回 <code>None</code> 将一无所获，例如在检索元素时。</p>
<h2 id="参数和元组"><a class="header" href="#参数和元组">参数和元组</a></h2>
<p>实际上，Erg 的所有 <code>Callable</code> 对象都是一个参数和一个返回值； 一个接受 N 个参数的子例程只是接收&quot;一个具有 N 个元素的元组&quot;作为参数。</p>
<pre><code class="language-python"># f x = ... 被隐式假设为 f(x) = ... 被认为是
f x = x
assert f(1) == 1
f(1, 2, 3) # 参数错误：f 接受 1 个位置参数，但给出了 3 个
g x: Int, . . y: Int = y
assert (2, 3) == g 1, 2, 3
</code></pre>
<p>这也解释了函数类型。</p>
<pre><code class="language-python">assert f in T: {(T,) -&gt; T | T}
assert g in {(Int, ... (Int; N)) -&gt; (Int; N) | N: Nat}
</code></pre>
<p>准确地说，函数的输入不是元组，而是&quot;具有默认属性的命名元组&quot;。 这是一个特殊的元组，只能在函数参数中使用，可以像记录一样命名，并且可以有默认值。</p>
<pre><code class="language-python">f(x: Int, y=0) = x + y
f: (Int, y=Int) -&gt; Int

f(x=0, y=1)
f(y=1, x=0)
f(x=0)
f(0)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="字典"><a class="header" href="#字典">字典</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/12_dict.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/12_dict.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Dict 是键/值对的集合。</p>
<pre><code class="language-python">ids = {&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301}
assert ids[&quot;Alice&quot;] == 145
</code></pre>
<p>如果键是&quot;哈希&quot;对象，则键不必是字符串。</p>
<pre><code class="language-python"># 不推荐使用范围对象作为键(与切片混淆)
r = {1..3: &quot;1~3&quot;, 4..6: &quot;4~6&quot;, 7..9: &quot;7~9&quot;}
assert r[1..3] == &quot;1~3&quot;
l = {[]: &quot;empty&quot;, [1]: &quot;1&quot;}
assert l[[]] == &quot;empty&quot;
</code></pre>
<p>对于字典来说，顺序无关紧要。 它也不能有重复的元素。 在这方面，Dict 与 Set 类似。
您可以说 Dict 是具有值的 Set。</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301} == {&quot;Alice&quot;: 145, &quot;Charlie&quot;: 301, &quot;Bob&quot;: 214}
</code></pre>
<p>从 dict 文字生成 dict 时，会检查重复键。
任何重复都会导致编译错误。</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Alice&quot;: 1} # Key错误：重复键`Alice`
</code></pre>
<p>空字典是用 <code>{:}</code> 创建的。 请注意，<code>{}</code> 表示一个空集。</p>
<pre><code class="language-python">mut_dict = !{:}
mut_dict.insert! &quot;Alice&quot;, 145
mut_dict.insert! &quot;Bob&quot;, 214
assert mut_dict[&quot;Alice&quot;] == 145
</code></pre>
<h2 id="异构字典"><a class="header" href="#异构字典">异构字典</a></h2>
<p>不需要有单一的键/值类型。 这样的字典称为 _<em>heterogenous dict</em>。</p>
<pre><code class="language-python">d: {Str: Int, Int: Str} = {&quot;a&quot;: 1, 1: &quot;a&quot;}
assert d[&quot;a&quot;] == 1
assert d[1] == &quot;a&quot;
</code></pre>
<p>但是，不能将相同类型的值分配给不同类型的键，或者将不同类型的值分配给相同类型的键。
在这种情况下，请改用 Or 类型。</p>
<pre><code class="language-python">invalid1 = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
invalid2 = {1: &quot;a&quot;, 2: 2}

# Erg 类型推断不推断 Or 类型，因此需要类型说明
valid1: {Int or Str: Str} = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
valid2: {Int: Int or Str} = {1: &quot;a&quot;, 2: 2}
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="记录record"><a class="header" href="#记录record">记录(Record)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/13_record.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/13_record.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>记录是一个集合，它结合了通过键访问的 Dict 和在编译时检查其访问的元组的属性。
如果您了解 JavaScript，请将其视为一种(更增强的)对象字面量表示法。</p>
<pre><code class="language-python">john = {.name = &quot;John&quot;; .age = 21}

assert john.name == &quot;John&quot;
assert john.age == 21
assert john in {.name = Str; .age = Nat}
john[&quot;name&quot;] # 错误：john 不可订阅
</code></pre>
<p><code>.name</code> 和 <code>.age</code> 部分称为属性，而 <code>&quot;John&quot;</code> 和 <code>21</code> 部分称为属性值。</p>
<p>与 JavaScript 对象字面量的区别在于它们不能作为字符串访问。 也就是说，属性不仅仅是字符串。
这是因为对值的访问是在编译时确定的，而且字典和记录是不同的东西。 换句话说，<code>{&quot;name&quot;: &quot;John&quot;}</code> 是一个字典，<code>{name = &quot;John&quot;}</code> 是一个记录。
那么我们应该如何使用字典和记录呢?
一般来说，我们建议使用记录。 记录具有在编译时检查元素是否存在以及能够指定 _<em>visibility</em> 的优点。
指定可见性等同于在 Java 和其他语言中指定公共/私有。 有关详细信息，请参阅 <a href="./19_visibility.html">可见性</a> 了解详细信息。</p>
<pre><code class="language-python">a = {x = 1; .y = x + 1}
a.x # 属性错误：x 是私有的
# 提示：声明为 `.x`。
assert a.y == 2
</code></pre>
<p>对于熟悉 JavaScript 的人来说，上面的示例可能看起来很奇怪，但简单地声明 <code>x</code> 会使其无法从外部访问</p>
<p>您还可以显式指定属性的类型</p>
<pre><code class="language-python">anonymous = {
    .name: Option! Str = !
    .age = 20
}
anonymous.name.set! &quot;John&quot;
</code></pre>
<p>一个记录也可以有方法。</p>
<pre><code class="language-python">o = {
    .i = !0
    .inc! ref! self = self.i.inc!()
}

assert o.i == 0
o.inc!()
assert o.i == 1
</code></pre>
<p>关于记录有一个值得注意的语法。 当记录的所有属性值都是类(不是结构类型)时，记录本身表现为一个类型，其自身的属性作为必需属性。
这种类型称为记录类型。 有关详细信息，请参阅 [记录] 部分。</p>
<pre><code class="language-python"># 记录
john = {.name = &quot;John&quot;}
# 记录 type
john: {.name = Str}
Named = {.name = Str}
john: Named

greet! n: Named =
    print! &quot;Hello, I am {n.name}&quot;
john # &quot;你好，我是约翰 print！

Named.name # Str
</code></pre>
<h2 id="解构记录"><a class="header" href="#解构记录">解构记录</a></h2>
<p>记录可以按如下方式解构。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x = a; y = b} = record
assert a == 1
assert b == 2

point = {x = 2; y = 3; z = 4}
match point:
    {x = 0; y = 0; z = 0} -&gt; &quot;origin&quot;
    {x = _; y = 0; z = 0} -&gt; &quot;on the x axis&quot;
    {x = 0; ...} -&gt; &quot;x = 0&quot;
    {x = x; y = y; z = z} -&gt; &quot;({x}, {y}, {z})&quot;
</code></pre>
<p>当存在与属性同名的变量时，<code>x = ...</code>也可以缩写为<code>x</code>，例如<code>x = x</code>或<code>x = .x</code>到<code>x</code>，和<code> .x = .x</code> 或 <code>.x = x</code> 到 <code>.x</code>。
但是，当只有一个属性时，必须在其后加上<code>;</code>以与集合区分开来。</p>
<pre><code class="language-python">x = 1
y = 2
xy = {x; y}
a = 1
b = 2
ab = {.a; .b}
assert ab.a == 1
assert ab.b == 2

record = {x;}
tuple = {x}
assert tuple.1 == 1
</code></pre>
<p>此语法可用于解构记录并将其分配给变量</p>
<pre><code class="language-python"># 一样 `{x = x; y = y} = xy`
{x; y} = xy
assert x == 1
assert y == 2
# 一样 `{.a = a; .b = b} = ab`
{a; b} = ab
assert a == 1
assert b == 2
</code></pre>
<h2 id="空记录"><a class="header" href="#空记录">空记录</a></h2>
<p>空记录由<code>{=}</code>表示。 空记录也是它自己的类，如 Unit</p>
<pre><code class="language-python">empty_record = {=}
empty_record: {=}
# Object: Type = {=}
empty_record: Object
empty_record: Structural {=}
{x = 3; y = 5}: Structural {=}
</code></pre>
<p>空记录不同于空 Dict <code>{:}</code> 或空集 <code>{}</code>。 特别要注意的是，它与 <code>{}</code> 的含义相反(在 Python 中，<code>{}</code> 是一个空字典，而在 Erg 中它是 Erg 中的 <code>!{:}</code>)。
作为枚举类型，<code>{}</code> 是一个空类型，其元素中不包含任何内容。 <code>Never</code> 类型是这种类型的一个分类。
相反，记录类 <code>{=}</code> 没有必需的实例属性，因此所有对象都是它的元素。 <code>Object</code> 是 this 的别名。
一个<code>Object</code>(<code>Object</code>的一个补丁)是<code>的一个元素。 __sizeof__</code> 和其他非常基本的提供方法。</p>
<pre><code class="language-python">AnyPatch = Patch Structural {=}
    . __sizeof__ self = ...
    .clone self = ...
    ...
Never = Class {}
</code></pre>
<p>请注意，没有其他类型或类在结构上与 <code>{}</code>、<code>Never</code> 类型等效，如果用户在右侧使用 <code>{}</code>、<code>Class {}</code> 定义类型，则会出错。
这意味着，例如，<code>1..10 或 -10。 -1</code>，但 <code>1..10 和 -10... -1</code>。 例如，当它应该是 1..10 或 -10...-1 时是 <code>-1</code>。
此外，如果您定义的类型(例如 <code>Int 和 Str</code>)会导致组合 <code>Object</code>，则会警告您只需将其设置为 <code>Object</code>。</p>
<h2 id="即时封锁"><a class="header" href="#即时封锁">即时封锁</a></h2>
<p>Erg 有另一种语法 Instant 块，它只返回最后评估的值。 不能保留属性。</p>
<pre><code class="language-python">x =
    x = 1
    y = x + 1
    y ** 3
assert x == 8

y =
    .x = 1 # 语法错误：无法在实体块中定义属性
</code></pre>
<h2 id="数据类"><a class="header" href="#数据类">数据类</a></h2>
<p>如果您尝试自己实现方法，则必须直接在实例中定义裸记录(由记录文字生成的记录)。
这是低效的，并且随着属性数量的增加，错误消息等变得难以查看和使用。</p>
<pre><code class="language-python">john = {
    name = &quot;John Smith&quot;
    age = !20
    .greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    .inc_age! ref! self = self::age.update! x -&gt; x + 1
}
john + 1
# 类型错误：{name = Str; 没有实现 + 年龄=诠释； 。迎接！ =参考(自我)。 () =&gt; 无； inc_age！ =参考！ () =&gt; 无}, 整数
</code></pre>
<p>因此，在这种情况下，您可以继承一个记录类。 这样的类称为数据类。
这在 <a href="./type/04_class.html">class</a> 中有描述。</p>
<pre><code class="language-python">Person = Inherit {name = Str; age = Nat}
Person.
    greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    inc_age! ref! self = self::age.update! x -&gt; x + 1

john = Person.new {name = &quot;John Smith&quot;; age = 20}
john + 1
# 类型错误：Person、Int 没有实现 +
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/14_set.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/14_set.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>一个Set代表一个集合，它在结构上是一个重复的无序数组。</p>
<pre><code class="language-python">assert Set.from([1, 2, 3, 2, 1]) == {1, 2, 3}
assert {1, 2} == {1, 1, 2} # 重复的被自动删除
assert {1, 2} == {2, 1}
</code></pre>
<p>Set可以执行集合操作。</p>
<pre><code class="language-python">assert 1 in {1, 2, 3}
assert not 1 in {}
assert {1} or {2} == {1, 2}
assert {1, 2} and {2, 3} == {2}
assert {1, 2} not {2} == {1}
</code></pre>
<p>Set是同质集合。 为了使不同类的对象共存，它们必须同质化</p>
<pre><code class="language-python">s: {Int or Str} = {&quot;a&quot;, 1, &quot;b&quot;, -1}
</code></pre>
<h2 id="sets为类型"><a class="header" href="#sets为类型">Sets为类型</a></h2>
<p>Sets也可以被视为类型。 这种类型称为 <em>枚举类型</em>。</p>
<pre><code class="language-python">i: {1, 2, 3} = 1
assert i in {1, 2, 3}
</code></pre>
<p>Set的元素直接是类型的元素。
请注意，这些Set本身是不同的。</p>
<pre><code class="language-python">mut_set = {1, 2, 3}.into {Int; !3}
mut_set.insert!(4)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型"><a class="header" href="#类型">类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/15_type.md&amp;commit_hash=d15cbbf7b33df0f78a575cff9679d84c36ea3ab1"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/15_type.md%26commit_hash%3Dd15cbbf7b33df0f78a575cff9679d84c36ea3ab1" alt="badge" /></a></p>
<p>类型是 Erg 中一个非常重要的特性，所以我们有一个 <a href="./type/01_type_system.html">dedicated section</a>。 请看那里。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erg-的类型系统"><a class="header" href="#erg-的类型系统">Erg 的类型系统</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/01_type_system.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/01_type_system.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>下面简单介绍一下 Erg 的类型系统。 详细信息在其他部分进行说明。</p>
<h2 id="如何定义"><a class="header" href="#如何定义">如何定义</a></h2>
<p>Erg 的独特功能之一是(普通)变量、函数(子例程)和类型(Kind)定义之间的语法没有太大区别。 所有都是根据普通变量和函数定义的语法定义的。</p>
<pre><code class="language-python">f i: Int = i + 1
f # &lt;函数 f&gt;
f(1) # 2
f.method self = ... # 语法错误：无法为子例程定义方法

T I: Int = {...}
T # &lt;kind 'T'&gt;
T(1) # 类型 T(1)
T.method self = ...
D = Class {private = Int; .public = Int}
D # &lt;类 'D'&gt;
o1 = {private = 1; .public = 2} # o1 是一个不属于任何类的对象
o2 = D.new {private = 1; .public = 2} # o2 是 D 的一个实例
o2 = D.new {.public = 2} # 初始化错误：类 'D' 需要属性 'private'(: Int) 但未定义
</code></pre>
<h2 id="classification"><a class="header" href="#classification">Classification</a></h2>
<p>Erg 中的所有对象都是强类型的。
顶层类型是<code>{=}</code>，实现了<code>__repr__</code>、<code>__hash__</code>、<code>clone</code>等(不是必须的方法，这些属性不能被覆盖)。
Erg 的类型系统包含结构子类型 (SST)。 该系统类型化的类型称为结构类型。
结构类型主要分为三种：Attributive(属性类型)、Refinement(细化类型)和Algebraic(代数类型)。</p>
<table><thead><tr><th></th><th>Record</th><th>Enum</th><th>Interval</th><th>Union</th><th>Intersection</th><th>Diff</th></tr></thead><tbody>
<tr><td>kind</td><td>Attributive</td><td>Refinement</td><td>Refinement</td><td>Algebraic</td><td>Algebraic</td><td>Algebraic</td></tr>
<tr><td>generator</td><td>record</td><td>set</td><td>range operator</td><td>or operator</td><td>and operator</td><td>not operator</td></tr>
</tbody></table>
<p>也可以使用名义子类型(NST)，将 SST 类型转换为 NST 类型称为类型的名义化。 结果类型称为名义类型。
在 Erg 中，名义类型是类和特征。 当我们简单地说类/特征时，我们通常指的是记录类/特征。</p>
<table><thead><tr><th></th><th>Type</th><th>Abstraction</th><th>Subtyping procedure</th></tr></thead><tbody>
<tr><td>NST</td><td>NominalType</td><td>Trait</td><td>Inheritance</td></tr>
<tr><td>SST</td><td>StructuralType</td><td>Structural Trait</td><td>(Implicit)</td></tr>
</tbody></table>
<p>整个名义类型的类型(<code>NominalType</code>)和整个结构类型的类型(<code>StructuralType</code>)是整个类型(<code>Type</code>)的类型的子类型。</p>
<p>Erg 可以将参数(类型参数)传递给类型定义。带有类型参数的 <code>Option</code>、<code>Array</code> 等称为多项式类型。这些本身不是类型，但它们通过应用参数成为类型。诸如 <code>Int</code>、<code>Str</code> 等没有参数的类型称为简单类型(标量类型)。</p>
<p>一个类型可以看成一个集合，并且存在包含关系。例如，&quot;Num&quot;包含&quot;Add&quot;、&quot;Sub&quot;等，&quot;Int&quot;包含&quot;Nat&quot;。
所有类的上类是<code>Object == Class {:}</code>，所有类型的下类是<code>Never == Class {}</code>。这在下面描述。</p>
<h2 id="类型-1"><a class="header" href="#类型-1">类型</a></h2>
<p>像 <code>Array T</code> 这样的类型可以看作是 <code>Type -&gt; Type</code> 类型的函数，它以 <code>T</code> 类型为参数并返回 <code>Array T</code> 类型(在类型论中也称为 Kind)。像 <code>Array T</code> 这样的类型专门称为多态类型，而 <code>Array</code> 本身称为一元 Kind。</p>
<p>已知参数和返回类型的函数的类型表示为<code>(T, U) -&gt; V</code>。如果要指定同一类型的整个双参数函数，可以使用 <code>|T| (T, T) -&gt; T</code>，如果要指定整个 N 参数函数，可以使用 <code>Func N</code>。但是，<code>Func N</code> 类型没有关于参数数量或其类型的信息，因此所有返回值在调用时都是<code>Obj</code> 类型。</p>
<p><code>Proc</code> 类型表示为 <code>() =&gt; Int</code> 等等。此外，<code>Proc</code> 类型实例的名称必须以 <code>!</code> 结尾。</p>
<p><code>Method</code> 类型是一个函数/过程，其第一个参数是它所属的对象 <code>self</code>(通过引用)。对于依赖类型，也可以在应用方法后指定自己的类型。这是 <code>T!(!N)</code> 类型和 <code>T!(N ~&gt; N-1)。 () =&gt; Int</code> 等等。</p>
<p>Erg 的数组(Array)就是 Python 所说的列表。 <code>[诠释; 3]</code>是一个数组类，包含三个<code>Int</code>类型的对象。</p>
<blockquote>
<p><strong>Note</strong>: <code>(Type; N)</code> 既是类型又是值，所以可以这样使用。</p>
<pre><code class="language-python.">Types = (Int, Str, Bool)

for! Types, T =&gt;
    print! T
# Int Str Bool
a: Types = (1, &quot;aaa&quot;, True)
</code></pre>
</blockquote>
<pre><code class="language-python">pop|T, N|(l: [T; N]): ([T; N-1], T) =
    [...l, last] = l
    (l, last)

lpop|T, N|(l: [T; N]): (T, [T; N-1]) =
    [first, ...l] = l
    (first, l)
</code></pre>
<p>以 <code>!</code> 结尾的类型可以重写内部结构。 例如，<code>[T; !N]</code> 类是一个动态数组。
要从&quot;T&quot;类型的对象创建&quot;T!&quot;类型的对象，请使用一元运算符&quot;!&quot;。</p>
<pre><code class="language-python">i: Int! = !1
i.update! i -&gt; i + 1
assert i == 2
arr = [1, 2, 3]
arr.push! 4 # 导入错误
mut_arr = [1, 2, 3].into [Int; !3]
mut_arr.push4
assert mut_arr == [1, 2, 3, 4].
</code></pre>
<h2 id="类型定义"><a class="header" href="#类型定义">类型定义</a></h2>
<p>类型定义如下。</p>
<pre><code class="language-python">Point2D = {.x = Int; .y = Int}
</code></pre>
<p>请注意，如果从变量中省略 <code>.</code>，它将成为类型中使用的私有变量。 但是，这也是必需的属性。
由于类型也是对象，因此类型本身也有属性。 这样的属性称为类型属性。 在类的情况下，它们也称为类属性。</p>
<h2 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h2>
<p>如前所述，Erg 中的&quot;类型&quot;大致表示一组对象。</p>
<p>下面是 <code>Add</code> 类型的定义，需要 <code>+</code>(中间运算符)。 <code>R, O</code> 是所谓的类型参数，可以是真正的类型(类)，例如 <code>Int</code> 或 <code>Str</code>。 在其他语言中，类型参数被赋予特殊的符号(泛型、模板等)，但在 Erg 中，它们可以像普通参数一样定义。
类型参数也可以用于类型对象以外的类型。 例如数组类型<code>[Int; 3]</code> 是 <code>Array Int, 3</code> 的语法糖。 如果类型实现重叠，用户必须明确选择一个。</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}
</code></pre>
<p>.<code>_+_</code>是Add.<code>_+_</code>的缩写。 前缀运算符 .<code>+_</code> 是 <code>Num</code> 类型的方法。</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
NumImpl = Patch Num
NumImpl.
    `+_`(self): Self = self
    ...
</code></pre>
<p>多态类型可以像函数一样对待。 通过将它们指定为 <code>Mul Int、Str</code> 等，它们可以是单态的(在许多情况下，它们是用实际参数推断出来的，而没有指定它们)。</p>
<pre><code class="language-python">1 + 1
`_+_` 1, 1
Nat.`_+_` 1, 1
Int.`_+_` 1, 1
</code></pre>
<p>前四行返回相同的结果(准确地说，底部的返回 <code>Int</code>)，但通常使用顶部的。
<code>Ratio.</code><em>+</em><code>(1, 1)</code> 将返回 <code>2.0</code> 而不会出错。
这是因为 <code>Int &lt;: Ratio</code>，所以 <code>1</code> 向下转换为 <code>Ratio</code>。
但这不是演员。</p>
<pre><code class="language-python">i = 1
if i: # 类型错误：i：Int 不能转换为 Bool，请改用 Int.is_zero()。
    log &quot;a&quot;
    log &quot;b&quot;
</code></pre>
<p>这是因为 <code>Bool &lt;: Int</code> (<code>True == 1</code>, <code>False == 0</code>)。转换为子类型通常需要验证。</p>
<h2 id="类型推理系统"><a class="header" href="#类型推理系统">类型推理系统</a></h2>
<p>Erg 使用静态鸭子类型，因此几乎不需要显式指定类型。</p>
<pre><code class="language-python">f x, y = x + y
</code></pre>
<p>在上面的代码中，带有 <code>+</code> 的类型，即 <code>Add</code> 是自动推断的； Erg 首先推断出最小的类型。如果<code>f 0, 1</code>，它将推断<code>f x：{0}，y：{1}</code>，如果<code>n：Nat; f n, 1</code>，它会推断<code>f x: Nat, y: {1}</code>。最小化之后，增加类型直到找到实现。在 <code>{0}, {1}</code> 的情况下，<code>Nat</code> 与 <code>Nat</code> 是单态的，因为 <code>Nat</code> 是具有 <code>+</code> 实现的最小类型。
如果是 <code>{0}, {-1}</code>，它与 <code>Int</code> 是单态的，因为它不匹配 <code>Nat</code>。如果子类型和超类型之间没有关系，则首先尝试具有最低浓度(实例数)(或者在多态类型的情况下参数更少)的那个。
<code>{0}</code> 和 <code>{1}</code> 是枚举类型，它们是部分类型，例如 <code>Int</code> 和 <code>Nat</code>。
例如，可以为枚举类型指定名称和请求/实现方法。在有权访问该类型的命名空间中，满足请求的对象可以使用实现方法。</p>
<pre><code class="language-python">Binary = Patch {0, 1}
Binary.
    # self 包含一个实例。 在此示例中，为 0 或 1。
    # 如果你想重写self，你必须追加！ 必须添加到类型名称和方法名称。
    is_zero(self) = match self:
        0 -&gt; True
        1 -&gt; False # 你也可以使用 _ -&gt; False
    is_one(self) = not self.is_zero()
    to_bool(self) = match self:
        0 -&gt; False
        1 -&gt; True
</code></pre>
<p>此后，代码&quot;0.to_bool()&quot;是可能的(尽管&quot;0 as Bool == False&quot;是内置定义的)。
这是一个实际上可以重写 <code>self</code> 的类型的示例，如代码所示。</p>
<pre><code class="language-python">Binary! = Patch {0, 1}!
Binary!
    switch! ref! self = match! self:
        0 =&gt; self = 1
        1 =&gt; self = 0

b = !1
b.switch!()
print! b # =&gt; 0
</code></pre>
<h2 id="结构类型匿名类型"><a class="header" href="#结构类型匿名类型">结构类型(匿名类型)</a></h2>
<pre><code class="language-python">Binary = {0, 1}
</code></pre>
<p>上面代码中的 <code>Binary</code> 是一个类型，其元素是 <code>0</code> 和 <code>1</code>。 它也是 <code>Int</code> 类型的子类型，它同时具有 <code>0</code> 和 <code>1</code>。
像 <code>{}</code> 这样的对象本身就是一种类型，可以在分配或不分配给上述变量的情况下使用。
这样的类型称为结构类型。 当我们想强调它作为后者而不是类(命名类型)的用途时，它也被称为未命名类型。 <code>{0, 1}</code>这样的结构类型称为枚举类型，还有区间类型、记录类型等。</p>
<h3 id="类型标识"><a class="header" href="#类型标识">类型标识</a></h3>
<p>无法指定以下内容。 例如，您不能指定 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code>。
例如，<code>Int</code>和<code>Str</code>都是<code>Add</code>，但是<code>Int</code>和<code>Str</code>不能相加。</p>
<pre><code class="language-python">add l: Add, r: Add =
    l + r # 类型错误: `_+_` 没有实现: |T, U &lt;: Add| (T, U) -&gt; &lt;失败&gt;
</code></pre>
<p>此外，下面的类型 <code>A</code> 和 <code>B</code> 不被认为是同一类型。 但是，类型&quot;O&quot;被认为是匹配的</p>
<pre><code class="language-python">... |R1; R2; O; A &lt;: Add(R1, O); B &lt;: Add(R2, O)|
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="类型的基本语法"><a class="header" href="#类型的基本语法">类型的基本语法</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/02_basic.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/02_basic.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="类型规范"><a class="header" href="#类型规范">类型规范</a></h2>
<p>在 Erg 中，可以在 <code>:</code> 之后指定变量的类型，如下所示。这可以与作业同时完成。</p>
<pre><code class="language-python">i: Int # 将变量 i 声明为 Int 类型
i: Int = 1
j = 1 # 类型说明可以省略
</code></pre>
<p>您还可以指定普通表达式的类型。</p>
<pre><code class="language-python">i = 1: Int
f([1, &quot;a&quot;]: [Int or Str])
</code></pre>
<p>对于简单的变量赋值，大多数类型说明可以省略。
在定义子例程和类型时，类型规范更有用。</p>
<pre><code class="language-python"># 参数的类型规范
f x, y: Array Int = ...
T X, Y: Array Int = ...
</code></pre>
<p>请注意，在上述情况下，<code>x, y</code> 都是 <code>Array Int</code>。</p>
<pre><code class="language-python"># 大写变量的值必须是常量表达式
f X: Int = X
</code></pre>
<p>或者，如果你不需要关于类型参数的完整信息，你可以用 <code>_</code> 省略它</p>
<pre><code class="language-python">g v: [T; _] = ...
</code></pre>
<p>但是请注意，类型规范中的 <code>_</code> 意味着 <code>Object</code>。</p>
<pre><code class="language-python">f x: _, y: Int = x + y # 类型错误：Object 和 Int 之间没有实现 +
</code></pre>
<h2 id="子类型规范"><a class="header" href="#子类型规范">子类型规范</a></h2>
<p>除了 <code>:</code>(类型声明运算符)，Erg 还允许您使用 <code>&lt;:</code>(部分类型声明运算符)来指定类型之间的关系。
<code>&lt;:</code> 的左边只能指定一个类。 使用 <code>Subtypeof</code> 或类似的运算符来比较结构类型。</p>
<p>这也经常在定义子例程或类型时使用，而不是简单地指定变量。</p>
<pre><code class="language-python"># 参数的子类型规范
f X &lt;: T = ...

# 所需属性的子类型规范(.Iterator 属性必须是 Iterator 类型的子类型)
Iterable T = Trait {
    .Iterator = {Iterator} # {Iterator} == {I: Type | I &lt;: Iterator}
    .iter = Self.() -&gt; Self.Iterator T
    ...
}
</code></pre>
<p>也可以在定义类时使用子类型规范来静态检查该类是否是指定类型的子类型。</p>
<pre><code class="language-python"># C 类是 Show 的子类型
C = Class Object, Impl := Show
C.show self = ... # 显示所需的属性。
</code></pre>
<p>您也可以仅在特定情况下指定子类型</p>
<pre><code class="language-python">K T: Eq
K Int &lt;: Show and Eq
K T = Class Object
K(T).
    `==` self, other = ...
K(Int).
    show self = ...
</code></pre>
<p>实现结构类型时建议使用子类型规范。
这是因为，由于结构子类型的性质，拼写错误或类型规范错误在实现所需属性时不会导致错误</p>
<pre><code class="language-python">C = Class Object
C.shoe self = ... # Show 由于 Typo 没有实现(它被认为只是一种独特的方法)
</code></pre>
<h2 id="属性定义"><a class="header" href="#属性定义">属性定义</a></h2>
<p>只能在模块中为特征和类定义属性</p>
<pre><code class="language-python">C = Class()
C.pub_attr = &quot;this is public&quot;
C::private_attr = &quot;this is private&quot;

c = C.new()
assert c.pub_attr == &quot;this is public&quot;
</code></pre>
<p>定义批处理定义的语法称为批处理定义，其中在 <code>C.</code> 或 <code>C::</code> 之后添加换行符，并且定义在缩进下方组合在一起</p>
<pre><code class="language-python">C = Class()
C.pub1 = ...
C.pub2 = ...
C::priv1 = ...
C::priv2 = ...
# 相当于
C = Class()
C.
    pub1 = ...
    C. pub2 = ...
C::
    priv1 = ...
    priv2 = ...
</code></pre>
<h2 id="别名"><a class="header" href="#别名">别名</a></h2>
<p>类型可以有别名。 这允许缩短长类型，例如记录类型</p>
<pre><code class="language-python">Id = Int
Point3D = {x = Int; y = Int; z = Int}
IorS = Int or Str
Vector = Array Int
</code></pre>
<p>此外，当显示错误时，如果定义了复合类型(在上面的示例中，右侧类型不是第一个类型)，编译器将为它们使用别名。</p>
<p>但是，每个模块只允许一个相同类型的别名，多个别名将导致警告。
这意味着应将具有不同用途的类型定义为单独的类型。
目的还在于防止在已经具有别名的类型之上添加别名。</p>
<pre><code class="language-python">Id = Int
UserId = Int # 类型警告：重复别名：Id 和 UserId

Ids = Array Id
Ints = Array Int # 类型警告：重复别名：Isd 和 Ints

IorS = Int or Str
IorSorB = IorS or Bool
IorSorB_ = Int or Str or Bool # 类型警告：重复别名：IorSorB 和 IorSorB_

Point2D = {x = Int; y = Int}
Point3D = {.... Point2D; z = Int}
Point = {x = Int; y = Int; z = Int} # 类型警告：重复别名：Point3D 和 Point
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="特质"><a class="header" href="#特质">特质</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/03_trait.md&amp;commit_hash=14657486719a134f494e107774ac8f9d5a63f083"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/03_trait.md%26commit_hash%3D14657486719a134f494e107774ac8f9d5a63f083" alt="badge" /></a></p>
<p>Trait 是一种名义类型，它将类型属性要求添加到记录类型。
它类似于 Python 中的抽象基类 (ABC)，但区别在于能够执行代数运算。</p>
<pre><code class="language-python">Norm = Trait {.x = Int; .y = Int; .norm = Self.() -&gt; Int}
</code></pre>
<p>特质不区分属性和方法。</p>
<p>注意，trait 只能声明，不能实现(实现是通过一个叫做 patching 的特性来实现的，后面会讨论)。
可以通过指定部分类型来检查特征在类中的实现。</p>
<pre><code class="language-python">Point2D &lt;: Norm
Point2D = Class {.x = Int; .y = Int}
Point2D.norm self = self.x**2 + self.y**2
</code></pre>
<p>Error if the required attributes are not implemented.</p>
<pre><code class="language-python">Point2D &lt;: Norm # 类型错误：Point2D 不是 Norm 的子类型
Point2D = Class {.x = Int; .y = Int}
</code></pre>
<p>特征与结构类型一样，可以应用组合、替换和消除等操作(例如&quot;T 和 U&quot;)。 由此产生的特征称为即时特征。</p>
<pre><code class="language-python">T = Trait {.x = Int}
U = Trait {.y = Int}
V = Trait {.x = Int; y: Int}
assert Structural(T and U) == Structural V
assert Structural(V not U) == Structural T
W = Trait {.x = Ratio}
assert Structural(W) ! = Structural(T)
assert Structural(W) == Structural(T.replace {.x = Ratio})
</code></pre>
<p>Trait 也是一种类型，因此可以用于普通类型规范</p>
<pre><code class="language-python">points: [Norm; 2] = [Point2D::new(1, 2), Point2D::new(3, 4)]
assert points.iter().map(x -&gt; x.norm()).collect(Array) == [5, 25].
</code></pre>
<h2 id="特征包含"><a class="header" href="#特征包含">特征包含</a></h2>
<p>扩展运算符 <code>...</code> 允许您将包含某个特征的特征定义为超类型。 这称为特征的 <strong>subsumption</strong>。
在下面的示例中，<code>BinAddSub</code> 包含 <code>BinAdd</code> 和 <code>BinSub</code>。
这对应于类中的继承，但与继承不同的是，可以使用&quot;和&quot;组合多个基类型。 也允许被 <code>not</code> 部分排除的特征。</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}

Sub R = Trait {
    .SubO = Type
    . `_-_` = Self.(R) -&gt; Self.SubO
}

BinAddSub = Subsume Add(Self) and Sub(Self)
</code></pre>
<h2 id="结构特征"><a class="header" href="#结构特征">结构特征</a></h2>
<p>特征可以结构化</p>
<pre><code class="language-python">SAdd = Structural Trait {
    . `_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: SAdd| 不能省略
add|A &lt;: SAdd| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

assert add(C.new(1), C.new(2)) == C.new(3)
</code></pre>
<p>名义特征不能简单地通过实现请求方法来使用，而必须明确声明已实现。
在以下示例中，<code>add</code>不能与<code>C</code>类型的参数一起使用，因为没有明确的实现声明。 它必须是<code>C = Class {i = Int}, Impl := Add</code>。</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: 添加| 可以省略
add|A &lt;: Add| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

add C.new(1), C.new(2) # 类型错误：C 不是 Add 的子类
# 提示：继承或修补&quot;添加&quot;
</code></pre>
<p>不需要为此实现声明结构特征，但类型推断不起作用。 使用时需要指定类型。</p>
<h2 id="多态特征"><a class="header" href="#多态特征">多态特征</a></h2>
<p>特征可以带参数。 这与多态类型相同。</p>
<pre><code class="language-python">Mapper T: Type = Trait {
    .mapIter = {Iterator}
    .map = (self: Self, T -&gt; U) -&gt; Self.MapIter U
}

# ArrayIterator &lt;: Mapper
# ArrayIterator.MapIter == ArrayMapper
# [1, 2, 3].iter(): ArrayIterator Int
# [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;): ArrayMapper Str
assert [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;).collect(Array) == [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="override特征"><a class="header" href="#override特征">Override特征</a></h2>
<p>派生特征可以Override基本特征的类型定义。
在这种情况下，Override方法的类型必须是基方法类型的子类型。</p>
<pre><code class="language-python"># `Self.(R) -&gt; O` is a subtype of ``Self.(R) -&gt; O or Panic
Div R, O: Type = Trait {
    . `/` = Self.(R) -&gt; O or Panic
}
SafeDiv R, O = Subsume Div, {
    @Override
    . `/` = Self.(R) -&gt; O
}
</code></pre>
<h2 id="在-api-中实现和解决重复的特征"><a class="header" href="#在-api-中实现和解决重复的特征">在 API 中实现和解决重复的特征</a></h2>
<p><code>Add</code>、<code>Sub</code> 和 <code>Mul</code> 的实际定义如下所示。</p>
<pre><code class="language-python">Add R = Trait {
    .Output = Type
    . `_+_` = Self.(R) -&gt; .Output
}
Sub R = Trait {
    .Output = Type
    . `_-_` = Self.(R) -&gt; .Output
}
Mul R = Trait {
    .Output = Type
    . `*` = Self.(R) -&gt; .Output
}
</code></pre>
<p><code>.Output</code> 重复。 如果要同时实现这些多个特征，请指定以下内容</p>
<pre><code class="language-python">P = Class {.x = Int; .y = Int}
# P|Self &lt;: Add(P)|可简写为 P|&lt;: Add(P)|
P|Self &lt;: Add(P)|.
    Output = P
    `_+_` self, other = P.new {.x = self.x + other.x; .y = self.y + other.y}
P|Self &lt;: Mul(Int)|.
    Output = P
    `*` self, other = P.new {.x = self.x * other; .y = self.y * other}
</code></pre>
<p>以这种方式实现的重复 API 在使用时几乎总是类型推断，但也可以通过使用 <code>||</code> 显式指定类型来解决。</p>
<pre><code class="language-python">print! P.Output # 类型错误：不明确的类型
print! P|&lt;: Mul(Int)|.Output # &lt;class 'P'&gt;
</code></pre>
<h2 id="附录与-rust-特征的区别"><a class="header" href="#附录与-rust-特征的区别">附录：与 Rust 特征的区别</a></h2>
<p>Erg 的特征忠实于 [Schärli 等人] (https://www.ptidej.net/courses/ift6251/fall06/presentations/061122/061122.doc.pdf) 提出的特征。
为了允许代数运算，特征被设计为不能有方法实现目录，但可以在必要时进行修补。</p>
<p 对齐='中心'>
     <a href='./02_basic.md'>上一页</a> | <a href='./04_class.md'>下一步</a>
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class"><a class="header" href="#class">Class</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/04_class.md&amp;commit_hash=157f51ae0e8cf3ceb45632b537ebe3560a5500b7"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/04_class.md%26commit_hash%3D157f51ae0e8cf3ceb45632b537ebe3560a5500b7" alt="badge" /></a></p>
<p>Erg 中的类大致是一种可以创建自己的元素(实例)的类型。
这是一个简单类的示例。</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
# 如果 `.new` 没有定义，那么 Erg 将创建 `Person.new = Person::__new__`
Person.
    new name, age = Self::__new__ {.name = name; .age = age}

john = Person.new &quot;John Smith&quot;, 25
print! john # &lt;Person object&gt;
print! classof(john) # Person
</code></pre>
<p>赋予&quot;Class&quot;的类型(通常是记录类型)称为需求类型(在本例中为&quot;{.name = Str; .age = Nat}&quot;)。
可以使用 <code>&lt;Class name&gt;::__new__ {&lt;attribute name&gt; = &lt;value&gt;; 创建实例 ...}</code> 可以创建。
<code>{.name = &quot;约翰·史密斯&quot;; .age = 25}</code> 只是一条记录，但它通过传递 <code>Person.new</code> 转换为 <code>Person</code> 实例。
创建此类实例的子例程称为构造函数。
在上面的类中，<code>.new</code> 方法被定义为可以省略字段名等。</p>
<p>请注意，以下不带换行符的定义将导致语法错误。</p>
<pre><code class="language-python">Person.new name, age = ... # 语法错误：不能直接在对象上定义属性
</code></pre>
<blockquote>
<p><strong>Warning</strong>：这是最近添加的规范，后续文档中可能不会遵循。 如果你发现它，请报告它。</p>
</blockquote>
<h2 id="实例和类属性"><a class="header" href="#实例和类属性">实例和类属性</a></h2>
<p>在 Python 和其他语言中，实例属性通常在块侧定义如下，但请注意，这样的写法在 Erg 中具有不同的含义。</p>
<pre><code class="language-python"># Python
class Person:
    name: str
    age: int
</code></pre>
<pre><code class="language-python"># 在Erg中，这个符号意味着类属性的声明(不是实例属性)
Person = Class()
Person.
    name: Str
    age: Int
</code></pre>
<pre><code class="language-python"># 以上 Python 代码的 Erg 代码
Person = Class {
    .name = Str
    .age = Nat
}
</code></pre>
<p>元素属性(在记录中定义的属性)和类型属性(也称为实例/类属性，尤其是在类的情况下)是完全不同的东西。 类型属性是类型本身的属性。 当一个类型的元素本身没有所需的属性时，它指的是一个类型属性。 元素属性是元素直接拥有的唯一属性。
为什么要进行这种区分? 如果所有属性都是元素属性，那么在创建对象时复制和初始化所有属性将是低效的。
此外，以这种方式划分属性明确了诸如&quot;该属性是共享的&quot;和&quot;该属性是分开持有的&quot;之类的角色。</p>
<p>下面的例子说明了这一点。 <code>species</code> 属性对所有实例都是通用的，因此将其用作类属性更自然。 但是，属性 <code>name</code> 应该是实例属性，因为每个实例都应该单独拥有它。</p>
<pre><code class="language-python">Person = Class {name = Str}
Person::
    species = &quot;human&quot;
Person.
    describe() =
        log &quot;species: {species}&quot;
    greet self =
        log &quot;Hello, My name is {self::name}.&quot;

Person.describe() # 类型：Person
Person.greet() # 类型错误: 未绑定的方法 Person.greet 需要一个参数

john = Person.new {name = &quot;John&quot;}
john.describe() # 类型: human
john.greet() # 你好，我是约翰

alice = Person.new {name = &quot;Alice&quot;}
alice.describe() # 类型: human
alice.greet() # 你好，我是爱丽丝
</code></pre>
<p>顺便说一下，如果实例属性和类型属性具有相同的名称和相同的类型，则会发生编译错误。 这是为了避免混淆。</p>
<pre><code class="language-python">C = Class {.i = Int}
C.i = 1 # 属性错误：`.i` 已在实例字段中定义
</code></pre>
<h2 id="类class-类型type"><a class="header" href="#类class-类型type">类(Class), 类型(Type)</a></h2>
<p>请注意，<code>1</code> 的类和类型是不同的。
只有一个类 <code>Int</code> 是 <code>1</code> 的生成器。 可以通过<code>classof(obj)</code>或<code>obj.__class__</code>获取对象所属的类。
相比之下，<code>1</code>有无数种。 例如，<code>{1}, {0, 1}, 0..12, Nat, Int, Num</code>。
但是，可以将最小类型定义为单一类型，在本例中为&quot;{1}&quot;。 可以通过<code>Typeof(obj)</code>获取对象所属的类型。 这是一个编译时函数。
对象可以使用补丁方法以及类方法。
Erg 不允许您添加类方法，但您可以使用 <a href="type/./07_patch.html">patch</a> 来扩展类。</p>
<p>您还可以从现有类(<a href="type/../29_decorator.html#%E5%8F%AF%E7%BB%A7%E6%89%BF">Inheritable</a> 类)继承。
您可以使用 <code>Inherit</code> 创建一个继承类。 左侧的类型称为派生类，右侧的&quot;继承&quot;的参数类型称为基类(继承类)。</p>
<pre><code class="language-python">MyStr = Inherit Str
# other: 如果你设置 ``other: Str''，你可以使用 MyStr。
MyStr.
    `-` self, other: Str = self.replace other, &quot;&quot;

abc = MyStr.new(&quot;abc&quot;)
# 这里的比较是向上的
assert abc - &quot;b&quot; == &quot;ac&quot;
</code></pre>
<p>与 Python 不同，默认情况下，定义的 Erg 类是 <code>final</code>(不可继承的)。
要使类可继承，必须将 <code>Inheritable</code> 装饰器附加到该类。
Str` 是可继承的类之一。</p>
<pre><code class="language-python">MyStr = Inherit Str # OK
MyStr2 = Inherit MyStr # NG

@Inheritable
InheritableMyStr = Inherit Str
MyStr3 = Inherit InheritableMyStr # OK
</code></pre>
<p><code>Inherit Object</code> 和 <code>Class()</code> 在实践中几乎是等价的。 一般使用后者。</p>
<p>类具有与类型不同的等价检查机制。
类型基于其结构进行等效性测试。</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
Human = {.name = Str; .age = Nat}

assert Person == Human
</code></pre>
<p>class has no equivalence relation defined.</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
Human = Class {.name = Str; .age = Nat}

Person == Human # 类型错误：无法比较类
</code></pre>
<h2 id="与结构类型的区别"><a class="header" href="#与结构类型的区别">与结构类型的区别</a></h2>
<p>我们说过类是一种可以生成自己的元素的类型，但这并不是严格的描述。 事实上，一个记录类型+补丁可以做同样的事情。</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    new name, age = {.name; .age}

john = Person.new(&quot;John Smith&quot;, 25)
</code></pre>
<p>使用类有四个优点。
第一个是构造函数经过有效性检查，第二个是它的性能更高，第三个是您可以使用符号子类型(NST)，第四个是您可以继承和覆盖。</p>
<p>我们之前看到记录类型 + 补丁也可以定义一个构造函数(某种意义上)，但这当然不是一个合法的构造函数。 这当然不是一个合法的构造函数，因为它可以返回一个完全不相关的对象，即使它调用自己<code>.new</code>。 在类的情况下，<code>.new</code> 被静态检查以查看它是否生成满足要求的对象。</p>
<p>~</p>
<p>类的类型检查只是检查对象的<code>。 __class__</code> 对象的属性。 因此可以快速检查一个对象是否属于一个类型。</p>
<p>~</p>
<p>Erg 在课堂上启用 NST； NST 的优点包括健壮性。
在编写大型程序时，经常会出现对象的结构巧合匹配的情况。</p>
<pre><code class="language-python">Dog = {.name = Str; .age = Nat}
DogImpl = Patch Dog
DogImpl.
    bark = log &quot;Yelp!&quot;
...
Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    greet self = log &quot;Hello, my name is {self.name}.&quot;

john = {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # &quot;Yelp!&quot;
</code></pre>
<p><code>Dog</code> 和 <code>Person</code> 的结构完全一样，但让动物打招呼，让人类吠叫显然是无稽之谈。
前者是不可能的，所以让它不适用更安全。 在这种情况下，最好使用类。</p>
<pre><code class="language-python">Dog = Class {.name = Str; .age = Nat}
Dog.bark = log &quot;Yelp!&quot;
...
Person = Class {.name = Str; .age = Nat}
Person.greet self = log &quot;Hello, my name is {self.name}.&quot;

john = Person.new {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # 类型错误: `Person` 对象没有方法 `.bark`。
</code></pre>
<p>另一个特点是补丁添加的类型属性是虚拟的，实现类不作为实体保存。
也就是说，<code>T.x</code>、<code>T.bar</code> 是可以通过与 <code>{i = Int}</code> 兼容的类型访问(编译时绑定)的对象，并且未在 <code>{i = Int}</code> 或 <code> C</code>。
相反，类属性由类本身持有。 因此，它们不能被不处于继承关系的类访问，即使它们具有相同的结构。</p>
<pre><code class="language-python">C = Class {i = Int}
C.
    foo self = ...
print! dir(C) # [&quot;foo&quot;, ...].

T = Patch {i = Int}
T.
    x = 1
    bar self = ...
print! dir(T) # [&quot;bar&quot;, &quot;x&quot;, ...].
assert T.x == 1
assert {i = 1}.x == 1
print! T.bar # &lt;函数 bar&gt;
{i = Int}.bar # 类型错误：Record({i = Int}) 没有方法 `.bar`。
C.bar # 类型错误：C 没有方法 `.bar` 打印！
print! {i = 1}.bar # &lt;方法 bar&gt;
C.new({i = 1}).bar # &lt;方法 bar&gt;
</code></pre>
<h2 id="与数据类的区别"><a class="header" href="#与数据类的区别">与数据类的区别</a></h2>
<p>有两种类型的类：常规类，通过<code>Class</code>成为记录类，以及从记录类继承(<code>Inherit</code>)的数据类。
数据类继承了记录类的功能，具有分解赋值、默认实现的<code>==</code>和<code>hash</code>等特性。另一方面，数据类有自己的等价关系和格式展示。
另一方面，如果要定义自己的等价关系或格式显示，则应使用普通类。</p>
<pre><code class="language-python">C = Class {i = Int}
c = C.new {i = 1}
d = C.new {i = 2}
print! c # &lt;C object&gt;
c == d # 类型错误：`==` 没有为 `C` 实现

D = Inherit {i = Int}
e = D::{i = 1} # 与`e = D.new {i = 1}`相同
f = D::{i = 2}
print! e # D(i=1)
assert e ! = f
</code></pre>
<h2 id="枚举类"><a class="header" href="#枚举类">枚举类</a></h2>
<p>为了便于定义&quot;Or&quot;类型的类，提供了一个&quot;Enum&quot;。</p>
<pre><code class="language-python">X = Class()
Y = Class()
XorY = Enum X, Y
</code></pre>
<p>每种类型都可以通过<code>XorY.X</code>、<code>XorY.Y</code>来访问，构造函数可以通过<code>X.new |&gt; XorY.new</code>获得。</p>
<pre><code class="language-python">x1 = XorY.new X.new()
x2 = (X.new |&gt; XorY.new)()
x3 = (Y.new |&gt; XorY.new)()
assert x1 == x2
assert x1 != x3
</code></pre>
<h2 id="类关系"><a class="header" href="#类关系">类关系</a></h2>
<p>类是需求类型的子类型。 类中可以使用需求类型的方法(包括补丁方法)。</p>
<pre><code class="language-python">T = Trait {.foo = Foo}
C = Class(... , impl: T)
C.
    foo = foo
    bar x = ...
assert C &lt; T
assert C.foo == foo
assert not T &lt; C
assert T.foo == Foo
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="继承"><a class="header" href="#继承">继承</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/05_inheritance.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/05_inheritance.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>继承允许您定义一个新类，为现有类添加功能或专业化。
继承类似于包含在特征中。 继承的类成为原始类的子类型。</p>
<pre><code class="language-python">NewInt = Inherit Int
NewInt.
    plus1 self = self + 1

assert NewInt.new(1).plus1() == 2
assert NewInt.new(1) + NewInt.new(1) == 2
</code></pre>
<p>如果你希望新定义的类是可继承的，你必须给它一个 <code>Inheritable</code> 装饰器。</p>
<p>您可以指定一个可选参数 <code>additional</code> 以允许该类具有其他实例属性，但前提是该类是一个值类。 但是，如果类是值类，则不能添加实例属性。</p>
<pre><code class="language-python">@Inheritable
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}

john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

MailAddress = Inherit Str, additional: {owner = Str} # 类型错误：实例变量不能添加到值类中
</code></pre>
<p>Erg 的特殊设计不允许继承&quot;Never&quot;类型。 Erg 的特殊设计不允许继承 <code>Never</code> 类型，因为 <code>Never</code> 是一个永远无法实例化的独特类。</p>
<h2 id="枚举类的继承"><a class="header" href="#枚举类的继承">枚举类的继承</a></h2>
<p><a href="type/./13_algebraic.html">Or 类型</a> 也可以被继承。 在这种情况下，您可以通过指定可选参数 <code>Excluding</code> 来删除任何选项(可以使用 <code>or</code> 进行多项选择)。
不能添加其他选项。 添加选项的类不是原始类的子类型。</p>
<pre><code class="language-python">Number = Class Int or Float or Complex
Number.abs(self): Float =
    match self:
        i: Int -&gt; i.abs().into Float
        f: Float -&gt; f.abs()
        c: Complex -&gt; c.abs().into Float

# c: 复杂不能出现在匹配选项中
RealNumber = Inherit Number, Excluding: Complex
</code></pre>
<p>同样，也可以指定<a href="type/./12_refinement.html">细化类型</a>。</p>
<pre><code class="language-python">Months = Class 0..12
MonthsNot31Days = Inherit Months, Excluding: {1, 3, 5, 7, 8, 10, 12}

StrMoreThan3 = Class StrWithLen N | N &gt;= 3
StrMoreThan4 = Inherit StrMoreThan3, Excluding: StrWithLen N | N == 3
</code></pre>
<h2 id="覆盖"><a class="header" href="#覆盖">覆盖</a></h2>
<p>该类与补丁相同，可以将新方法添加到原始类型，但可以进一步&quot;覆盖&quot;该类。
这种覆盖称为覆盖。要覆盖，必须满足三个条件。
首先，覆盖必须有一个 <code>Override</code> 装饰器，因为默认情况下它会导致错误。
另外，覆盖不能改变方法的类型。它必须是原始类型的子类型。
如果你重写了一个被另一个方法引用的方法，你也必须重写所有被引用的方法。</p>
<p>为什么这个条件是必要的?这是因为重写不仅会改变一种方法的行为，而且可能会影响另一种方法的行为。</p>
<p>让我们从第一个条件开始。此条件是为了防止&quot;意外覆盖&quot;。
换句话说，必须使用 <code>Override</code> 装饰器来防止派生类中新定义的方法的名称与基类的名称冲突。</p>
<p>接下来，考虑第二个条件。这是为了类型一致性。由于派生类是基类的子类型，因此它的行为也必须与基类的行为兼容。</p>
<p>最后，考虑第三个条件。这种情况是 Erg 独有的，在其他面向对象语言中并不常见，同样是为了安全。让我们看看如果不是这种情况会出现什么问题。</p>
<pre><code class="language-python"># 反面示例
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    g! ref! self = self.f!() # 无限递归警告：此代码陷入无限循环 
    # 覆盖错误：方法 `.g` 被 `.f` 引用但未被覆盖
</code></pre>
<p>在继承类 <code>Inherited!</code> 中，<code>.g!</code> 方法被重写以将处理转移到 <code>.f!</code>。 但是，基类中的 <code>.f!</code> 方法会将其处理转移到 <code>.g!</code>，从而导致无限循环。 <code>.f</code> 是 <code>Base!</code> 类中的一个没有问题的方法，但它被覆盖以一种意想不到的方式使用，并且被破坏了。</p>
<p>Erg 已将此规则构建到规范中。</p>
<pre><code class="language-python"># OK.
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    f! ref! self =
        print! self::x
        self::x.update! x -&gt; x + 1
    @Override
    g! ref! self = self.f!()
</code></pre>
<p>然而，这个规范并没有完全解决覆盖问题。 然而，这个规范并没有完全解决覆盖问题，因为编译器无法检测覆盖是否解决了问题。
创建派生类的程序员有责任纠正覆盖的影响。 只要有可能，尝试定义一个别名方法。</p>
<h3 id="替换特征或看起来像什么"><a class="header" href="#替换特征或看起来像什么">替换特征(或看起来像什么)</a></h3>
<p>尽管无法在继承时替换特征，但有一些示例似乎可以这样做。</p>
<p>例如，<code>Int</code>，<code>Real</code> 的子类型(实现了 <code>Add()</code>)，似乎重新实现了 <code>Add()</code>。</p>
<pre><code class="language-python">Int = Class ... , Impl := Add() and ...
</code></pre>
<p>但实际上 <code>Real</code> 中的 <code>Add()</code> 代表 <code>Add(Real, Real)</code>，而在 <code>Int</code> 中它只是被 <code>Add(Int, Int)</code> 覆盖。
它们是两个不同的特征(<code>Add</code> 是一个 <a href="type/./advanced/variance.html">covariate</a>，所以<code>Add(Real, Real) :&gt; Add(Int, Int)</code>)。</p>
<h2 id="多重继承"><a class="header" href="#多重继承">多重继承</a></h2>
<p>Erg 不允许普通类之间的交集、差异和互补。</p>
<pre><code class="language-python">Int and Str # 类型错误：无法合并类
</code></pre>
<p>该规则防止从多个类继承，即多重继承。</p>
<pre><code class="language-python">IntAndStr = Inherit Int and Str # 语法错误：不允许类的多重继承
</code></pre>
<p>但是，可以使用多个继承的 Python 类。</p>
<h2 id="多层多级继承"><a class="header" href="#多层多级继承">多层(多级)继承</a></h2>
<p>Erg 继承也禁止多层继承。 也就是说，您不能定义从另一个类继承的类。
从&quot;Object&quot;继承的可继承类可能会异常继承。</p>
<p>同样在这种情况下，可以使用 Python 的多层继承类。</p>
<h2 id="重写继承的属性"><a class="header" href="#重写继承的属性">重写继承的属性</a></h2>
<p>Erg 不允许重写从基类继承的属性。 这有两个含义。</p>
<p>第一个是对继承的源类属性的更新操作。 例如，它不能重新分配，也不能通过 <code>.update!</code> 方法更新。</p>
<p>覆盖与重写不同，因为它是一种用更专业的方法覆盖的操作。 覆盖也必须替换为兼容的类型。</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    var = !1
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1

Inherited! = Inherit Base!
Inherited!
    var.update! v -&gt; v + 1
    # 类型错误：不能更新基类变量
    @Override
    inc_pub! ref! self = self.pub + 1
    # 覆盖错误：`.inc_pub!` 必须是 `Self! 的子类型！ () =&gt; ()`
</code></pre>
<p>第二个是对继承源的(变量)实例属性的更新操作。 这也是被禁止的。 基类的实例属性只能从基类提供的方法中更新。
无论属性的可见性如何，都无法直接更新。 但是，它们可以被读取。</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1
    inc_pri! ref! self = self::pri.update! p -&gt; p + 1

self = self.pub.update!
Inherited!
    # OK
    add2_pub! ref! self =
        self.inc_pub!()
        self.inc_pub!()
    # NG, `Child` 不能触摸 `self.pub` 和 `self::pri`。
    add2_pub! ref! self =
        self.pub.update! p -&gt; p + 2
</code></pre>
<p>毕竟 Erg 继承只能添加新的属性和覆盖基类的方法。</p>
<h2 id="使用继承"><a class="header" href="#使用继承">使用继承</a></h2>
<p>虽然继承在正确使用时是一项强大的功能，但它也有一个缺点，即它往往会使类依赖关系复杂化，尤其是在使用多层或多层继承时。复杂的依赖关系会降低代码的可维护性。
Erg 禁止多重和多层继承的原因是为了降低这种风险，并且引入了类补丁功能以降低依赖关系的复杂性，同时保留继承的&quot;添加功能&quot;方面。</p>
<p>那么，反过来说，应该在哪里使用继承呢?一个指标是何时需要&quot;基类的语义子类型&quot;。
Erg 允许类型系统自动进行部分子类型确定(例如，Nat，其中 Int 大于或等于 0)。
但是，例如，仅依靠 Erg 的类型系统很难创建&quot;表示有效电子邮件地址的字符串类型&quot;。您可能应该对普通字符串执行验证。然后，我们想为已通过验证的字符串对象添加某种&quot;保证&quot;。这相当于向下转换为继承的类。将 <code>Str object</code> 向下转换为 <code>ValidMailAddressStr</code> 与验证字符串是否采用正确的电子邮件地址格式是一一对应的。</p>
<pre><code class="language-python">ValidMailAddressStr = Inherit Str
ValidMailAddressStr.
    init s: Str =
        validate s # 邮件地址验证
        Self.new s

s1 = &quot;invalid mail address&quot;
s2 = &quot;foo@gmail.com&quot;
_ = ValidMailAddressStr.init s1 # 恐慌：无效的邮件地址
valid = ValidMailAddressStr.init s2
valid: ValidMailAddressStr # 确保电子邮件地址格式正确
</code></pre>
<p>另一个指标是您何时想要实现名义多态性。
例如，下面定义的 <code>greet!</code> 过程将接受任何类型为 <code>Named</code> 的对象。
但显然应用 <code>Dog</code> 类型的对象是错误的。 所以我们将使用 <code>Person</code> 类作为参数类型。
这样，只有 <code>Person</code> 对象、从它们继承的类和 <code>Student</code> 对象将被接受为参数。
这是比较保守的，避免不必要地承担过多的责任。</p>
<pre><code class="language-python">Named = {name = Str; ...}
Dog = Class {name = Str; breed = Str}
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}
structural_greet! person: Named =
    print! &quot;Hello, my name is {person::name}.&quot;
greet! person: Person =
    print! &quot;Hello, my name is {person::name}.&quot;

max = Dog.new {name = &quot;Max&quot;, breed = &quot;Labrador&quot;}
john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

structural_greet! max # 你好，我是马克斯
structural_greet! john # 你好，我是约翰
greet! alice # 你好，我是爱丽丝
greet! max # 类型错误：
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="名义子类型与结构子类型"><a class="header" href="#名义子类型与结构子类型">名义子类型与结构子类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/06_nst_vs_sst.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/06_nst_vs_sst.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<pre><code class="language-python">Months = 0..12

# NST
MonthsClass = Class Months
MonthsClass.
    name self =
        match self:
            1 -&gt; &quot;january&quot;
            2 -&gt; &quot;february&quot;
            3 -&gt; &quot;march&quot;
            ...

# SST
MonthsImpl = Patch Months
MonthsImpl.
    name self =
        match self:
            1 -&gt; &quot;January&quot;
            2 -&gt; &quot;February&quot;
            3 -&gt; &quot;March&quot;
            ...

assert 12 in Months
assert 2.name() == &quot;February&quot;
assert not 12 in MonthsClass
assert MonthsClass.new(12) in MonthsClass
# 它可以使用结构类型，即使包装在一个类中。
assert MonthsClass.new(12) in Months
# 如果两者都存在，则类方法优先
assert MonthsClass.new(2).name() == &quot;february&quot;
</code></pre>
<h2 id="最后我应该使用哪个nst-还是-sst"><a class="header" href="#最后我应该使用哪个nst-还是-sst">最后，我应该使用哪个，NST 还是 SST?</a></h2>
<p>如果您无法决定使用哪一个，我们的建议是 NST。
SST 需要抽象技能来编写在任何用例中都不会崩溃的代码。 好的抽象可以带来高生产力，但错误的抽象(外观上的共性)会导致适得其反的结果。(NST 可以通过故意将抽象保持在最低限度来降低这种风险。如果您不是库实现者，那么仅使用 NST 进行编码并不是一个坏主意。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="修补"><a class="header" href="#修补">修补</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/07_patch.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/07_patch.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg 不允许修改现有类型和类。
这意味着，不可能在类中定义额外的方法，也不能执行特化(一种语言特性，单态化多态声明的类型并定义专用方法，如在 C++ 中)。
但是，在许多情况下，您可能希望向现有类型或类添加功能，并且有一个称为&quot;修补&quot;的功能允许您执行此操作。</p>
<pre><code class="language-python">StrReverse = Patch Str
StrReverse.
    reverse self = self.iter().rev().collect(Str)

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
</code></pre>
<p>补丁的名称应该是要添加的主要功能的简单描述。
这样，被修补类型的对象(<code>Str</code>)可以使用修补程序的方法(<code>StrReverse</code>)。
实际上，内置方法<code>.reverse</code>并不是<code>Str</code>的方法，而是<code>StrRReverse</code>中添加的方法。</p>
<p>但是，补丁方法的优先级低于名义类型(类/特质)的方法，并且不能覆盖现有类型。</p>
<pre><code class="language-python">StrangeInt = Patch Int
StrangeInt.
    `_+_` = Int.`_-_` # 赋值错误：. `_+_` 已在 Int 中定义
</code></pre>
<p>如果要覆盖，则必须从类继承。
但是，基本上建议不要覆盖并定义具有不同名称的方法。
由于一些安全限制，覆盖不是很容易做到。</p>
<pre><code class="language-python">StrangeInt = Inherit Int
StrangeInt.
# 覆盖方法必须被赋予覆盖装饰器。
    # 另外，你需要覆盖所有依赖于 Int.`_+_` 的 Int 方法。
    @Override
    `_+_` = Super.`_-_` # OverrideError: Int.`_+_` 被 ... ````` 引用，所以这些方法也必须被覆盖
</code></pre>
<h2 id="选择修补程序"><a class="header" href="#选择修补程序">选择修补程序</a></h2>
<p>可以为单一类型定义修复程序，并且可以组合在一起。</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
StrMultiReplace = Patch(Str)
StrMultiReverse.
    multi_replace self, pattern_and_targets: [(Pattern, Str)] = ...
StrToCamelCase = Patch(Str)
StrToCamelCase.
    to_camel_case self = ...
StrToKebabCase = Patch(Str)
StrToKebabCase.
    to_kebab_case self = ...

StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
</code></pre>
<pre><code class="language-python">{StrBoosterPack; ...} = import &quot;foo&quot;

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
assert &quot;abc&quot;.multi_replace([(&quot;a&quot;, &quot;A&quot;), (&quot;b&quot;, &quot;B&quot;)]) == &quot;ABc&quot;
assert &quot;to camel case&quot;.to_camel_case() == &quot;toCamelCase&quot;
assert &quot;to kebab case&quot;.to_kebab_case() == &quot;to-kebab-case&quot;
</code></pre>
<p>如果定义了多个修复程序，其中一些可能会导致重复实施</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
# 更高效的实现
StrReverseMk2 = Patch(Str)
StrReverseMk2.
    reverse self = ...

&quot;hello&quot;.reverse() # 补丁选择错误: `.reverse` 的多个选择: StrReverse, StrReverseMk2
</code></pre>
<p>在这种情况下，您可以使用 <strong>related function</strong> 形式而不是方法形式使其唯一</p>
<pre><code class="language-python">assert StrReverseMk2.reverse(&quot;hello&quot;) == &quot;olleh&quot;
</code></pre>
<p>You can also make it unique by selectively importing.</p>
<pre><code class="language-python">{StrReverseMk2; ...} = import &quot;foo&quot;

assert &quot;hello&quot;.reverse() == &quot;olleh&quot;
</code></pre>
<h2 id="胶水补丁"><a class="header" href="#胶水补丁">胶水补丁</a></h2>
<p>维修程序也可以将类型相互关联。 <code>StrReverse</code> 补丁涉及 <code>Str</code> 和 <code>Reverse</code>。
这样的补丁称为 <strong>glue patch</strong>。
因为 <code>Str</code> 是内置类型，所以用户需要使用胶水补丁来改造特征。</p>
<pre><code class="language-python">Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch Str, Impl := Reverse
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>每个类型/特征对只能定义一个胶水补丁。
这是因为如果多个胶水修复程序同时&quot;可见&quot;，就不可能唯一确定选择哪个实现。
但是，当移动到另一个范围(模块)时，您可以交换维修程序。</p>
<pre><code class="language-python">NumericStr = Inherit Str
NumericStr.
    ...

NumStrRev = Patch NumericStr, Impl := Reverse
NumStrRev.
    ...
# 重复修补程序错误：数值Str已与&quot;反向&quot;关联`
# 提示：'Str'(NumericStr'的超类)通过'StrReverse'与'Reverse'关联
</code></pre>
<h2 id="附录与-rust-特征的关系"><a class="header" href="#附录与-rust-特征的关系">附录：与 Rust 特征的关系</a></h2>
<p>Erg 修复程序相当于 Rust 的(改造的)<code>impl</code> 块。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
trait Reverse {
    fn reverse(self) -&gt; Self;
}

impl Reverse for String {
    fn reverse(self) -&gt; Self {
        self.chars().rev().collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以说，Rust 的特征是 Erg 的特征和修复程序的特征。 这使得 Rust 的特征听起来更方便，但事实并非如此。</p>
<pre><code class="language-python"># Erg
Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch(Str, Impl := Reverse)
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>因为 impl 块在 Erg 中被对象化为补丁，所以在从其他模块导入时可以选择性地包含。 作为副作用，它还允许将外部特征实现到外部结构。
此外，结构类型不再需要诸如 <code>dyn trait</code> 和 <code>impl trait</code> 之类的语法。</p>
<pre><code class="language-python"># Erg
reversible: [Reverse; 2] = [[1, 2, 3], &quot;hello&quot;]

iter|T|(i: Iterable T): Iterator T = i.iter()
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
let reversible: [Box&lt;dyn Reverse&gt;; 2] = [Box::new([1, 2, 3]), Box::new(&quot;hello&quot;)];

fn iter&lt;I&gt;(i: I) -&gt; impl Iterator&lt;Item = I::Item&gt; where I: IntoIterator {
    i.into_iter()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="通用补丁"><a class="header" href="#通用补丁">通用补丁</a></h2>
<p>补丁不仅可以为一种特定类型定义，还可以为&quot;一般功能类型&quot;等定义。
在这种情况下，要给出自由度的项作为参数给出(在下面的情况下，<code>T：Type</code>)。 以这种方式定义的补丁称为全对称补丁。
如您所见，全对称补丁正是一个返回补丁的函数，但它本身也可以被视为补丁。</p>
<pre><code class="language-python">FnType T: Type = Patch(T -&gt; T)
FnType(T).
    type = T

assert (Int -&gt; Int).type == Int
</code></pre>
<h2 id="结构补丁"><a class="header" href="#结构补丁">结构补丁</a></h2>
<p>此外，可以为满足特定结构的任何类型定义修复程序。
但是，这比名义上的维修程序和类方法具有较低的优先级。</p>
<p>在定义结构修复程序时应使用仔细的设计，因为某些属性会因扩展而丢失，例如以下内容。</p>
<pre><code class="language-python"># 这不应该是 `Structural`
Norm = Structural Patch {x = Int; y = Int}
Norm.
    norm self = self::x**2 + self::y**2

Point2D = Class {x = Int; y = Int}
assert Point2D.new({x = 1; y = 2}).norm() == 5

Point3D = Class {x = Int; y = Int; z = Int}
assert Point3D.new({x = 1; y = 2; z = 3}).norm() == 14 # AssertionError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="值类型"><a class="header" href="#值类型">值类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/08_value.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/08_value.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>值类型是可以在编译时评估的 Erg 内置类型，具体来说：</p>
<pre><code class="language-python">Value = (
    Int
    or Nat
    or Ratio
    or Float
    or Complex
    or Bool
    or Str
    or NoneType
    or Array Const
    or Tuple Const
    or Set Const
    or ConstFunc(Const, _)
    or ConstProc(Const, _)
    or ConstMethod(Const, _)
)
</code></pre>
<p>应用于它们的值类型对象、常量和编译时子例程称为 <strong>constant 表达式</strong>。</p>
<pre><code class="language-python">1, 1.0, 1+2im, True, None, &quot;aaa&quot;, [1, 2, 3], Fib(12)
</code></pre>
<p>小心子程序。子例程可能是也可能不是值类型。
由于子程序的实质只是一个指针，因此可以将其视为一个值<a href="type/08_value.html#1"><sup id="f1">1</sup></a>，但是在编译不是子程序的东西时不能使用 在恒定的上下文中。 不是值类型，因为它没有多大意义。</p>
<p>将来可能会添加归类为值类型的类型。</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> Erg 中的术语&quot;值类型&quot;与其他语言中的定义不同。 纯 Erg 语义中没有内存的概念，并且因为它被放置在堆栈上而说它是值类型，或者因为它实际上是一个指针而说它不是值类型是不正确的。 值类型仅表示它是&quot;值&quot;类型或其子类型。 <a href="type/08_value.html#f1">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="属性类型"><a class="header" href="#属性类型">属性类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/09_attributive.md&amp;commit_hash=eccd113c1512076c367fb87ea73406f91ff83ba7"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/09_attributive.md%26commit_hash%3Deccd113c1512076c367fb87ea73406f91ff83ba7" alt="badge" /></a></p>
<p>属性类型是包含 Record 和 Dataclass、Patch、Module 等的类型。
属于属性类型的类型不是值类型。</p>
<h2 id="记录类型复合"><a class="header" href="#记录类型复合">记录类型复合</a></h2>
<p>可以展平复合的记录类型。
例如，<code>{... {.name = Str; .age = Nat}; ... {.name = Str; .id = Nat}}</code> 变成 <code>{.name = Str; .age = 自然； .id = Nat}</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="间隔类型"><a class="header" href="#间隔类型">间隔类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/10_interval.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/10_interval.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p><code>Range</code> 对象最基本的用途是作为迭代器。</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>请注意，与 Python 不同，它包含一个结束编号。</p>
<p>然而，这不仅仅用于 <code>Range</code> 对象。 也可以使用类型。 这种类型称为Interval类型。</p>
<pre><code class="language-python">i: 0..10 = 2
</code></pre>
<p><code>Nat</code> 类型等价于 <code>0..&lt;Inf</code> 并且，<code>Int</code> 和 <code>Ratio</code> 等价于 <code>-Inf&lt;..&lt;Inf</code>，
<code>0..&lt;Inf</code> 也可以写成 <code>0.._</code>。 <code>_</code> 表示任何 <code>Int</code> 类型的实例。</p>
<p>由于它也可以用作迭代器，所以可以倒序指定，例如<code>10..0</code>，但是<code>&lt;..</code>、<code>..&lt;</code>和<code>&lt;..&lt;</code>不能倒序</p>
<pre><code class="language-python">a = 0..10 # OK
b = 0..&lt;10 # OK
c = 10..0 # OK
d = 10&lt;..0 # 语法错误
e = 10..&lt;0 # 语法错误
f = 10&lt;..&lt;0 # 语法错误
</code></pre>
<p>Range 运算符可用于非数字类型，只要它们是&quot;Ord&quot;不可变类型</p>
<pre><code class="language-python">Alphabet = &quot;A&quot;..&quot;z&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举类型"><a class="header" href="#枚举类型">枚举类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/11_enum.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/11_enum.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Set 生成的枚举类型。
枚举类型可以与类型规范一起使用，但可以通过将它们分类为类或定义修复程序来定义进一步的方法。</p>
<p>具有枚举类型的部分类型系统称为枚举部分类型。</p>
<pre><code class="language-python">Bool = {True, False}
Status = {&quot;ok&quot;, &quot;error&quot;}
</code></pre>
<p>由于 <code>1..7</code> 可以重写为 <code>{1, 2, 3, 4, 5, 6, 7}</code>，所以当元素是有限的时，Enum 类型本质上等同于 Range 类型。</p>
<pre><code class="language-python">Binary! = Class {0, 1}!.
    invert! ref! self =
        if! self == 0:
            do!
                self.set! 1
            do!
                self.set! 0

b = Binary!.new !0
b.invert!()
</code></pre>
<p>顺便说一下，Erg 的 Enum 类型是一个包含其他语言中常见的枚举类型的概念。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
enum Status { Ok, Error }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Erg
Status = {&quot;Ok&quot;, &quot;Error&quot;}
</code></pre>
<p>Rust 的不同之处在于它使用了结构子类型(SST)。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Status 和 ExtraStatus 之间没有关系。
enum Status { Ok, Error }
enum ExtraStatus { Ok, Error, Unknown }

// 可实施的方法
impl Status {
    // ...
}
impl ExtraStatus {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Status &gt; ExtraStatus，Status的元素可以使用ExtraStatus的方法
Status = Trait {&quot;Ok&quot;, &quot;Error&quot;}
    # ...
ExtraStatus = Trait {&quot;Ok&quot;, &quot;Error&quot;, &quot;Unknown&quot;}
    # ...
</code></pre>
<p>方法也可以通过补丁添加。</p>
<p>使用&quot;或&quot;运算符明确指示包含或向现有 Enum 类型添加选项。</p>
<pre><code class="language-python">ExtraStatus = Status or {&quot;Unknown&quot;}
</code></pre>
<p>一个元素所属的所有类都相同的枚举类型称为同质枚举类型。</p>
<p>默认情况下，可以将需求类型为同类枚举类型的类视为元素所属类的子类。</p>
<p>如果您不想这样做，可以将其设为包装类</p>
<pre><code class="language-python">Abc = Class {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}
Abc.new(&quot;A&quot;).is_uppercase()

OpaqueAbc = Class {inner = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}}.
    new inner: {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} = Self.new {inner;}
OpaqueAbc.new(&quot;A&quot;).is_uppercase() # 类型错误
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="细化类型"><a class="header" href="#细化类型">细化类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/12_refinement.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/12_refinement.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>细化类型是受谓词表达式约束的类型。 枚举类型和区间类型是细化类型的语法糖。</p>
<p>细化类型的标准形式是<code>{Elem: Type | (预)*}</code>。 这意味着该类型是其元素为满足 <code>Pred</code> 的 <code>Elem</code> 的类型。
可用于筛选类型的类型仅为 [Const type]。</p>
<pre><code class="language-python">Nat = 0.. _
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N &gt;= 3}
</code></pre>
<p>当有多个 pred 时，可以用 <code>;</code> 或 <code>and</code> 或 <code>or</code> 分隔。 <code>;</code> 和 <code>and</code> 的意思是一样的。</p>
<p><code>Odd</code> 的元素是 <code>1, 3, 5, 7, 9, ...</code>。
它被称为细化类型，因为它的元素是现有类型的一部分，就好像它是细化一样。</p>
<p><code>Pred</code> 被称为(左侧)谓词表达式。 和赋值表达式一样，它不返回有意义的值，左侧只能放置一个模式。
也就是说，诸如<code>X**2 - 5X + 6 == 0</code>之类的表达式不能用作细化类型的谓词表达式。 在这方面，它不同于右侧的谓词表达式。</p>
<pre><code class="language-python">{X: Int | X**2 - 5X + 6 == 0} # 语法错误：谓词形式无效。 只有名字可以在左边
</code></pre>
<p>如果你知道如何解二次方程，你会期望上面的细化形式等价于<code>{2, 3}</code>。
但是，Erg 编译器对代数的了解很少，因此无法解决右边的谓词。</p>
<h2 id="智能投射"><a class="header" href="#智能投射">智能投射</a></h2>
<p>很高兴您定义了 <code>Odd</code>，但事实上，它看起来不能在文字之外使用太多。 要将普通 <code>Int</code> 对象中的奇数提升为 <code>Odd</code>，即将 <code>Int</code> 向下转换为 <code>Odd</code>，您需要传递 <code>Odd</code> 的构造函数。
对于细化类型，普通构造函数 <code>.new</code> 可能会出现恐慌，并且有一个名为 <code>.try_new</code> 的辅助构造函数返回一个 <code>Result</code> 类型。</p>
<pre><code class="language-python">i = Odd.new (0..10).sample!()
i: Odd # or Panic
</code></pre>
<p>它也可以用作 <code>match</code> 中的类型说明。</p>
<pre><code class="language-python"># i: 0..10
i = (0..10).sample!
match i:
    o: Odd -&gt;
        log &quot;i: Odd&quot;
    n: Nat -&gt; # 0..10 &lt; Nat
        log &quot;i: Nat&quot;
</code></pre>
<p>但是，Erg 目前无法做出诸如&quot;偶数&quot;之类的子决策，因为它不是&quot;奇数&quot;等。</p>
<h2 id="枚举区间和筛选类型"><a class="header" href="#枚举区间和筛选类型">枚举、区间和筛选类型</a></h2>
<p>前面介绍的枚举/区间类型是细化类型的语法糖。
<code>{a, b, ...}</code> 是 <code>{I: Typeof(a) | I == a 或 I == b 或 ... }</code>，并且 <code>a..b</code> 被去糖化为 <code>{I: Typeof(a) | 我 &gt;= a 和我 &lt;= b}</code>。</p>
<pre><code class="language-python">{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I &gt;= 1 and I &lt;= 10}
1... &lt;10 == {I: Int | I &gt;= 1 and I &lt; 10}
</code></pre>
<h2 id="细化模式"><a class="header" href="#细化模式">细化模式</a></h2>
<p>正如 <code>_: {X}</code> 可以重写为 <code>X</code>(常量模式)，<code>_: {X: T | Pred}</code> 可以重写为<code>X: T | Pred</code></p>
<pre><code class="language-python"># 方法 `.m` 是为长度为 3 或更大的数组定义的
Array(T, N | N &gt;= 3)
    .m(&amp;self) = ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代数类型"><a class="header" href="#代数类型">代数类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/13_algebraic.md&amp;commit_hash=c120700585fdb1d655255c8e2817bb13cc8d369e"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/13_algebraic.md%26commit_hash%3Dc120700585fdb1d655255c8e2817bb13cc8d369e" alt="badge" /></a></p>
<p>代数类型是通过将类型视为代数来操作类型而生成的类型。
它们处理的操作包括Union、Intersection、Diff、Complement等。
普通类只能进行Union，其他操作会导致类型错误。</p>
<h2 id="联合union"><a class="header" href="#联合union">联合(Union)</a></h2>
<p>联合类型可以为类型提供多种可能性。 顾名思义，它们是由&quot;或&quot;运算符生成的。
一个典型的 Union 是 <code>Option</code> 类型。 <code>Option</code> 类型是 <code>T 或 NoneType</code> 补丁类型，主要表示可能失败的值。</p>
<pre><code class="language-python">IntOrStr = Int or Str
assert dict.get(&quot;some key&quot;) in (Int or NoneType)

# 隐式变为 `T != NoneType`
Option T = T or NoneType
</code></pre>
<h2 id="路口"><a class="header" href="#路口">路口</a></h2>
<p>交集类型是通过将类型与 <code>and</code> 操作组合得到的。</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
</code></pre>
<p>如上所述，普通类不能与&quot;and&quot;操作结合使用。 这是因为实例只属于一个类。</p>
<h2 id="差异"><a class="header" href="#差异">差异</a></h2>
<p>Diff 类型是通过 <code>not</code> 操作获得的。
最好使用 <code>and not</code> 作为更接近英文文本的符号，但建议只使用 <code>not</code>，因为它更适合与 <code>and</code> 和 <code>or</code> 一起使用。</p>
<pre><code class="language-python">CompleteNum = Add and Sub and Mul and Div and Eq and Ord
Num = CompleteNum not Div not Ord

True = Bool not {False}
OneTwoThree = {1, 2, 3, 4, 5, 6} - {4, 5, 6, 7, 8, 9, 10}
</code></pre>
<h2 id="补充"><a class="header" href="#补充">补充</a></h2>
<p>补码类型是通过 <code>not</code> 操作得到的，这是一个一元操作。 <code>not T</code> 类型是 <code>{=} not T</code> 的简写。
类型为&quot;非 T&quot;的交集等价于 Diff，类型为&quot;非 T&quot;的 Diff 等价于交集。
但是，不推荐这种写法。</p>
<pre><code class="language-python"># 非零数类型的最简单定义
NonZero = Not {0}
# 不推荐使用的样式
{True} == Bool and not {False} # 1 == 2 + - 1
Bool == {True} not not {False} # 2 == 1 - -1
</code></pre>
<h2 id="真代数类型"><a class="header" href="#真代数类型">真代数类型</a></h2>
<p>有两种代数类型：可以简化的表观代数类型和不能进一步简化的真实代数类型。
&quot;表观代数类型&quot;包括 Enum、Interval 和 Record 类型的 <code>or</code> 和 <code>and</code>。
这些不是真正的代数类型，因为它们被简化了，并且将它们用作类型说明符将导致警告； 要消除警告，您必须简化它们或定义它们的类型。</p>
<pre><code class="language-python">assert {1, 2, 3} or {2, 3} == {1, 2, 3}
assert {1, 2, 3} and {2, 3} == {2, 3}
assert -2..-1 or 1..2 == {-2, -1, 1, 2}

i: {1, 2} or {3, 4} = 1 # 类型警告：{1, 2} 或 {3, 4} 可以简化为 {1, 2, 3, 4}
p: {x = Int, ...} and {y = Int; ...} = {x = 1; y = 2; z = 3}
# 类型警告：{x = Int, ...} 和 {y = Int; ...} 可以简化为 {x = Int; y = 整数； ...}

Point1D = {x = Int; ...}
Point2D = Point1D and {y = Int; ...} # == {x = Int; y = Int; ...}
q: Point2D = {x = 1; y = 2; z = 3}
</code></pre>
<p>真正的代数类型包括类型&quot;或&quot;和&quot;与&quot;。 类之间的&quot;或&quot;等类属于&quot;或&quot;类型。</p>
<pre><code class="language-python">assert Int or Str == Or(Int, Str)
assert Int and Marker == And(Int, Marker)
</code></pre>
<p>Diff, Complement 类型不是真正的代数类型，因为它们总是可以被简化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依赖类型"><a class="header" href="#依赖类型">依赖类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/14_dependent.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/14_dependent.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>依赖类型是一个特性，可以说是 Erg 的最大特性。
依赖类型是将值作为参数的类型。 普通的多态类型只能将类型作为参数，但依赖类型放宽了这个限制。</p>
<p>依赖类型等价于<code>[T; N]</code>(<code>数组(T，N)</code>)。
这种类型不仅取决于内容类型&quot;T&quot;，还取决于内容数量&quot;N&quot;。 <code>N</code> 包含一个<code>Nat</code> 类型的对象。</p>
<pre><code class="language-python">a1 = [1, 2, 3]
assert a1 in [Nat; 3]
a2 = [4, 5, 6, 7]
assert a1 in [Nat; 4]
assert a1 + a2 in [Nat; 7]
</code></pre>
<p>如果函数参数中传递的类型对象与返回类型有关，则写：</p>
<pre><code class="language-python">narray: |N: Nat| {N} -&gt; [{N}; N]
narray(N: Nat): [N; N] = [N; N]
assert array(3) == [3, 3, 3]
</code></pre>
<p>定义依赖类型时，所有类型参数都必须是常量。</p>
<p>依赖类型本身存在于现有语言中，但 Erg 具有在依赖类型上定义过程方法的特性</p>
<pre><code class="language-python">x=1
f x =
    print! f::x, module::x

# Phantom 类型有一个名为 Phantom 的属性，其值与类型参数相同
T X: Int = Class Impl := Phantom X
T(X).
    x self = self::Phantom

T(1).x() # 1
</code></pre>
<p>可变依赖类型的类型参数可以通过方法应用程序进行转换。
转换规范是用 <code>~&gt;</code> 完成的</p>
<pre><code class="language-python"># 注意 `Id` 是不可变类型，不能转换
VM!(State: {&quot;stopped&quot;, &quot;running&quot;}! := _, Id: Nat := _) = Class(..., Impl := Phantom! State)
VM!().
    # 不改变的变量可以通过传递`_`省略。
    start! ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.initialize_something!()
        self::set_phantom!(&quot;running&quot;)

# 你也可以按类型参数切出(仅在定义它的模块中)
VM!.new() = VM!(!&quot;stopped&quot;, 1).new()
VM!(&quot;running&quot; ~&gt; &quot;running&quot;).stop!ref!self =
    self.close_something!()
    self::set_phantom!(&quot;stopped&quot;)

vm = VM!.new()
vm.start!()
vm.stop!()
vm.stop!() # 类型错误：VM!(!&quot;stopped&quot;, 1) 没有 .stop!()
# 提示：VM!(!&quot;running&quot;, 1) 有 .stop!()
</code></pre>
<p>您还可以嵌入或继承现有类型以创建依赖类型。</p>
<pre><code class="language-python">MyArray(T, N) = Inherit[T; N]

# self 的类型：Self(T, N) 与 .array 一起变化
MyStruct!(T, N: Nat!) = Class {.array: [T; !N]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型变量量化类型"><a class="header" href="#类型变量量化类型">类型变量，量化类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/15_quantified.md&amp;commit_hash=14657486719a134f494e107774ac8f9d5a63f083"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/15_quantified.md%26commit_hash%3D14657486719a134f494e107774ac8f9d5a63f083" alt="badge" /></a></p>
<p>类型变量是用于例如指定子程序参数类型的变量，它的类型是任意的(不是单态的)。
首先，作为引入类型变量的动机，考虑 <code>id</code> 函数，它按原样返回输入。</p>
<pre><code class="language-python">id x: Int = x
</code></pre>
<p>返回输入的&quot;id&quot;函数是为&quot;Int&quot;类型定义的，但这个函数显然可以为任何类型定义。
让我们使用 <code>Object</code> 来表示最大的类。</p>
<pre><code class="language-python">id x: Object = x

i = id 1
s = id &quot;foo&quot;
b = id True
</code></pre>
<p>当然，它现在接受任意类型，但有一个问题：返回类型被扩展为 <code>Object</code>。 返回类型扩展为 <code>Object</code>。
如果输入是&quot;Int&quot;类型，我想查看返回类型&quot;Int&quot;，如果输入是&quot;Str&quot;类型，我想查看&quot;Str&quot;。</p>
<pre><code class="language-python">print! id 1 # &lt;Object object&gt;
id(1) + 1 # 类型错误：无法添加 `Object` 和 `Int
</code></pre>
<p>要确保输入的类型与返回值的类型相同，请使用 <strong>type 变量</strong>。
类型变量在<code>||</code>(类型变量列表)中声明。</p>
<pre><code class="language-python">id|T: Type| x: T = x
assert id(1) == 1
assert id(&quot;foo&quot;) == &quot;foo&quot;
assert id(True) == True
</code></pre>
<p>这称为函数的 <strong>universal quantification(泛化)</strong>。 有细微的差别，但它对应于其他语言中称为泛型的函数。 泛化函数称为__多态函数__。
定义一个多态函数就像为所有类型定义一个相同形式的函数(Erg 禁止重载，所以下面的代码真的不能写)。</p>
<pre><code class="language-python">id|T: Type| x: T = x
# 伪代码
id x: Int = x
id x: Str = x
id x: Bool = x
id x: Ratio = x
id x: NoneType = x
...
</code></pre>
<p>此外，类型变量&quot;T&quot;可以推断为&quot;Type&quot;类型，因为它在类型规范中使用。 所以 <code>|T: Type|</code> 可以简单地缩写为 <code>|T|</code>。
你也可以省略<code>|T, N| 脚; N]</code> 如果可以推断它不是类型对象(<code>T: Type, N: Nat</code>)。</p>
<p>如果类型对于任意类型来说太大，您也可以提供约束。
约束也有优势，例如，子类型规范允许使用某些方法。</p>
<pre><code class="language-python"># T &lt;: Add
# =&gt; T 是 Add 的子类
# =&gt; 可以做加法
add|T &lt;: Add| l: T, r: T = l + r
</code></pre>
<p>在本例中，<code>T</code> 必须是<code>Add</code> 类型的子类，并且要分配的<code>l</code> 和<code>r</code> 的实际类型必须相同。
在这种情况下，&quot;T&quot;由&quot;Int&quot;、&quot;Ratio&quot;等满足。因此，例如，&quot;Int&quot;和&quot;Str&quot;的添加没有定义，因此被拒绝。</p>
<p>您也可以像这样键入它。</p>
<pre><code class="language-python">f|
    Y, Z: Type
    X &lt;: Add Y, O1
    O1 &lt;: Add Z, O2
    O2 &lt;: Add X, _
| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>如果注释列表很长，您可能需要预先声明它。</p>
<pre><code class="language-python">f: |Y, Z: Type, X &lt;: Add(Y, O1), O1 &lt;: Add(Z, O2), O2 &lt;: Add(X, O3)| (X, Y, Z) -&gt; O3
f|X, Y, Z| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>与许多具有泛型的语言不同，所有声明的类型变量都必须在临时参数列表(<code>x: X, y: Y, z: Z</code> 部分)或其他类型变量的参数中使用。
这是 Erg 语言设计的一个要求，即所有类型变量都可以从真实参数中推断出来。
因此，无法推断的信息，例如返回类型，是从真实参数传递的； Erg 允许从实参传递类型。</p>
<pre><code class="language-python">Iterator T = Trait {
    # 从参数传递返回类型。
    # .collect: |K: Type -&gt; Type| Self(T). ({K}) -&gt; K(T)
    .collect(self, K: Type -&gt; Type): K(T) = ...
    ...
}

it = [1, 2, 3].iter().map i -&gt; i + 1
it.collect(Array) # [2, 3, 4].
</code></pre>
<p>类型变量只能在 <code>||</code> 期间声明。 但是，一旦声明，它们就可以在任何地方使用，直到它们退出作用域</p>
<pre><code class="language-python">f|X|(x: X): () =
    y: X = x.clone()
    log X.__name__
    log X

f 1
# Int
# &lt;class Int&gt;
</code></pre>
<p>您也可以在使用时明确单相如下</p>
<pre><code class="language-python">f: Int -&gt; Int = id|Int|
</code></pre>
<p>在这种情况下，指定的类型优先于实际参数的类型(匹配失败将导致类型错误，即实际参数的类型错误)。
即如果传递的实际对象可以转换为指定的类型，则进行转换； 否则会导致编译错误。</p>
<pre><code class="language-python">assert id(1) == 1
assert id|Int|(1) in Int
assert id|Ratio|(1) in Ratio
# 你也可以使用关键字参数
assert id|T: Int|(1) == 1
id|Int|(&quot;str&quot;) # 类型错误: id|Int| is type `Int -&gt; Int`但得到了 Str
</code></pre>
<p>当此语法与理解相冲突时，您需要将其括在 <code>()</code> 中。</p>
<pre><code class="language-python"># {id|Int| x | x &lt;- 1..10} 将被解释为 {id | ...}
{(id|Int| x) | x &lt;- 1..10}
</code></pre>
<p>不能使用与已存在的类型相同的名称来声明类型变量。 这是因为所有类型变量都是常量。</p>
<pre><code class="language-python">I: Type
# ↓ 无效类型变量，已经存在
f|I: Type| ... = ...
</code></pre>
<h2 id="在方法定义中输入参数"><a class="header" href="#在方法定义中输入参数">在方法定义中输入参数</a></h2>
<p>默认情况下，左侧的类型参数被视为绑定变量。</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(T, N).
    foo(x) = ...
</code></pre>
<p>使用另一个类型变量名称将导致警告。</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(U, M). # 警告：K 的类型变量名是 'T' 和 'N'
    foo(x) = ...
</code></pre>
<p>自定义以来，所有命名空间中的常量都是相同的，因此它们当然不能用于类型变量名称</p>
<pre><code class="language-python">N = 1
K(N: Nat) = ... # 名称错误：N 已定义

L(M: Nat) = ...
# 仅当 M == N == 1 时才定义
L(N).
    foo(self, x) = ...
# 为任何定义 M: Nat
L(M).
    .bar(self, x) = ...
</code></pre>
<p>每个类型参数不能有多个定义，但可以定义具有相同名称的方法，因为未分配类型参数的依赖类型(非原始类型)和分配的依赖类型(原始类型)之间没有关系 )。</p>
<pre><code class="language-python">K(I: Int) = ...
K.
    # K 不是真正的类型(atomic Kind)，所以我们不能定义方法
    # 这不是方法(更像是静态方法)
    foo(x) = ...
K(0).
    foo(self, x): Nat = ...
</code></pre>
<h2 id="所有对称类型"><a class="header" href="#所有对称类型">所有对称类型</a></h2>
<p>上一节中定义的 <code>id</code> 函数是一个可以是任何类型的函数。 那么 <code>id</code> 函数本身的类型是什么?</p>
<pre><code class="language-python">print! classof(id) # |T: Type| T -&gt; T
</code></pre>
<p>我们得到一个类型<code>|T: Type| T -&gt; T</code>。 这称为一个 <strong>封闭的全称量化类型/全称类型</strong>，即<code>['a. ...]'</code> 在 ML 和 <code>forall t. ...</code> 在 Haskell 中。 为什么使用形容词&quot;关闭&quot;将在下面讨论。</p>
<p>封闭的全称量化类型有一个限制：只有子程序类型可以被通用量化，即只有子程序类型可以放在左子句中。 但这已经足够了，因为子程序是 Erg 中最基本的控制结构，所以当我们说&quot;我要处理任意 X&quot;时，即我想要一个可以处理任意 X 的子程序。所以，量化类型具有相同的含义 作为多态函数类型。 从现在开始，这种类型基本上被称为多态函数类型。</p>
<p>与匿名函数一样，多态类型具有任意类型变量名称，但它们都具有相同的值。</p>
<pre><code class="language-python">assert (|T: Type| T -&gt; T) == (|U: Type| U -&gt; U)
</code></pre>
<p>当存在 alpha 等价时，等式得到满足，就像在 lambda 演算中一样。 由于对类型的操作有一些限制，所以总是可以确定等价的(如果我们不考虑 stoppage 属性)。</p>
<h2 id="多态函数类型的子类型化"><a class="header" href="#多态函数类型的子类型化">多态函数类型的子类型化</a></h2>
<p>多态函数类型可以是任何函数类型。 这意味着与任何函数类型都存在子类型关系。 让我们详细看看这种关系。</p>
<p>类型变量在左侧定义并在右侧使用的类型，例如 <code>OpenFn T: Type = T -&gt; T</code>，称为 <strong>open 通用类型</strong>。
相反，在右侧定义和使用类型变量的类型，例如 <code>ClosedFn = |T: Type| T -&gt; T</code>，被称为 <strong>封闭的通用类型</strong>。</p>
<p>开放通用类型是所有同构&quot;真&quot;类型的超类型。 相反，封闭的通用类型是所有同构真类型的子类型。</p>
<pre><code class="language-python">(|T: Type| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)
</code></pre>
<p>您可能还记得封闭的较小/开放的较大。
但为什么会这样呢? 为了更好地理解，让我们考虑每个实例。</p>
<pre><code class="language-python"># id: |T: Type| T -&gt; T
id|T|(x: T): T = x

# iid: Int -&gt; Int
iid(x: Int): Int = x

# 按原样返回任意函数
id_arbitrary_fn|T|(f1: T -&gt; T): (T -&gt; T) = f
# id_arbitrary_fn(id) == id
# id_arbitrary_fn(iid) == iid

# return the poly correlation number as it is
id_poly_fn(f2: (|T| T -&gt; T)): (|T| T -&gt; T) = f
# id_poly_fn(id) == id
id_poly_fn(iid) # 类型错误

# 按原样返回 Int 类型函数
id_int_fn(f3: Int -&gt; Int): (Int -&gt; Int) = f
# id_int_fn(id) == id|Int|
# id_int_fn(iid) == iid
</code></pre>
<p>由于 <code>id</code> 是 <code>|T: Type| 类型T -&gt; T</code>，可以赋值给<code>Int-&gt; Int</code>类型的参数<code>f3</code>，我们可以考虑<code>(|T| T -&gt; T) &lt; (Int -&gt; Int)</code>。
反之，<code>Int -&gt; Int</code>类型的<code>iid</code>不能赋值给<code>(|T| T -&gt; T)</code>类型的参数<code>f2</code>，但可以赋值给<code>(|T| T -&gt; T)</code>的参数<code>f1</code>输入 <code>T -&gt; T</code>，所以 <code>(Int -&gt; Int) &lt; (T -&gt; T)</code>。
因此，确实是<code>(|T| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)</code>。</p>
<h2 id="量化类型和依赖类型"><a class="header" href="#量化类型和依赖类型">量化类型和依赖类型</a></h2>
<p>依赖类型和量化类型(多态函数类型)之间有什么关系，它们之间有什么区别?
我们可以说依赖类型是一种接受参数的类型，而量化类型是一种赋予参数任意性的类型。</p>
<p>重要的一点是封闭的多态类型本身没有类型参数。例如，多态函数类型<code>|T| T -&gt; T</code> 是一个接受多态函数 <strong>only</strong> 的类型，它的定义是封闭的。您不能使用其类型参数<code>T</code>来定义方法等。</p>
<p>在 Erg 中，类型本身也是一个值，因此带参数的类型(例如函数类型)可能是依赖类型。换句话说，多态函数类型既是量化类型又是依赖类型。</p>
<pre><code class="language-python">PolyFn = Patch(|T| T -&gt; T)
PolyFn.
    type self = T # 名称错误：找不到&quot;T&quot;
DepFn T = Patch(T -&gt; T)
DepFn.
    type self =
        log &quot;by DepFn&quot;
        T

assert (Int -&gt; Int).type() == Int # 由 DepFn
assert DepFn(Int).type() == Int # 由 DepFn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子类型"><a class="header" href="#子类型">子类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/16_subtyping.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/16_subtyping.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>在 Erg 中，可以使用比较运算符 <code>&lt;</code>、<code>&gt;</code> 确定类包含。</p>
<pre><code class="language-python">Nat &lt; Int
Int &lt; Object
1... _ &lt; Nat
{1, 2} &gt; {1}
{=} &gt; {x = Int}
{I: Int | I &gt;= 1} &lt; {I: Int | I &gt;= 0}
</code></pre>
<p>请注意，这与 <code>&lt;:</code> 运算符的含义不同。 它声明左侧的类是右侧类型的子类型，并且仅在编译时才有意义。</p>
<pre><code class="language-python">C &lt;: T # T: 结构类型
f|D &lt;: E| ...

assert F &lt; G
</code></pre>
<p>您还可以为多态子类型规范指定 <code>Self &lt;: Add</code>，例如 <code>Self(R, O) &lt;: Add(R, O)</code>。</p>
<h2 id="结构类型和类类型关系"><a class="header" href="#结构类型和类类型关系">结构类型和类类型关系</a></h2>
<p>结构类型是结构类型的类型，如果它们具有相同的结构，则被认为是相同的对象。</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}

assert T == U
t: T = {i = 1}
assert t in T
assert t in U
</code></pre>
<p>相反，类是符号类型的类型，不能在结构上与类型和实例进行比较</p>
<pre><code class="language-python">C = Class {i = Int}
D = Class {i = Int}

assert C == D # 类型错误：无法比较类
c = C.new {i = 1}
assert c in C
assert not c in D
</code></pre>
<h2 id="子程序的子类型化"><a class="header" href="#子程序的子类型化">子程序的子类型化</a></h2>
<p>子例程的参数和返回值只采用一个类。
换句话说，您不能直接将结构类型或特征指定为函数的类型。
必须使用部分类型规范将其指定为&quot;作为该类型子类型的单个类&quot;。</p>
<pre><code class="language-python"># OK
f1 x, y: Int = x + y
# NG
f2 x, y: Add = x + y
# OK
# A 是一些具体的类
f3&lt;A &lt;: Add&gt; x, y: A = x + y
</code></pre>
<p>子程序中的类型推断也遵循此规则。 当子例程中的变量具有未指定的类型时，编译器首先检查它是否是其中一个类的实例，如果不是，则在特征范围内查找匹配项。 如果仍然找不到，则会发生编译错误。 此错误可以通过使用结构类型来解决，但由于推断匿名类型可能会给程序员带来意想不到的后果，因此它被设计为由程序员使用 <code>Structural</code> 显式指定。</p>
<h2 id="类向上转换"><a class="header" href="#类向上转换">类向上转换</a></h2>
<pre><code class="language-python">i: Int
i as (Int or Str)
i as (1..10)
i as {I: Int | I &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="投掷"><a class="header" href="#投掷">投掷</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/17_type_casting.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/17_type_casting.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="向上转型"><a class="header" href="#向上转型">向上转型</a></h2>
<p>因为 Python 是一种使用鸭子类型的语言，所以没有强制转换的概念。没有必要向上转型，本质上也没有向下转型。
但是，Erg 是静态类型的，因此有时必须进行强制转换。
一个简单的例子是 <code>1 + 2.0</code>：<code>+</code>(Int, Ratio) 或 Int(&lt;: Add(Ratio, Ratio)) 操作在 Erg 语言规范中没有定义。这是因为 <code>Int &lt;: Ratio</code>，所以 1 向上转换为 1.0，即 Ratio 的一个实例。</p>
<p>~~ Erg扩展字节码在BINARY_ADD中增加了类型信息，此时类型信息为Ratio-Ratio。在这种情况下，BINARY_ADD 指令执行 Int 的转换，因此没有插入指定转换的特殊指令。因此，例如，即使您在子类中重写了某个方法，如果您将父类指定为类型，则会执行类型强制，并在父类的方法中执行该方法(在编译时执行名称修改以引用父母的方法)。编译器只执行类型强制验证和名称修改。运行时不强制转换对象(当前。可以实现强制转换指令以优化执行)。 ~~</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    # Override 需要 Override 装饰器
    @Override
    greet!() = print! &quot;Hello from Child&quot;

greet! p: Parent = p.greet!()

parent = Parent.new()
child = Child.new()

parent # 来自Parent的问候！
child #  来自child的问候！
</code></pre>
<p>此行为不会造成与 Python 的不兼容。 首先，Python 没有指定变量的类型，所以可以这么说，所有的变量都是类型变量。 由于类型变量会选择它们可以适应的最小类型，因此如果您没有在 Erg 中指定类型，则可以实现与 Python 中相同的行为。</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    greet!() = print! &quot;Hello from Child&quot; Child.

greet! some = some.greet!()

parent = Parent.new()
child = Child.new()

parent # 来自Parent的问候！
child #  来自child的问候！
</code></pre>
<p>您还可以使用 <code>.from</code> 和 <code>.into</code>，它们会为相互继承的类型自动实现</p>
<pre><code class="language-python">assert 1 == 1.0
assert Ratio.from(1) == 1.0
assert 1.into&lt;Ratio&gt;() == 1.0
</code></pre>
<h2 id="向下转型"><a class="header" href="#向下转型">向下转型</a></h2>
<p>由于向下转换通常是不安全的并且转换方法很重要，我们改为实现&quot;TryFrom.try_from&quot;</p>
<pre><code class="language-python">IntTryFromFloat = Patch Int
IntTryFromFloat.
    try_from r: Float =
        if r.ceil() == r:
            then: r.ceil()
            else: Error &quot;conversion failed&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可变类型"><a class="header" href="#可变类型">可变类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/18_mut.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/18_mut.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>：本节中的信息是旧的并且包含一些错误。</p>
</blockquote>
<p>默认情况下，Erg 中的所有类型都是不可变的，即它们的内部状态无法更新。
但是你当然也可以定义可变类型。 变量类型用 <code>!</code> 声明。</p>
<pre><code class="language-python">Person! = Class({name = Str; age = Nat!})
Person!.
    greet! ref! self = print! &quot;Hello, my name is {self::name}. I am {self::age}.&quot;
    inc_age!ref!self = self::name.update!old -&gt; old + 1
</code></pre>
<p>准确地说，基类型是可变类型或包含可变类型的复合类型的类型必须在类型名称的末尾有一个&quot;！&quot;。 没有 <code>!</code> 的类型可以存在于同一个命名空间中，并被视为单独的类型。
在上面的例子中，<code>.age</code> 属性是可变的，<code>.name</code> 属性是不可变的。 如果即使一个属性是可变的，那么整个属性也是可变的。</p>
<p>可变类型可以定义重写实例的过程方法，但具有过程方法并不一定使它们可变。 例如数组类型<code>[T; N]</code> 实现了一个 <code>sample!</code> 随机选择一个元素的方法，但当然不会破坏性地修改数组。</p>
<p>对可变对象的破坏性操作主要是通过 .update! 方法完成的。 <code>.update!</code> 方法是一个高阶过程，它通过应用函数 <code>f</code> 来更新 <code>self</code></p>
<pre><code class="language-python">i = !1
i.update! old -&gt; old + 1
assert i == 2
</code></pre>
<p><code>.set!</code> 方法只是丢弃旧内容并用新值替换它。 .set!x = .update!_ -&gt; x。</p>
<pre><code class="language-python">i = !1
i.set! 2
assert i == 2
</code></pre>
<p><code>.freeze_map</code> 方法对不变的值进行操作</p>
<pre><code class="language-python">a = [1, 2, 3].into [Nat; !3]
x = a.freeze_map a: [Nat; 3] -&gt; a.iter().map(i -&gt; i + 1).filter(i -&gt; i % 2 == 0).collect(Array)
</code></pre>
<p>在多态不可变类型中，该类型的类型参数&quot;T&quot;被隐式假定为不可变。</p>
<pre><code class="language-python"># ImmutType &lt; Type
KT: ImmutType = Class ...
K!T: Type = Class ...
</code></pre>
<p>在标准库中，变量 <code>(...)!</code> 类型通常基于不可变 <code>(...)</code> 类型。 但是，<code>T!</code> 和 <code>T</code> 类型没有特殊的语言关系，并且不能这样构造 <a href="type/18_mut.html#1"><sup id="f1">1</sup></a> 。</p>
<p>请注意，有几种类型的对象可变性。
下面我们将回顾内置集合类型的不可变/可变语义。</p>
<pre><code class="language-python"># 数组类型
## 不可变类型
[T; N] # 不能执行可变操作
## 可变类型
[T; N] # 可以一一改变内容
[T; !N] # 可变长度，内容不可变但可以通过添加/删除元素来修改
[!T; N] # 内容是不可变的对象，但是可以替换成不同的类型(实际上可以通过不改变类型来替换)
[!T; !N] # 类型和长度可以改变
[T; !N] # 内容和长度可以改变
[!T!; N] # 内容和类型可以改变
[!T!; !N] # 可以执行各种可变操作
</code></pre>
<p>当然，您不必全部记住和使用它们。
对于可变数组类型，只需将 <code>!</code> 添加到您想要可变的部分，实际上是 <code>[T; N]</code>, <code>[T!; N]</code>，<code>[T; !N]</code>, <code> [T!; !N]</code> 可以涵盖大多数情况。</p>
<p>这些数组类型是语法糖，实际类型是：</p>
<pre><code class="language-python"># actually 4 types
[T; N] = Array(T, N)
[T; !N] = Array!(T, !N)
[!T; N] = ArrayWithMutType!(!T, N)
[!T; !N] = ArrayWithMutTypeAndLength!(!T, !N)
[T!; !N] = Array!(T!, !N)
[!T!; N] = ArrayWithMutType!(!T!, N)
[!T!; !N] = ArrayWithMutTypeAndLength!(!T!, !N)
</code></pre>
<p>这就是能够改变类型的意思。</p>
<pre><code class="language-python">a = [1, 2, 3].into [!Nat; 3]
a.map!(_ -&gt; &quot;a&quot;)
a: [!Str; 3]
</code></pre>
<p>其他集合类型也是如此。</p>
<pre><code class="language-python"># 元组类型
## 不可变类型
(T, U) # 元素个数不变，内容不能变
## 可变类型
(T!, U) # 元素个数不变，第一个元素可以改变
(T，U)！ # 元素个数不变，内容可以替换
...
</code></pre>
<pre><code class="language-python"># 设置类型
## 不可变类型
{T; N} # 不可变元素个数，内容不能改变
## 可变类型
{T！; N} # 不可变元素个数，内容可以改变(一个一个)
{T; N}！ # 可变元素个数，内容不能改变
{T！; N}！ # 可变元素个数，内容可以改变
...
</code></pre>
<pre><code class="language-python"># 字典类型
## 不可变类型
{K: V} # 长度不可变，内容不能改变
## 可变类型
{K:V!} # 恒定长度，值可以改变(一一)
{K：V}！ # 可变长度，内容不能改变，但可以通过添加或删除元素来增加或删除，内容类型也可以改变
...
</code></pre>
<pre><code class="language-python"># 记录类型
## 不可变类型
{x = Int; y = Str} # 内容不能改变
## 可变类型
{x = Int！; y = Str} # 可以改变x的值
{x = Int; y = Str}！ # 替换 {x = Int; 的任何实例 y = Str}
...
</code></pre>
<p>一个类型 <code>(...)</code> 简单地变成了 <code>T! = (...)!</code> 当 <code>T = (...)</code> 被称为简单结构化类型。 简单的结构化类型也可以(语义上)说是没有内部结构的类型。
数组、元组、集合、字典和记录类型都是非简单的结构化类型，但 Int 和 Sieve 类型是。</p>
<pre><code class="language-python">#筛子类型
## 枚举
{1, 2, 3} # 1, 2, 3 之一，不可更改
{1、2、3}！ # 1、2、3，可以改
##区间类型
1..12 #1到12，不能改
1..12！ # 1-12中的任意一个，你可以改变
##筛型(普通型)
{I: Int | I % 2 == 0} #偶数类型，不可变
{I: Int | I % 2 == 0} #偶数类型，可以改变
{I: Int | I % 2 == 0}！ # 与上面完全相同的类型，但上面的表示法是首选
</code></pre>
<p>从上面的解释来看，可变类型不仅包括自身可变的，还包括内部类型可变的。
诸如 <code>{x: Int!}</code> 和 <code>[Int!; 之类的类型3]</code> 是内部可变类型，其中内部的对象是可变的，而实例本身是不可变的。</p>
<p>对于具有内部结构并在类型构造函数本身上具有 <code>!</code> 的类型 <code>K!(T, U)</code>，<code>*self</code> 可以更改整个对象。也可以进行局部更改。
但是，希望尽可能保持本地更改权限，因此如果只能更改 <code>T</code>，最好使用 <code>K(T!, U)</code>。
而对于没有内部结构的类型‘T!’，这个实例只是一个可以交换的‘T’盒子。方法不能更改类型。</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> <code>T!</code> 和 <code>T</code> 类型没有特殊的语言关系是有意的。这是一个设计。如果存在关系，例如命名空间中存在<code>T</code>/<code>T!</code>类型，则无法从其他模块引入<code>T!</code>/<code>T</code>类型。此外，可变类型不是为不可变类型唯一定义的。给定定义 <code>T = (U, V)</code>，<code>T!</code> 的可能变量子类型是 <code>(U!, V)</code> 和 <code>(U, V!)</code>。<a href="type/18_mut.html#f1">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><p>下面，我们将讨论更高级的类型系统。 初学者不必阅读所有部分。<a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced.md&amp;commit_hash=d15cbbf7b33df0f78a575cff9679d84c36ea3ab1"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced.md%26commit_hash%3Dd15cbbf7b33df0f78a575cff9679d84c36ea3ab1" alt="badge" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带默认参数的函数类型"><a class="header" href="#带默认参数的函数类型">带默认参数的函数类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/default_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/default_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>首先，让我们看一个使用默认参数的示例。</p>
<pre><code class="language-python">f: (Int, Int, z := Int) -&gt; Int
f(x, y, z := 0) = x + y + z

g: (Int, Int, z := Int, w := Int) -&gt; Int
g(x, y, z := 0, w := 1) = x + y + z + w

fold: ((Int, Int) -&gt; Int, [Int], acc := Int) -&gt; Int
fold(f, [], acc) = acc
fold(f, arr, acc := 0) = fold(f, arr[1..], f(acc, arr[0]))
assert fold(f, [1, 2, 3]) == 6
assert fold(g, [1, 2, 3]) == 8
</code></pre>
<p><code>:=</code> 之后的参数是默认参数。
子类型规则如下:</p>
<pre><code class="language-python">((X, y := Y) -&gt; Z) &lt;: (X -&gt; Z)
((X, y := Y, ...) -&gt; Z) &lt;: ((X, ...) -&gt; Z)
</code></pre>
<p>第一个意味着可以用没有默认参数的函数来识别具有默认参数的函数。
第二个意味着可以省略任何默认参数。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型擦除"><a class="header" href="#类型擦除">类型擦除</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/erasure.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/erasure.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>类型擦除是将类型参数设置为 <code>_</code> 并故意丢弃其信息的过程。类型擦除是许多多态语言的特性，但在 Erg 的语法上下文中，将其称为类型参数擦除更为准确。</p>
<p>类型擦除的最常见示例是 <code>[T, _]</code>。数组在编译时并不总是知道它们的长度。例如，引用命令行参数的 <code>sys.argv</code> 的类型为 <code>[Str, _]</code>。由于 Erg 的编译器无法知道命令行参数的长度，因此必须放弃有关其长度的信息。
然而，一个已经被类型擦除的类型变成了一个未被擦除的类型的超类型(例如<code>[T; N] &lt;: [T; _]</code>)，所以它可以接受更多的对象。
类型的对象<code>[T; N]</code> 当然可以使用 <code>[T; _]</code>，但使用后会删除<code>N</code>信息。如果长度没有改变，那么可以使用<code>[T; N]</code> 在签名中。如果长度保持不变，则必须由签名指示。</p>
<pre><code class="language-python"># 保证不改变数组长度的函数(例如，排序)
f: [T; N] -&gt; [T; N] # 没有的函数 (f: [T; N])
# 没有的功能(例如过滤器)
g: [T; n] -&gt; [T; _]
</code></pre>
<p>如果您在类型规范本身中使用 <code>_</code>，则类型将向上转换为 <code>Object</code>。
对于非类型类型参数(Int、Bool 等)，带有 <code>_</code> 的参数将是未定义的。</p>
<pre><code class="language-python">i: _ # i: Object
[_; _] == [Object; _] == Array
</code></pre>
<p>类型擦除与省略类型说明不同。 一旦类型参数信息被删除，除非您再次声明它，否则它不会被返回。</p>
<pre><code class="language-python">implicit = (1..5).iter().map(i -&gt; i * 2).to_arr()
explicit = (1..5).iter().map(i -&gt; i * 2).into(Array(Nat))
</code></pre>
<p>在 Rust 中，这对应于以下代码:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let partial = (1..6).iter().map(|i| i * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Erg 不允许部分省略类型，而是使用高阶种类多态性。</p>
<pre><code class="language-python"># collect 是采用 Kind 的高阶 Kind 方法
hk = (1..5).iter().map(i -&gt; i * 2).collect(Array)
hk: Array(Int)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存在类型"><a class="header" href="#存在类型">存在类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/existential.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/existential.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>如果存在对应于∀的for-all类型，那么很自然地假设存在对应于∃的存在类型。
存在类型并不难。 你已经知道存在类型，只是没有意识到它本身。</p>
<pre><code class="language-python">T: Trait
f x: T = ...
</code></pre>
<p>上面的 trait <code>T</code> 被用作存在类型。
相比之下，小写的<code>T</code>只是一个特征，<code>X</code>是一个for-all类型。</p>
<pre><code class="language-python">f|X &lt;: T| x: X = ...
</code></pre>
<p>事实上，existential 类型被 for-all 类型所取代。 那么为什么会有存在类型这样的东西呢?
首先，正如我们在上面看到的，存在类型不涉及类型变量，这简化了类型规范。
此外，由于可以删除类型变量，因此如果它是一个全推定类型，则可以构造一个等级为 2 或更高的类型。</p>
<pre><code class="language-python">show_map f: (|T| T -&gt; T), arr: [Show; _] =
    arr.map x -&gt;
        y = f x
        log y
        y
</code></pre>
<p>但是，如您所见，existential 类型忘记或扩展了原始类型，因此如果您不想扩展返回类型，则必须使用 for-all 类型。
相反，仅作为参数且与返回值无关的类型可以写为存在类型。</p>
<pre><code class="language-python"># id(1): 我希望它是 Int
id|T|(x: T): T = x
# |S &lt;: Show|(s: S) -&gt; () 是多余的
show(s: Show): () = log s
</code></pre>
<p>顺便说一句，类不称为存在类型。 一个类不被称为存在类型，因为它的元素对象是预定义的。
存在类型是指满足某种特征的任何类型，它不是知道实际分配了什么类型的地方。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="广义代数数据类型-gadt"><a class="header" href="#广义代数数据类型-gadt">广义代数数据类型 (GADT)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/GADTs.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/GADTs.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg 可以通过对 Or 类型进行分类来创建广义代数数据类型 (GADT)。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
Cons T = Class {head = T; rest = List T}, Impl := Unpack
List T: Type = Class(Nil T or Cons T)
List.
    nil|T|() = Self(T).new Nil(T).new()
    cons head, rest | T = Self(T).new Cons(T).new(head, rest)
    head self = match self:
        {head; ...}: Cons_ -&gt; head
        _: Nil -&gt; panic &quot;empty list&quot;
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil.head() # 运行时错误：&quot;空list&quot;
</code></pre>
<p>我们说 <code>List.nil|T|() = ...</code> 而不是 <code>List(T).nil() = ...</code> 的原因是我们在使用它时不需要指定类型。</p>
<pre><code class="language-python">i = List.nil()
_: List Int = cons 1, i
</code></pre>
<p>这里定义的 <code>List T</code> 是 GADTs，但它是一个幼稚的实现，并没有显示 GADTs 的真正价值。
例如，上面的 .head 方法会在 body 为空时抛出运行时错误，但是这个检查可以在编译时进行。</p>
<pre><code class="language-python">List: (Type, {&quot;Empty&quot;, &quot;Nonempty&quot;}) -&gt; Type
List T, &quot;Empty&quot; = Class(Impl := Phantom T)
List T, &quot;Nonempty&quot; = Class {head = T; rest = List(T, _)}, Impl := Unpack
List.
    nil|T|() = Self(T, &quot;Empty&quot;).new Nil(T).new()
    cons head, rest | T = Self(T, &quot;Nonempty&quot;).new {head; rest}
List(T, &quot;Nonempty&quot;).
    head {head; ...} = head
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil().head() # 类型错误
</code></pre>
<p>街上经常解释的 GADT 的一个例子是一个列表，可以像上面那样通过类型来判断内容是否为空。
Erg 可以进一步细化以定义一个有长度的列表。</p>
<pre><code class="language-python">List: (Type, Nat) -&gt; Type
List T, 0 = Class(Impl := Phantom T)
List T, N = Class {head = T; rest = List(T, N-1)}, Impl := Unpack
List.
    nil|T|() = Self(T, 0).new Nil(T).new()
    cons head, rest | T, N = Self(T, N).new {head; rest}
List(_, N | N &gt;= 1).
    head {head; ...} = head
List(_, N | N &gt;= 2).
    pair {head = first; rest = {head = second; ...}} = [first, second]
{nil; cons; ...} = List

print! cons(1, cons(2, nil)).pair() # [1, 2]
print! cons(1, nil).pair() # 类型错误
print! cons(1, nil).head() # 1
print! nil. head() # 类型错误
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="带有关键字参数的函数类型"><a class="header" href="#带有关键字参数的函数类型">带有关键字参数的函数类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/keyword_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/keyword_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<pre><code class="language-python">h(f) = f(y: 1, x: 2)
h: |T: type|((y: Int, x: Int) -&gt; T) -&gt; T
</code></pre>
<p>带有关键字参数的函数的子类型化规则如下。</p>
<pre><code class="language-python">((x: T, y: U) -&gt; V) &lt;: ((T, U) -&gt; V) # x, y 为任意关键字参数
((y: U, x: T) -&gt; V) &lt;: ((x: T, y: U) -&gt; V)
((x: T, y: U) -&gt; V) &lt;: ((y: U, x: T) -&gt; V)
</code></pre>
<p>这意味着可以删除或替换关键字参数。
但是你不能同时做这两件事。
也就是说，您不能将 <code>(x: T, y: U) -&gt; V</code> 转换为 <code>(U, T) -&gt; V</code>。
请注意，关键字参数仅附加到顶级元组，而不附加到数组或嵌套元组。</p>
<pre><code class="language-python">Valid: [T, U] -&gt; V
Invalid: [x: T, y: U] -&gt; V
Valid: (x: T, ys: (U,)) -&gt; V
Invalid: (x: T, ys: (y: U,)) -&gt; V
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">Kind</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/kind.md&amp;commit_hash=a9ea4eca75fe849e31f83570159f84b611892d7a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/kind.md%26commit_hash%3Da9ea4eca75fe849e31f83570159f84b611892d7a" alt="badge" /></a></p>
<p>一切都在 Erg 中输入。类型本身也不例外。 <strong>kind</strong> 表示&quot;类型的类型&quot;。例如，<code>Int</code> 属于 <code>Type</code>，就像 <code>1</code> 属于 <code>Int</code>。 <code>Type</code> 是最简单的一种，<strong>atomic kind</strong>。在类型论符号中，<code>Type</code> 对应于 <code>*</code>。</p>
<p>在Kind的概念中，实际上重要的是一种或多种Kind(多项式Kind)。单项类型，例如<code>Option</code>，属于它。一元Kind表示为 <code>Type -&gt; Type</code> <a href="type/advanced/kind.html#1"><sup id="f1">1</sup></a>。诸如 <code>Array</code> 或 <code>Option</code> 之类的 <strong>container</strong> 特别是一种以类型作为参数的多项式类型。
正如符号 <code>Type -&gt; Type</code> 所表明的，<code>Option</code> 实际上是一个接收类型 <code>T</code> 并返回类型 <code>Option T</code> 的函数。但是，由于这个函数不是通常意义上的函数，所以通常称为一元类。</p>
<p>注意<code>-&gt;</code>本身，它是一个匿名函数操作符，当它接收一个类型并返回一个类型时，也可以看作是一Kind型。</p>
<p>另请注意，不是原子Kind的Kind不是类型。正如 <code>-1</code> 是一个数字但 <code>-</code> 不是，<code>Option Int</code> 是一个类型但 <code>Option</code> 不是。 <code>Option</code> 等有时被称为类型构造函数。</p>
<pre><code class="language-python">assert not Option in Type
assert Option in Type -&gt; Type
</code></pre>
<p>所以像下面这样的代码会报错：
在 Erg 中，方法只能在原子类型中定义，并且名称 <code>self</code> 不能在方法的第一个参数以外的任何地方使用。</p>
<pre><code class="language-python">#K 是一元类型
K: Type -&gt; Type
K T = Class...
K.
foo x = ... # OK，这就像是所谓的静态方法
     bar self, x = ... # 类型错误: 无法为非类型对象定义方法
K(T).
    baz self, x = ... # OK
</code></pre>
<p>二进制或更高类型的示例是 <code>{T: U}</code>(: <code>(Type, Type) -&gt; Type</code>), <code>(T, U, V)</code>(: <code>(Type, Type, Type) - &gt; Type </code>), ... 等等。</p>
<p>还有一个零项类型<code>() -&gt; Type</code>。 这有时等同于类型论中的原子类型，但在 Erg 中有所区别。 一个例子是<code>类</code>。</p>
<pre><code class="language-python">Nil = Class()
</code></pre>
<h2 id="收容类"><a class="header" href="#收容类">收容类</a></h2>
<p>多项类型之间也存在部分类型关系，或者更确切地说是部分类型关系。</p>
<pre><code class="language-python">K T = ...
L = Inherit K
L&lt;: K
</code></pre>
<p>也就是说，对于任何 <code>T</code>，如果 <code>L T &lt;: K T</code>，则 <code>L &lt;: K</code>，反之亦然。</p>
<pre><code class="language-python">∀T. L T &lt;: K T &lt;=&gt; L &lt;: K
</code></pre>
<h2 id="高阶kind"><a class="header" href="#高阶kind">高阶Kind</a></h2>
<p>还有一种高阶Kind。 这是一种与高阶函数相同的概念，一种自身接收一种类型。 <code>(Type -&gt; Type) -&gt; Type</code> 是一种更高的Kind。 让我们定义一个属于更高Kind的对象。</p>
<pre><code class="language-python">IntContainerOf K: Type -&gt; Type = K Int
assert IntContainerOf Option == Option Int
assert IntContainerOf Result == Result Int
assert IntContainerOf in (Type -&gt; Type) -&gt; Type
</code></pre>
<p>多项式类型的有界变量通常表示为 K, L, ...，其中 K 是 Kind 的 K</p>
<h2 id="设置kind"><a class="header" href="#设置kind">设置Kind</a></h2>
<p>在类型论中，有记录的概念。 这与 Erg 记录 <a href="type/advanced/kind.html#2"><sup id="f2">2</sup></a> 几乎相同。</p>
<pre><code class="language-python"># 这是一条记录，对应于类型论中所谓的记录
{x = 1; y = 2}
</code></pre>
<p>当所有的记录值都是类型时，它是一种类型，称为记录类型。</p>
<pre><code class="language-python">assert {x = 1; y = 2} in {x = Int; y = Int}
</code></pre>
<p>记录类型键入记录。 一个好的猜测者可能认为应该有一个&quot;记录类型&quot;来键入记录类型。 实际上它是存在的。</p>
<pre><code class="language-python">log Typeof {x = Int; y = Int} # {{x = Int; y = Int}}
</code></pre>
<p>像 <code>{{x = Int; 这样的类型 y = Int}}</code> 是一种记录类型。 这不是一个特殊的符号。 它只是一个枚举类型，只有 <code>{x = Int; y = Int}</code> 作为一个元素。</p>
<pre><code class="language-python">Point = {x = Int; y = Int}
Pointy = {Point}
</code></pre>
<p>记录类型的一个重要属性是，如果 <code>T: |T|</code> 和 <code>U &lt;: T</code> 则 <code>U: |T|</code>。
从枚举实际上是筛子类型的语法糖这一事实也可以看出这一点。</p>
<pre><code class="language-python"># {c} == {X: T | X == c} 对于普通对象，但是不能为类型定义相等性，所以 |T| == {X | X &lt;: T}
{Point} == {P | P &lt;: Point}
</code></pre>
<p>类型约束中的 <code>U &lt;: T</code> 实际上是 <code>U: |T|</code> 的语法糖。
作为此类类型的集合的种类通常称为集合种类。 Setkind 也出现在迭代器模式中。</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<h2 id="多项式类型的类型推断"><a class="header" href="#多项式类型的类型推断">多项式类型的类型推断</a></h2>
<pre><code class="language-python">Container K: Type -&gt; Type, T: Type = Patch K(T, T)
Container (K).
    f self = ...
Option T: Type = Patch T or NoneType
Option(T).
    f self = ...
Fn T: Type = Patch T -&gt; T
Fn(T).
    f self = ...
Fn2 T, U: Type = Patch T -&gt; U
Fn2(T, U).
    f self = ...

(Int -&gt; Int).f() # 选择了哪一个?
</code></pre>
<p>在上面的示例中，方法 <code>f</code> 会选择哪个补丁?
天真，似乎选择了<code>Fn T</code>，但是<code>Fn2 T，U</code>也是可以的，<code>Option T</code>原样包含<code>T</code>，所以任何类型都适用，<code>Container K，T</code>也匹配<code>-&gt;(Int, Int)</code>，即 <code>Container(</code>-&gt;<code>, Int)</code> 为 <code>Int -&gt; Int</code>。因此，上述所有四个修复程序都是可能的选择。</p>
<p>在这种情况下，根据以下优先标准选择修复程序。</p>
<ul>
<li>任何 <code>K(T)</code>(例如 <code>T or NoneType</code>)优先匹配 <code>Type -&gt; Type</code> 而不是 <code>Type</code>。</li>
<li>任何 <code>K(T, U)</code>(例如 <code>T -&gt; U</code>)优先匹配 <code>(Type, Type) -&gt; Type</code> 而不是 <code>Type</code>。</li>
<li>类似的标准适用于种类 3 或更多。</li>
<li>选择需要较少类型变量来替换的那个。例如，<code>Int -&gt; Int</code> 是 <code>T -&gt; T</code> 而不是 <code>K(T, T)</code>(替换类型变量：K, T)或 <code>T -&gt; U</code>(替换类型变量：T, U )。(替换类型变量：T)优先匹配。</li>
<li>如果更换的次数也相同，则报错为不可选择。</li>
</ul>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> 在类型理论符号中，<code>*=&gt;*</code> <a href="type/advanced/kind.html#f1">↩</a></span></p>
<p><span id="2" style="font-size:x-small"><sup>2</sup> 可见性等细微差别。<a href="type/advanced/kind.html#f2">↩</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标记特征"><a class="header" href="#标记特征">标记特征</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/marker_trait.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/marker_trait.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>标记特征是没有必需属性的特征。 也就是说，您可以在不实现任何方法的情况下实现 Impl。
没有 required 属性似乎没有意义，但由于注册了它属于 trait 的信息，因此可以使用 patch 方法或由编译器进行特殊处理。</p>
<p>所有标记特征都包含在&quot;标记&quot;特征中。
作为标准提供的&quot;光&quot;是一种标记特征。</p>
<pre><code class="language-python">Light = Subsume Marker
</code></pre>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat} and Light
</code></pre>
<pre><code class="language-python">M = Subsume Marker

MarkedInt = Inherit Int, Impl := M

i = MarkedInt.new(2)
assert i + 1 == 2
assert i in M
</code></pre>
<p>标记类也可以使用 <code>Excluding</code> 参数排除。</p>
<pre><code class="language-python">NInt = Inherit MarkedInt, Impl := N, Excluding: M
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可变结构类型"><a class="header" href="#可变结构类型">可变结构类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/mut_struct.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/mut_struct.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p><code>T!</code> 类型被描述为可以被任何 <code>T</code> 类型对象替换的盒子类型。</p>
<pre><code class="language-python">Particle!State: {&quot;base&quot;, &quot;excited&quot;}! = Class(... Impl := Phantom State)
Particle!
    # 此方法将状态从&quot;base&quot;移动到&quot;excited&quot;
    apply_electric_field!(ref! self(&quot;base&quot; ~&gt; &quot;excited&quot;), field: Vector) = ...
</code></pre>
<p><code>T!</code> 类型可以替换数据，但不能改变其结构。
更像是一个真实程序的行为，它不能改变它的大小(在堆上)。 这样的类型称为不可变结构(mutable)类型。</p>
<p>事实上，有些数据结构不能用不变的结构类型来表示。
例如，可变长度数组。 <code>[T; N]!</code>类型可以包含任何<code>[T; N]</code>，但不能被<code>[T; N+1]</code> 等等。</p>
<p>换句话说，长度不能改变。 要改变长度，必须改变类型本身的结构。</p>
<p>这是通过可变结构(可变)类型实现的。</p>
<pre><code class="language-python">v = [Str; !0].new()
v.push! &quot;Hello&quot;
v: [Str; !1].
</code></pre>
<p>对于可变结构类型，可变类型参数用 <code>!</code> 标记。 在上述情况下，类型 <code>[Str; !0]</code> 可以更改为 <code>[Str; !1]</code> 等等。 即，可以改变长度。
顺便说一句，<code>[T; !N]</code> 类型是 <code>ArrayWithLength!(T, !N)</code> 类型的糖衣语法。</p>
<p>可变结构类型当然可以是用户定义的。 但是请注意，在构造方法方面与不变结构类型存在一些差异。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, !0 = Inherit Nil T
List T, N: Nat! = Class {head = T; rest = List(T, !N-1)}
List(T, !N).
    push! ref! self(N ~&gt; N+1, ...), head: T =
        self.update! old -&gt; Self.new {head; old}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幻影phantom类"><a class="header" href="#幻影phantom类">幻影(phantom)类</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/phantom.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/phantom.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>幻像类型是标记特征，其存在仅用于向编译器提供注释。
作为幻像类型的一种用法，让我们看一下列表的结构。</p>
<pre><code class="language-python">Nil = Class()
List T, 0 = Inherit Nil
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>此代码导致错误。</p>
<pre><code class="language-python">3 | List T, 0 = Inherit Nil
                        ^^^
类型构造错误：由于Nil没有参数T，所以无法用Nil构造List(T, 0)
提示：使用 'Phantom' 特质消耗 T
</code></pre>
<p>此错误是在使用 <code>List(_, 0).new Nil.new()</code> 时无法推断 <code>T</code> 的抱怨。
在这种情况下，无论 <code>T</code> 类型是什么，它都必须在右侧使用。 大小为零的类型(例如长度为零的元组)很方便，因为它没有运行时开销。</p>
<pre><code class="language-python">Nil T = Class((T; 0))
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>此代码通过编译。 但是理解意图有点棘手，除非类型参数是类型，否则不能使用它。</p>
<p>在这种情况下，幻影类型正是您所需要的。 幻像类型是大小为 0 的广义类型。</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}

nil = Nil(Int).new()
assert nil.__size__ == 0
</code></pre>
<p><code>Phantom</code> 拥有<code>T</code> 类型。 但实际上 <code>Phantom T</code> 类型的大小是 0 并且不包含 <code>T</code> 类型的对象。</p>
<p>此外，<code>Phantom</code> 可以使用除其类型之外的任意类型参数。 在下面的示例中，<code>Phantom</code> 包含一个名为 <code>State</code> 的类型参数，它是 <code>Str</code> 的子类型对象。
同样，<code>State</code> 是一个假的类型变量，不会出现在对象的实体中。</p>
<pre><code class="language-python">VM! State: {&quot;stopped&quot;, &quot;running&quot;}! = Class(... State)
VM!(&quot;stopped&quot;).
    start ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.do_something!()
        self::set_phantom!(&quot;running&quot;))
</code></pre>
<p><code>state</code> 是通过 <code>update_phantom!</code> 或 <code>set_phantom!</code> 方法更新的。
这是标准补丁为<code>Phantom!</code>(<code>Phantom</code>的变量版本)提供的方法，其用法与变量<code>update!</code>和<code>set!</code>相同。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="投影类型"><a class="header" href="#投影类型">投影类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/projection.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/projection.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>投影类型表示如下代码中的&quot;Self.AddO&quot;等类型。</p>
<pre><code class="language-python">Add R = Trait {
    . `_+_` = Self, R -&gt; Self.AddO
    .AddO = Type
}

AddForInt = Patch(Int, Impl := Add Int)
AddForInt.
    AddO = Int
</code></pre>
<p>类型&quot;Add(R)&quot;可以说是定义了与某个对象的加法的类型。 由于方法应该是一个类型属性，<code>+</code> 类型声明应该写在缩进下面。
<code>Add</code> 类型的场景是声明 <code>.AddO = Type</code>，而 <code>.AddO</code> 类型的实体是一个投影类型，由一个作为 <code> 子类型的类型持有 添加</code>。 例如，<code>Int.AddO = Int</code>、<code>Odd.AddO = Even</code>。</p>
<pre><code class="language-python">assert Int &lt; Add
assert Int.AddO == Int
assert Odd &lt; Add
assert Odd.AddO == Even
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量化依赖类型"><a class="header" href="#量化依赖类型">量化依赖类型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/quantified_dependent.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/quantified_dependent.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg 有量化和依赖类型。 那么很自然地，就可以创建一个将两者结合起来的类型。 那是量化的依赖类型。</p>
<pre><code class="language-python">NonNullStr = |N: Nat| StrWithLen N | N ! = 0 # 同 {S | N: Nat; S: StrWithLen N; N ! = 0}
NonEmptyArray = |N: Nat| [_; N | N &gt; 0] # 同 {A | N: Nat; A: Array(_, N); N &gt; 0}
</code></pre>
<p>量化依赖类型的标准形式是&quot;K(A, ... | Pred)&quot;。 <code>K</code> 是类型构造函数，<code>A, B</code> 是类型参数，<code>Pred</code> 是条件表达式。</p>
<p>作为左值的量化依赖类型只能在与原始类型相同的模块中定义方法。</p>
<pre><code class="language-python">K A: Nat = Class ...
K(A).
    ...
K(A | A &gt;= 1).
    method ref! self(A ~&gt; A+1) = ...
</code></pre>
<p>作为右值的量化依赖类型需要在类型变量列表 (<code>||</code>) 中声明要使用的类型变量。</p>
<pre><code class="language-python"># T 是具体类型
a: |N: Nat| [T; N | N &gt; 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="共享参考"><a class="header" href="#共享参考">共享参考</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/shared.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/shared.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>共享引用是必须小心处理的语言特性之一。
例如，在 TypeScript 中，以下代码将通过类型检查。</p>
<pre><code class="language-typescript">class NormalMember {}
class VIPMember extends NormalMember {}

let vip_area: VIPMember[] = []
let normal_area: NormalMember[] = vip_area

normal_area.push(new NormalMember())
console.log(vip_area) # [NormalMember]
</code></pre>
<p>一个 NormalMember 已进入 vip_area。 这是一个明显的错误，但是出了什么问题?
原因是共享引用 <a href="type/advanced/./variance.html">denatured</a>。 <code>normal_area</code> 是通过复制 <code>vip_area</code> 来创建的，但是这样做的时候类型已经改变了。
但是 <code>VIPMember</code> 继承自 <code>NormalMember</code>，所以 <code>VIPMember[] &lt;: NormalMember[]</code>，这不是问题。
关系 <code>VIPMember[] &lt;: NormalMember[]</code> 适用于不可变对象。 但是，如果您执行上述破坏性操作，则会出现故障。</p>
<p>在 Erg 中，由于所有权系统，此类代码会被回放。</p>
<pre><code class="language-python">NormalMember = Class()
VIPMember = Class()

vip_area = [].into [VIPMember; !_]
normal_area: [NormalMember; !_] = vip_area

normal_area.push!(NormalMember.new())
log vip_area # 所有权错误：`vip_room` 已移至 `normal_room`
</code></pre>
<p>然而，一个对象只属于一个地方可能会很不方便。
出于这个原因，Erg 有一个类型 <code>SharedCell!T!</code>，它代表一个共享状态。</p>
<pre><code class="language-python">$p1 = SharedCell!.new(!1)
$p2 = $p1.mirror!()
$p3 = SharedCell!.new(!1)
# 如果$p1 == $p2，比较内容类型Int！
assert $p1 == $p2
assert $p1 == $p3
# 检查 $p1 和 $p2 是否用 `.addr!` 指向同一个东西。
assert $p1.addr!() == $p2.addr!()
assert $p1.addr!() != $p3.addr!()
$p1.add! 1
assert $p1 == 2
assert $p2 == 2
assert $p3 == 1
</code></pre>
<p><code>SharedCell!</code> 类型的对象必须以<code>$</code> 为前缀。 此外，就其性质而言，它们不可能是常数。</p>
<p><code>SharedCell！ T!</code> 类型也是 <code>T!</code> 的子类型，可以调用 <code>T!</code> 类型的方法。 <code>SharedCell!T!</code> 类型特有的唯一方法是 <code>.addr!</code>、<code>.mirror!</code> 和 <code>.try_take</code>。</p>
<p>一个重要的事实是<code>SharedCell! T!</code> 是非变体的，即没有为不同类型的参数定义包含。</p>
<pre><code class="language-python">$vip_area = SharedCell!.new([].into [VIPMember; !_])
$normal_area: SharedCell!([NormalMember; !_]) = $vip_area.mirror!() #类型错误：预期 SharedCell！([NormalMember；！_])，但得到 SharedCell！([VIPMember;!_])
# 提示：SharedCell!(T) 是非变体的，这意味着它不能有超类型或子类型。
</code></pre>
<p>但是，下面的代码没有问题。 在最后一行，它是 <code>VIPMember</code> 参数已被类型转换</p>
<pre><code class="language-python">$normal_area = SharedCell!.new([].into [NormalMember; !_])
$normal_area.push!(NormalMember.new()) # OK
$normal_area.push!(VIPMember.new()) # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/16_iterator.md&amp;commit_hash=14657486719a134f494e107774ac8f9d5a63f083"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/16_iterator.md%26commit_hash%3D14657486719a134f494e107774ac8f9d5a63f083" alt="badge" /></a></p>
<p>迭代器是用于检索容器元素的对象。</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>此代码打印数字 0 到 9。
每个数字(=Int 对象)都分配给<code>i</code>，并执行以下操作(=<code>print！i</code>)。 这种重复执行称为__iteration__。</p>
<p>现在让我们看看 <code>for!</code> 过程的类型签名。</p>
<pre><code class="language-python">for!: |T: Type, I &lt;: Iterable T| (I, T =&gt; None) =&gt; None
</code></pre>
<p>第一个参数似乎接受&quot;Iterable&quot;类型的对象。</p>
<p><code>Iterable</code> 是一个具有<code>.Iterator</code> 属性的类型，<code>.iter</code> 方法在request 方法中。</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<p><code>.Iterator</code> 属性的类型 <code>{Iterator}</code> 是所谓的 set-kind(kind 在 <a href="./type/advanced/kind.html">here</a> 中描述)</p>
<pre><code class="language-python">assert [1, 2, 3] in Iterable(Int)
assert 1..3 in Iterable(Int)
assert [1, 2, 3].Iterator == ArrayIterator
assert (1..3).Iterator == RangeIterator

log [1, 2, 3].iter() # &lt;数组迭代器对象&gt;
log (1..3).iter() # &lt;Range迭代器对象&gt;
</code></pre>
<p><code>ArrayIterator</code> 和 <code>RangeIterator</code> 都是实现 <code>Iterator</code> 的类，它们的存在只是为了提供 <code>Array</code> 和 <code>Range</code> 迭代函数。
这种设计模式称为伴生类 <a href="16_iterator.html#1"><sup id="f1">1</sup></a>。
而&quot;IteratorImpl&quot;补丁是迭代功能的核心。 <code>Iterator</code> 只需要一个<code>.next</code> 方法，<code>IteratorImpl</code> 确实提供了几十种方法。 <code>ArrayIterator</code>和<code>RangeIterator</code>只需实现<code>.next</code>方法就可以使用<code>IteratorImpl</code>的实现方法。 为了方便起见，标准库实现了许多迭代器。</p>
<pre><code class="language-mermaid">classDiagram
    class Array~T~ {
        ...
        iter() ArrayIterator~T~
    }
    class Range~T~ {
        ...
        iter() RangeIterator~T~
    }
    class Iterable~T~ {
        &lt;&lt;trait&gt;&gt;
        iter() Iterator~T~
    }
    Iterable~T~ &lt;|.. Array~T~: Impl
    Iterable~T~ &lt;|.. Range~T~: Impl
    class ArrayIterator~T~ {
        array: Array~T~
        next() T
    }
    class RangeIterator~T~ {
        range: Range~T~
        next() T
    }
    class Iterator~T~ {
        &lt;&lt;trait&gt;&gt;
        next() T
    }
    Iterator~T~ &lt;|.. ArrayIterator~T~: Impl
    Iterator~T~ &lt;|.. RangeIterator~T~: Impl

    Array &lt;-- ArrayIterator
    Range &lt;-- RangeIterator
</code></pre>
<p>诸如 <code>Iterable</code> 之类的以静态分派但统一的方式提供用于处理特征(在本例中为 <code>Iterator</code>)的接口的类型称为伴生类适配器。</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> 这个模式似乎没有统一的名称，但是在 Rust 中，有 [companion struct 模式]( https://gist.github.com/qnighy/be99c2ece6f3f4b1248608a04e104b38#:~:text=%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82 %8B%E3%80%82-,companion%20struct,-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%80% 81%E3 %81%9D%E3%81%AE)，并以此命名。 <a href="16_iterator.html#f1">↩</a> </span></p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可变性"><a class="header" href="#可变性">可变性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/17_mutability.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/17_mutability.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>正如我们已经看到的，所有 Erg 变量都是不可变的。 但是，Erg 对象具有可变性的概念。
以下面的代码为例。</p>
<pre><code class="language-python">a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>上面的代码实际上不能被 Erg 执行。 这是因为它不可重新分配。</p>
<p>可以执行此代码。</p>
<pre><code class="language-python">b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
</code></pre>
<p><code>a, b</code> 的最终结果看起来一样，但它们的含义却大不相同。
虽然 <code>a</code> 是表示 <code>Nat</code> 数组的变量，但第一行和第二行指向的对象是不同的。 名称<code>a</code>相同，但内容不同。</p>
<pre><code class="language-python">a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
</code></pre>
<p><code>id!</code> 过程返回对象驻留的内存地址。</p>
<p><code>b</code> 是一个 <code>Nat</code> &quot;动态&quot; 数组。 对象的内容发生了变化，但变量指向的是同一个东西</p>
<pre><code class="language-python">b = ![1, 2, 3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
</code></pre>
<pre><code class="language-python">i = !0
if! True. do!
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
</code></pre>
<p><code>!</code> 是一个特殊的运算符，称为 <strong>mutation 运算符</strong>。 它使不可变对象可变。
标有&quot;！&quot;的对象的行为可以自定义。</p>
<pre><code class="language-python">Point = Class {.x = Int; .y = Int}

# 在这种情况下 .x 是可变的，而 .y 保持不变
Point! = Class {.x = Int!; .y = Int}
Point!.
    inc_x! ref!(self) = self.x.update! x -&gt; x + 1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
</code></pre>
<h2 id="常量-1"><a class="header" href="#常量-1">常量</a></h2>
<p>与变量不同，常量在所有范围内都指向同一事物。
常量使用 <code>=</code> 运算符声明。</p>
<pre><code class="language-python">PI = 3.141592653589
match! x:
    PI =&gt; print! &quot;this is pi&quot;
</code></pre>
<p>常量在全局以下的所有范围内都是相同的，并且不能被覆盖。因此，它们不能被 <code>=</code> 重新定义。此限制允许它用于模式匹配。
<code>True</code> 和 <code>False</code> 可以用于模式匹配的原因是因为它们是常量。
此外，常量总是指向不可变对象。诸如 <code>Str!</code> 之类的类型不能是常量。
所有内置类型都是常量，因为它们应该在编译时确定。可以生成非常量的类型，但不能用于指定类型，只能像简单记录一样使用。相反，类型是其内容在编译时确定的记录。</p>
<h2 id="变量名称标识符符号"><a class="header" href="#变量名称标识符符号">变量、名称、标识符、符号</a></h2>
<p>让我们理清一些与 Erg 中的变量相关的术语。</p>
<p>变量是一种为对象赋予名称以便可以重用(或指向该名称)的机制。
标识符是指定变量的语法元素。
符号是表示名称的语法元素、记号。</p>
<p>只有非符号字符是符号，符号不称为符号，尽管它们可以作为运算符的标识符。
例如，<code>x</code> 是一个标识符和一个符号。 <code>x.y</code> 也是一个标识符，但它不是一个符号。 <code>x</code> 和 <code>y</code> 是符号。
即使 <code>x</code> 没有绑定到任何对象，<code>x</code> 仍然是一个符号和一个标识符，但它不会被称为变量。
<code>x.y</code> 形式的标识符称为字段访问器。
<code>x[y]</code> 形式的标识符称为下标访问器。</p>
<p>变量和标识符之间的区别在于，如果我们在 Erg 的语法理论意义上谈论变量，则两者实际上是相同的。
在 C 中，类型和函数不能分配给变量； int 和 main 是标识符，而不是变量(严格来说可以赋值，但有限制)。
然而，在Erg语中，&quot;一切都是对象&quot;。不仅函数和类型，甚至运算符都可以分配给变量。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="所有权制度"><a class="header" href="#所有权制度">所有权制度</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/18_ownership.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/18_ownership.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>由于 Erg 是一种使用 Python 作为宿主语言的语言，因此内存管理的方法取决于 Python 的实现。
但语义上 Erg 的内存管理与 Python 的不同。 一个显着的区别在于所有权制度和禁止循环引用。</p>
<h2 id="所有权"><a class="header" href="#所有权">所有权</a></h2>
<p>Erg 有一个受 Rust 启发的所有权系统。
Rust 的所有权系统通常被认为是深奥的，但 Erg 的所有权系统被简化为直观。
在 Erg 中，<strong>mutable objects</strong> 是拥有的，并且在所有权丢失后无法引用。</p>
<pre><code class="language-python">v = [1, 2, 3].into [Int; !3]

push! vec, x =
    vec.push!(x)
    vec

# v ([1, 2, 3])的内容归w所有
w = push! v, 4
print! v # 错误：v 被移动了
print!w # [1, 2, 3, 4]
</code></pre>
<p>例如，当一个对象被传递给一个子程序时，就会发生所有权转移。
如果您想在赠送后仍然拥有所有权，则需要克隆、冻结或借用。
但是，如后所述，可以借用的情况有限。</p>
<h2 id="复制"><a class="header" href="#复制">复制</a></h2>
<p>复制一个对象并转移其所有权。 它通过将 <code>.clone</code> 方法应用于实际参数来做到这一点。
复制的对象与原始对象完全相同，但相互独立，不受更改影响。</p>
<p>复制相当于 Python 的深拷贝，由于它完全重新创建相同的对象，因此计算和内存成本通常高于冻结和借用。
需要复制对象的子例程被称为&quot;参数消耗&quot;子例程。</p>
<pre><code class="language-python">capitalize s: Str!=
    s. capitalize!()
    s

s1 = !&quot;hello&quot;
s2 = capitalize s1.clone()
log s2, s1 # !&quot;HELLO hello&quot;
</code></pre>
<h2 id="冻结"><a class="header" href="#冻结">冻结</a></h2>
<p>我们利用了不可变对象可以从多个位置引用的事实，并将可变对象转换为不可变对象。
这称为冻结。 例如，在从可变数组创建迭代器时会使用冻结。
由于您不能直接从可变数组创建迭代器，请将其转换为不可变数组。
如果您不想破坏数组，请使用 <a href="./type/18_mut.html"><code>.freeze_map</code> 方法</a>。</p>
<pre><code class="language-python"># 计算迭代器产生的值的总和
sum|T &lt;: Add + HasUnit| i: Iterator T = ...

x = [1, 2, 3].into [Int; !3]
x.push!(4)
i = x.iter() # 类型错误：[Int; !4] 没有方法 `iter`
y = x.freeze()
i = y.iter()
assert sum(i) == 10
y # y 仍然可以被触摸
</code></pre>
<h2 id="借"><a class="header" href="#借">借</a></h2>
<p>借用比复制或冻结便宜。
可以在以下简单情况下进行借款：</p>
<pre><code class="language-python">peek_str ref(s: Str!) =
    log s

s = !&quot;hello&quot;
peek_str s
</code></pre>
<p>借来的值称为原始对象的 <strong>reference</strong>。
您可以&quot;转租&quot;对另一个子例程的引用，但您不能使用它，因为您只是借用它。</p>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # 由于日志函数只借用参数，所以可以转租
    log s
    # 错误，因为丢弃函数消耗了参数
    discard s # OwnershipError: 不能消费借来的值
    # 提示：使用 `clone` 方法
</code></pre>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # 这也不好(=消耗右边)
     x = s # OwnershipError: 不能消费借来的值
    x
</code></pre>
<p>Erg 的引用比 Rust 的更严格。 引用是语言中的一等对象，但不能显式创建，它们只能指定为通过 <code>ref</code>/<code>ref!</code> 传递的参数。
这意味着您不能将引用填充到数组中或创建将引用作为属性的类。</p>
<p>但是，这样的限制是语言中的自然规范，一开始就没有引用，而且它们并没有那么不方便。</p>
<h2 id="循环引用"><a class="header" href="#循环引用">循环引用</a></h2>
<p>Erg 旨在防止无意的内存泄漏，如果内存检查器检测到循环引用，则会发出错误。 在大多数情况下，这个错误可以通过弱引用 <code>Weak</code> 来解决。 但是，由于无法生成循环图等具有循环结构的对象，因此我们计划实现一个 API，可以将循环引用作为不安全操作生成。</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可见性"><a class="header" href="#可见性">可见性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/19_visibility.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/19_visibility.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg 变量具有 <strong>visibility</strong> 的概念。
到目前为止，我们看到的所有变量都称为 <strong>private variables</strong>。 这是一个外部不可见的变量。
例如，<code>foo</code> 模块中定义的私有变量不能被另一个模块引用。</p>
<pre><code class="language-python"># foo.er
x = &quot;this is an invisible variable&quot;
</code></pre>
<pre><code class="language-python">#bar.er
foo = import &quot;foo&quot;
foo.x # AttributeError: 模块 'foo' 没有属性 'x' ('x' 是私有的)
</code></pre>
<p>另一方面，也有__public variables__，可以从外部引用。
公共变量用<code>.</code>定义。</p>
<pre><code class="language-python"># foo.er
.x = &quot;this is a visible variable&quot;
</code></pre>
<pre><code class="language-python">#bar.er
foo = import &quot;foo&quot;
assert foo.x == &quot;this is a visible variable&quot;
</code></pre>
<p>您不需要向私有变量添加任何内容，但您也可以添加 <code>::</code> 或 <code>self::</code>(用于类型等的<code>Self::</code>)以表明它们是私有的。 增加。 如果它是一个模块，它也可以是 <code>module::</code></p>
<pre><code class="language-python">::x = &quot;this is an invisible variable&quot;
assert ::x == x
assert self ::x == ::x
assert module::x == ::x
</code></pre>
<p>In the context of purely sequential execution, private variables are almost synonymous with local variables. It can be referenced from the inner scope.</p>
<pre><code class="language-python">::x = &quot;this is a private variable&quot;
y =
    x + 1 # 完全是 module::x
</code></pre>
<p>通过使用<code>::</code>，可以区分作用域内同名的变量。
在左侧指定要引用的变量的范围。 为顶层指定 <code>module</code>。
如果未指定，则照常引用最里面的变量。</p>
<pre><code class="language-python">::x = 0
assert x == 0
y =
    ::x = 1
    assert x == 1
    z =
        ::x = 2
        assert ::x == 2
        assert z::x == 2
        assert y::x == 1
        assert module::x == 0
</code></pre>
<p>在匿名子程序作用域中，<code>self</code> 指定了它自己的作用域</p>
<pre><code class="language-python">x = 0
f = x -&gt;
    log module::x, self::x
f1# 0 1
</code></pre>
<p><code>::</code> 还负责访问私有实例属性。</p>
<pre><code class="language-python">x = 0
C = Class {x = Int}
C.
    # 顶级 x 被引用(警告使用 module::x)
    f1 self = x
    # 实例属性 x 被引用
    f2 self = self::x
</code></pre>
<h2 id="外部模块中的可见性"><a class="header" href="#外部模块中的可见性">外部模块中的可见性</a></h2>
<p>在一个模块中定义的类实际上可以定义来自外部模块的方法。</p>
<pre><code class="language-python"># foo.er
.Foo = Class()
</code></pre>
<pre><code class="language-python">#bar.er
{Foo; ...} = import &quot;foo&quot;

Foo::
    private self = pass
Foo.
    public self = self::private()

.f() =
    foo = Foo.new()
    foo.public()
    foo::private() # 属性错误
</code></pre>
<p>但是，这两种方法都只在该模块中可用。
外部定义的私有方法对 Foo 类的方法仅在定义模块内可见。
公共方法暴露在类之外，但不在模块之外。</p>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;

foo = Foo.new()
foo.public() # 属性错误：&quot;Foo&quot;没有属性&quot;public&quot;(&quot;public&quot;在模块&quot;bar&quot;中定义)
</code></pre>
<p>此外，方法不能在要重新导出的类型中定义。
这是为了避免混淆方法是否找到，具体取决于导入方法的模块。</p>
<pre><code class="language-python">#bar.er
{.Foo; ...} = import &quot;foo&quot;

.Foo::
    private self = pass # 错误
Foo.
    public self = self::private() # 错误
</code></pre>
<p>如果你想做这样的事情，定义一个 <a href="./type/07_patch.html">patch</a>。</p>
<pre><code class="language-python">#bar.er
{Foo; ...} = import &quot;foo&quot;

FooImpl = Patch Foo
FooImpl :=:
    private self = pass
Foo Impl.
    public self = self::private()
</code></pre>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;
{FooImpl; ...} = import &quot;bar&quot;

foo = Foo.new()
foo.public()
</code></pre>
<h2 id="受限公共变量"><a class="header" href="#受限公共变量">受限公共变量</a></h2>
<p>可变可见性不限于完全公共/私有。
您也可以有限制地发布。</p>
<pre><code class="language-python"># foo.er
.record = {
    .a = {
        .(.record)x = 0
        .(module)y = 0
        .z = 0
    }
    _ = .a.x # OK
    _ = .a.y # OK
    _ = .a.z # OK
}

_ = .record.a.x # 可见性错误
_ = .record.a.y # OK
_ = .record.a.z # OK
</code></pre>
<pre><code class="language-python">foo = import &quot;foo&quot;
_ = foo.record.a.x # 可见性错误
_ = foo.record.a.y # 可见性错误
_ = foo.record.a.z # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名约定"><a class="header" href="#命名约定">命名约定</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/20_naming_rule.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/20_naming_rule.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>如果要将变量用作常量表达式，请确保它以大写字母开头。 两个或多个字母可能是小写的。</p>
<pre><code class="language-python">i: Option Type = Int
match i:
    t: Type -&gt; log &quot;type&quot;
    None -&gt; log &quot;None&quot;
</code></pre>
<p>具有副作用的对象总是以 <code>!</code> 结尾。 程序和程序方法，以及可变类型。
然而，<code>Proc</code> 类型本身是不可变的。</p>
<pre><code class="language-python"># Callable == Func or Proc
c: Callable = print!
match c:
    p! -&gt; log &quot;proc&quot; # `: Proc` 可以省略，因为它是不言自明的
    f -&gt; log &quot;func&quot;
</code></pre>
<p>如果您想向外界公开一个属性，请在开头使用 <code>.</code> 定义它。 如果你不把<code>.</code>放在开头，它将是私有的。 为避免混淆，它们不能在同一范围内共存。</p>
<pre><code class="language-python">o = {x = 1; .x = 2} # 语法错误：同名的私有变量和公共变量不能共存
</code></pre>
<h2 id="文字标识符"><a class="header" href="#文字标识符">文字标识符</a></h2>
<p>可以通过将字符串括在单引号 ('') 中来规避上述规则。 也就是说，程序对象也可以在没有 <code>!</code> 的情况下分配。 但是，在这种情况下，即使该值是常量表达式，也不会被视为常量。
像这样用单引号括起来的字符串称为文字标识符。
这在调用Python等其他语言的API(FFI)时使用。</p>
<pre><code class="language-python">bar! = pyimport(&quot;foo&quot;).'bar'
</code></pre>
<p>在 Erg 中也有效的标识符不需要用 '' 括起来。</p>
<p>此外，文字标识符可以包含符号和空格，因此通常不能用作标识符的字符串可以用作标识符。</p>
<pre><code class="language-python">'∂/∂t' y
'test 1: pass x to y'()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="匿名函数"><a class="header" href="#匿名函数">匿名函数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/21_lambda.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/21_lambda.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>匿名函数是一种无需命名即可动态创建函数对象的语法。</p>
<pre><code class="language-python"># `-&gt;` 是匿名函数操作符
# 同 `f x, y = x + y`
f = (x, y) -&gt; x + y
# same as `g(x, y: Int): Int = x + y`
g = (x, y: Int): Int -&gt; x + y
</code></pre>
<p>如果只有一个参数，您可以省略 <code>()</code>。</p>
<pre><code class="language-python">assert [1, 2, 3].map_collect(i -&gt; i + 1) == [2, 3, 4]
assert ((i, j) -&gt; [i, j])(1, 2) == [1, 2]
</code></pre>
<p>在下面的情况下，它是 <code>0..9, (i -&gt; ...)</code> 而不是 <code>(0..9, i) -&gt; ...</code>
<code>-&gt;</code> 在左侧只接受一个参数。 多个参数作为单个元组接收</p>
<pre><code class="language-python">for 0..9, i: Int -&gt;
    ...
</code></pre>
<p>在匿名函数中，由于空格，解析存在差异</p>
<pre><code class="language-python"># 在这种情况下，解释为 `T(() -&gt; Int)`
i: T() -&gt; Int
# 在这种情况下，它被解释为 (U()) -&gt; Int
k: U() -&gt; Int
</code></pre>
<p>匿名函数可以不带参数使用。</p>
<pre><code class="language-python"># `=&gt;` 是一个匿名过程操作符
p! = () =&gt; print! # `p!` 被调用
# `() -&gt;`, `() =&gt;` 有语法糖 `do`, `do!`
# p! = do! print! &quot;`p!` 被调用
p!() # `p!` 被调用
</code></pre>
<p>无参数函数可用于延迟初始化</p>
<pre><code class="language-python">time = import &quot;time&quot;
date = import &quot;datetime&quot;
now = if! True:
    do!:
        time. sleep! 1000
        date.now!()
    do date.new(&quot;1970&quot;, &quot;1&quot;, &quot;1&quot;, &quot;00&quot;, &quot;00&quot;)
</code></pre>
<p>您还可以键入和模式匹配。 正因为如此，<code>match</code> 函数大多是借助匿名函数的力量来实现的。
作为 <code>match</code> 函数的参数给出的匿名函数从顶部开始按顺序尝试。 因此，您应该在顶部描述特殊情况，在底部描述更一般的情况。 如果你弄错了顺序，编译器会发出警告(如果可能的话)</p>
<pre><code class="language-python">n = (Complex or Ratio or Int).sample!()
i = matchn:
    PI -&gt; PI # 如果等于常数 PI
    For (i: 1..10) -&gt; i # 整数从 1 到 10
    (i: Int) -&gt; i # Int
    (c: Complex) -&gt; c.real() # 对于复杂。 Int &lt; Complex，但可以回退
    _ -&gt; panic &quot;cannot convert to Int&quot; # 如果以上都不适用。 match 必须涵盖所有模式
</code></pre>
<p>错误处理通常也使用 <code>?</code> 或 <code>match</code> 完成。</p>
<pre><code class="language-python">res: ParseResult Int
matchres:
    i: Int -&gt; i
    err: Error -&gt; panic err.msg

res2: Result Int, Error
match res2:
    ok: Not Error -&gt; log Type of ok
    err: Error -&gt; panic err.msg
</code></pre>
<h2 id="匿名多相关系数"><a class="header" href="#匿名多相关系数">匿名多相关系数</a></h2>
<pre><code class="language-python"># 与此相同 id|T|x：T = x
id = |T| x: T -&gt; x
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子程序签名"><a class="header" href="#子程序签名">子程序签名</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/22_subroutine.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/22_subroutine.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<pre><code class="language-python">some_func(x: T, y: U) -&gt; V
some_func: (T, U) -&gt; V
</code></pre>
<h2 id="过程"><a class="header" href="#过程">过程</a></h2>
<pre><code class="language-python">some_proc!(x: T, y: U) =&gt; V
some_proc!: (T, U) =&gt; V
</code></pre>
<h2 id="函数方法"><a class="header" href="#函数方法">函数方法</a></h2>
<p>方法类型不能用<code>Self</code>在外部指定</p>
<pre><code class="language-python">.some_method(self, x: T, y: U) =&gt; ()
# (Self, T, U) =&gt; () 拥有 self 的所有权
.some_method: (Ref(Self), T, U) =&gt; ()
</code></pre>
<h2 id="过程方法依赖"><a class="header" href="#过程方法依赖">过程方法(依赖)</a></h2>
<p>在下文中，假设类型 <code>T!</code> 采用类型参数 <code>N: Nat</code>。 要在外部指定它，请使用类型变量</p>
<pre><code class="language-python">T!: Nat -&gt; Type
# ~&gt; 表示应用前后类型参数的状态(此时self必须是变量引用)
T!(N).some_method!: (Ref!(T! N ~&gt; N+X), X: Nat) =&gt; ()
</code></pre>
<p>注意，<code>.some_method</code> 的类型是 <code>| N，X：Nat| (Ref!(T! N ~&gt; N+X), {X}) =&gt; ()</code>。
对于没有 <code>ref!</code> 的方法，即在应用后被剥夺所有权，不能使用类型参数转换(<code>~&gt;</code>)。</p>
<p>如果取得所有权，则如下所示。</p>
<pre><code class="language-python"># 如果不使用N，可以用_省略。
# .some_method!: |N, X: Nat| (T!(N), {X}) =&gt; T!(N+X)
.some_method!|N, X: Nat| (self: T!(N), X: Nat) =&gt; T!(N+X)
</code></pre>
<h2 id="运算符-1"><a class="header" href="#运算符-1">运算符</a></h2>
<p>可以通过用 ` 括起来将其定义为普通函数。</p>
<p>中性字母运算符，例如 <code>and</code> 和 <code>or</code> 可以通过用 ` 括起来定义为中性运算符。</p>
<pre><code class="language-python">and(x, y, z) = x and y and z
`_+_`(x: Foo, y: Foo) = x.a + y.a
`-_`(x: Foo) = Foo.new(-x.a)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="关闭"><a class="header" href="#关闭">关闭</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/23_closure.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/23_closure.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg 子例程有一个称为&quot;闭包&quot;的功能，可以捕获外部变量。</p>
<pre><code class="language-python">outer = 1
f x = outer + x
assert f(1) == 2
</code></pre>
<p>与不可变对象一样，可变对象也可以被捕获。</p>
<pre><code class="language-python">sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45

p!x=
    sum.add!x
p!(1)
assert sum == 46
</code></pre>
<p>但是请注意，函数不能捕获可变对象。
如果可以在函数中引用可变对象，则可以编写如下代码。</p>
<pre><code class="language-python"># !!! 这段代码实际上给出了一个错误！！！
i = !0
f x = i + x
assert f 1 == 1
i.add! 1
assert f 1 == 2
</code></pre>
<p>该函数应该为相同的参数返回相同的值，但假设被打破了。
请注意，<code>i</code> 仅在调用时进行评估。</p>
<p>如果您想在定义函数时获取可变对象的内容，请调用<code>.clone</code></p>
<pre><code class="language-python">i = !0
immut_i = i.clone().freeze()
fx = immut_i + x
assert f 1 == 1
i.add! 1
assert f 1 == 1
</code></pre>
<h2 id="avoid-mutable-state-functional-programming"><a class="header" href="#avoid-mutable-state-functional-programming">avoid mutable state, functional programming</a></h2>
<pre><code class="language-python"># Erg
sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45
</code></pre>
<p>上面的等效程序可以用 Python 编写如下：</p>
<pre><code class="language-python"># Python
sum = 0
for i in range(1, 10):
    sum += i
assert sum == 45
</code></pre>
<p>但是，Erg 建议使用更简单的表示法。
与其使用子例程和可变对象来传递状态，不如使用一种使用函数来定位状态的风格。这称为函数式编程</p>
<pre><code class="language-python"># 功能风格
sum = (1..10).sum()
assert sum == 45
</code></pre>
<p>上面的代码给出了与之前完全相同的结果，但是您可以看到这个代码要简单得多。</p>
<p><code>fold</code> 函数可以用来做比 sum 更多的事情。
<code>fold</code> 是一个迭代器方法，它为每次迭代执行参数 <code>f</code>。
累加结果的计数器的初始值在 <code>init</code> 中指定，并在 <code>acc</code> 中累加。</p>
<pre><code class="language-python"># 从0开始，结果会
sum = (1..10).fold(init: 0, f: (acc, i) -&gt; acc + i)
assert sum == 45
</code></pre>
<p>Erg 被设计为对使用不可变对象进行编程的自然简洁描述。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">module</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/24_module.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/24_module.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg allows you to think of the file itself as a single record. This is called a module.</p>
<pre><code class="language-python:foo.er"># foo.er
.i = 1
</code></pre>
<pre><code class="language-python"># 定义 foo 模块与定义这条记录几乎相同
foo = {.i = 1}
</code></pre>
<pre><code class="language-python:bar.er">#bar.er
foo = import &quot;foo&quot;
print! foo # &lt;module 'foo'&gt;
assert foo.i == 1
</code></pre>
<p>由于模块类型也是记录类型，因此可以进行解构赋值</p>
<pre><code class="language-python">{sin; cos; ...} = import &quot;math&quot;
</code></pre>
<h2 id="模块可见性"><a class="header" href="#模块可见性">模块可见性</a></h2>
<pre><code class="language-console">└─┬ ./src
   ├─ lib.er
   ├─ foo.er
   ├─bar.er
   └─┬ bar
     ├─ baz.er
     └─ qux.er
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="目的"><a class="header" href="#目的">目的</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/25_object_system.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/25_object_system.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>可以分配给变量的所有数据。 <code>Object</code> 类的属性如下。</p>
<ul>
<li><code>.__repr__</code>：返回对象的(非丰富)字符串表示</li>
<li><code>.__sizeof__</code>：返回对象的大小(包括堆分配)</li>
<li><code>.__dir__</code>: 返回对象属性列表</li>
<li><code>.__hash__</code>：返回对象的哈希值</li>
<li><code>.__getattribute__</code>: 获取并返回对象的属性</li>
<li><code>.clone</code>：创建并返回一个对象的克隆(在内存中有一个独立的实体)</li>
<li><code>.copy</code>：返回对象的副本(指向内存中的同一事物)</li>
</ul>
<h2 id="记录"><a class="header" href="#记录">记录</a></h2>
<p>由记录文字(<code>{attr = value; ...}</code>)生成的对象。
这个对象有基本的方法，比如<code>.clone</code>和<code>.__sizeof__</code>。</p>
<pre><code class="language-python">obj = {.x = 1}
assert obj.x == 1

obj2 = {...x; .y = 2}
assert obj2.x == 1 and obj2.y == 2
</code></pre>
<h2 id="属性"><a class="header" href="#属性">属性</a></h2>
<p>与对象关联的对象。 特别是，将 self (<code>self</code>) 作为其隐式第一个参数的子例程属性称为方法。</p>
<pre><code class="language-python"># 请注意，private_attr 中没有`.`
record = {.public_attr = j; private_attr = 2; .method = self -&gt; self.i + 1}
record. public_attr == 2
record.private_attr # AttributeError: private_attr 是私有的
assert record.method() == 3
</code></pre>
<h2 id="元素"><a class="header" href="#元素">元素</a></h2>
<p>属于特定类型的对象(例如，&quot;1&quot;是&quot;Int&quot;类型的元素)。所有对象至少是<code>{=}</code>类型的元素。
类的元素有时称为实例。</p>
<h2 id="子程序"><a class="header" href="#子程序">子程序</a></h2>
<p>表示作为函数或过程(包括方法)实例的对象。代表子程序的类是&quot;子程序&quot;。
实现 <code>.__call__</code> 的对象通常称为 <code>Callable</code>。</p>
<h2 id="可调用"><a class="header" href="#可调用">可调用</a></h2>
<p>一个实现<code>.__call__</code>的对象。它也是 <code>Subroutine</code> 的超类。</p>
<h2 id="类型-2"><a class="header" href="#类型-2">类型</a></h2>
<p>定义需求属性并使对象通用化的对象。
主要有两种类型：多态类型和单态类型。典型的单态类型有<code>Int</code>、<code>Str</code>等，多态类型有<code>Option Int</code>、<code>[Int; 3]</code>等
此外，定义改变对象状态的方法的类型称为 Mutable 类型，需要在变量属性中添加 <code>!</code>(例如动态数组：<code>[T; !_]</code>)。</p>
<h2 id="班级"><a class="header" href="#班级">班级</a></h2>
<p>具有 <code>.__new__</code>、<code>.__init__</code> 方法等的类型。实现基于类的面向对象。</p>
<h2 id="功能-1"><a class="header" href="#功能-1">功能</a></h2>
<p>对外部变量(不包括静态变量)有读权限但对外部变量没有读/写权限的子程序。换句话说，它没有外部副作用。
Erg 函数的定义与 Python 的不同，因为它们不允许副作用。</p>
<h2 id="程序-1"><a class="header" href="#程序-1">程序</a></h2>
<p>它对外部变量具有读取和&quot;自我&quot;权限，对静态变量具有读/写权限，并允许使用所有子例程。它可能有外部副作用。</p>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>隐式将&quot;self&quot;作为第一个参数的子例程。它与简单的函数/过程是不同的类型。</p>
<h2 id="实体"><a class="header" href="#实体">实体</a></h2>
<p>不是子例程和类型的对象。
单态实体(<code>1</code>、<code>&quot;a&quot;</code> 等)也称为值对象，多态实体(<code>[1, 2, 3], {&quot;a&quot;: 1}</code>)也称为容器对象。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配可反驳"><a class="header" href="#模式匹配可反驳">模式匹配，可反驳</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/26_pattern_matching.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/26_pattern_matching.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<h2 id="erg-中可用的模式"><a class="header" href="#erg-中可用的模式">Erg 中可用的模式</a></h2>
<h3 id="变量模式"><a class="header" href="#变量模式">变量模式</a></h3>
<pre><code class="language-python"># 基本任务
i = 1
# 有类型
i: Int = 1
# 匿名类型
i: {1, 2, 3} = 2

# 功能
fn x = x + 1
# 等于
fn x: Add(Int) = x + 1
# (匿名)函数
fn = x -&gt; x + 1
fn: Int -&gt; Int = x -&gt; x + 1

# 高阶类型
a: [Int; 4] = [0, 1, 2, 3]
# or
a: Array Int, 4 = [0, 1, 2, 3]
</code></pre>
<h3 id="文字字面量"><a class="header" href="#文字字面量">文字字面量</a></h3>
<pre><code class="language-python"># 如果在编译时无法确定 `i` 为 1，则引发 TypeError。
# 省略 `_: {1} = i`
1 = i

# 简单的模式匹配
match x:
    1 -&gt; &quot;1&quot;
    2 -&gt; &quot;2&quot;
    _ -&gt; &quot;other&quot;

# 斐波那契函数
fib0 = 0
fib1 = 1
fibn: Nat = fibn-1 + fibn-2
</code></pre>
<h3 id="常量模式"><a class="header" href="#常量模式">常量模式</a></h3>
<pre><code class="language-python">cond=False
match! cond:
    True =&gt; print! &quot;cond is True&quot;
    _ =&gt; print! &quot;cond is False&quot;

PI = 3.141592653589793
E = 2.718281828459045
num = PI
name = match num:
    PI -&gt; &quot;pi&quot;
    E -&gt; &quot;e&quot;
    _ -&gt; &quot;unnamed&quot;
</code></pre>
<h3 id="筛子图案"><a class="header" href="#筛子图案">筛子图案</a></h3>
<pre><code class="language-python"># 这两个是一样的
Array(T, N: {N | N &gt;= 3})
Array(T, N | N &gt;= 3)

f M, N | M &gt;= 0, N &gt;= 1 = ...
f(1, 0) # 类型错误：N(第二个参数)必须为 1 或更多
</code></pre>
<h3 id="丢弃通配符模式"><a class="header" href="#丢弃通配符模式">丢弃(通配符)模式</a></h3>
<pre><code class="language-python">_ = 1
_: Int = 1
zero_ = 0
right(_, r) = r
</code></pre>
<h3 id="可变长度模式"><a class="header" href="#可变长度模式">可变长度模式</a></h3>
<p>它与稍后描述的元组/数组/记录模式结合使用。</p>
<pre><code class="language-python">[i,...j] = [1, 2, 3, 4]
assert j == [2, 3, 4]
first|T|(fst: T, ...rest: T) = fst
assert first(1, 2, 3) == 1
</code></pre>
<h3 id="元组模式"><a class="header" href="#元组模式">元组模式</a></h3>
<pre><code class="language-python">(i, j) = (1, 2)
((k, l), _) = ((1, 2), (3, 4))
# 如果不嵌套，() 可以省略(1, 2 被视为(1, 2))
m, n = 1, 2

f(x, y) = ...
</code></pre>
<h3 id="数组模式"><a class="header" href="#数组模式">数组模式</a></h3>
<pre><code class="language-python">[i, j] = [1, 2]
[[k, l], _] = [[1, 2], [3, 4]]

length[] = 0
length[_, ...rest] = 1 + lengthrest
</code></pre>
<h4 id="record-模式"><a class="header" href="#record-模式">record 模式</a></h4>
<pre><code class="language-python">record = {i = 1; j = 2; k = 3}
{j; ...} = record # i, k 将被释放

{sin; cos; tan; ...} = import &quot;math&quot;
{*} = import &quot;math&quot; # import all

person = {name = &quot;John Smith&quot;; age = 20}
age = match person:
    {name = &quot;Alice&quot;; _} -&gt; 7
    {_; age} -&gt; age

f {x: Int; y: Int} = ...
</code></pre>
<h3 id="数据类模式"><a class="header" href="#数据类模式">数据类模式</a></h3>
<pre><code class="language-python">Point = Inherit {x = Int; y = Int}
p = Point::{x = 1; y = 2}
Point::{x; y} = p

Nil T = Class Impl := Phantom T
Cons T = Inherit {head = T; rest = List T}
List T = Enum Nil(T), Cons(T)
List T.
    first self =
        match self:
            Cons::{head; ...} -&gt; x
            _ -&gt; ...
    second self =
        match self:
            Cons::{rest=Cons::{head; ...}; ...} -&gt; head
            _ -&gt; ...
</code></pre>
<h3 id="枚举模式"><a class="header" href="#枚举模式">枚举模式</a></h3>
<ul>
<li>其实只是枚举类型</li>
</ul>
<pre><code class="language-python">match x:
    i: {1, 2} -&gt; &quot;one or two: {i}&quot;
    _ -&gt; &quot;other&quot;
</code></pre>
<h3 id="range-模式"><a class="header" href="#range-模式">Range 模式</a></h3>
<ul>
<li>实际上，它只是一个区间类型。</li>
</ul>
<pre><code class="language-python"># 0 &lt; i &lt; 1
i: 0&lt;..&lt;1 = 0.5
# 1 &lt; j &lt;= 2
_: {[I, J] | I, J: 1&lt;..2} = [1, 2]
# 1 &lt;= i &lt;= 5
match i
    i: 1..5 -&gt; ...
</code></pre>
<h3 id="不是模式的东西不能被模式化的东西"><a class="header" href="#不是模式的东西不能被模式化的东西">不是模式的东西，不能被模式化的东西</a></h3>
<p>模式是可以唯一指定的东西。 在这方面，模式匹配不同于普通的条件分支。</p>
<p>条件规格不是唯一的。 例如，要检查数字 <code>n</code> 是否为偶数，正统是 <code>n % 2 == 0</code>，但也可以写成 <code>(n / 2).round() == n / 2</code>。
非唯一形式无论是正常工作还是等效于另一个条件都不是微不足道的。</p>
<h4 id="set-1"><a class="header" href="#set-1">Set</a></h4>
<p>没有固定的模式。 因为集合没有办法唯一地检索元素。
您可以通过迭代器检索它们，但不能保证顺序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comprehension"><a class="header" href="#comprehension">Comprehension</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/27_comprehension.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/27_comprehension.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Array 和 <code>[expr | (name &lt;- iterable)+ (predicate)*]</code>,
set 和 <code>{expr | (name &lt;- iterable)+ (predicate)*}</code>,
你可以创建一个字典 <code>{key: value | (name &lt;- iterable)+ (predicate)*}</code>.</p>
<p>由<code>|</code>分隔的子句的第一部分称为布局子句(位置子句)，第二部分称为绑定子句(绑定子句)，第三部分称为保护子句(条件子句)。
保护子句可以省略，但绑定子句不能省略，保护子句不能在绑定子句之前。</p>
<p>理解示例</p>
<pre><code class="language-python"># 布局子句是 i
# 绑定子句是 i &lt;- [0, 1, 2]
assert [i | i &lt;- [0, 1, 2]] == [0, 1, 2]

# 布局子句是 i / 2
# 绑定子句是 i &lt;- 0..2
assert [i/2 | i &lt;- 0..2] == [0.0, 0.5, 1.0]

# 布局子句是 (i, j)
# 绑定子句 i &lt;- 0..2, j &lt;- 0..2
# 保护子句是 (i + j) % 2 == 0
assert [(i, j) | i &lt;- 0..2; j &lt;- 0..2; (i + j) % 2 == 0] == [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)]

assert {i % 2 | i &lt;- 0..9} == {0, 1}
assert {k: v | k &lt;- [&quot;a&quot;, &quot;b&quot;]; v &lt;- [1, 2]} == {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<p>Erg推导式受到 Haskell 的启发，但有一些不同。
对于 Haskell 列表推导，变量的顺序会对结果产生影响，但在 Erg 中这并不重要。</p>
<pre><code class="language-haskell">-- Haskell
[(i, j) | i &lt;- [1..3], j &lt;- [3..5]] == [(1,3),(1,4),(1,5),(2 ,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
[(i, j) | j &lt;- [3..5], i &lt;- [1..3]] == [(1,3),(2,3),(3,3),(1 ,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>
<pre><code class="language-python"># Erg
assert [(i, j) | i &lt;- 1..&lt;3; j &lt;- 3..&lt;5] == [(i, j) | j &lt;- 3..&lt;5; i &lt;- 1.. &lt;3]
</code></pre>
<p>该规范与 Python 的规范相同。</p>
<pre><code class="language-python"># Python
assert [(i, j) for i in range(1, 3) for j in range(3, 5)] == [(i, j) for j in range(3, 5) for i in range(1, 3)]
</code></pre>
<h2 id="筛子类型"><a class="header" href="#筛子类型">筛子类型</a></h2>
<p>与推导类似的是筛类型。 筛子类型是以<code>{Name: Type | Predicate}</code>创建的(枚举类型)
sieve类型的情况下，只能指定一个Name，不能指定布局(但是如果是tuple类型可以处理多个值)，Predicate可以在编译时计算，即 ，只能指定一个常量表达式。</p>
<pre><code class="language-python">Nat = {I: Int | I &gt;= 0}
# 如果谓词表达式只有and，可以替换为:
# Nat2D = {(I, J): (Int, Int) | I &gt;= 0; J &gt;= 0}
Nat2D = {(I, J): (Int, Int) | I &gt;= 0 and J &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="传播赋值"><a class="header" href="#传播赋值">传播赋值</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/28_spread_syntax.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/28_spread_syntax.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>在分解赋值中，将 <code>...</code> 放在变量前面会将所有剩余元素展开到该变量中。 这称为扩展赋值。</p>
<pre><code class="language-python">[x,...y] = [1, 2, 3]
assert x == 1
assert y == [2, 3]
x, ...y = (1, 2, 3)
assert x == 1
assert y == (2, 3)
</code></pre>
<h2 id="提取赋值"><a class="header" href="#提取赋值">提取赋值</a></h2>
<p>如果在 <code>...</code> 之后没有写入任何内容，则忽略并分配剩余的元素。 这种类型的扩展赋值具体称为抽取赋值。
提取分配是一种方便的语法，用于本地化模块或记录中的特定属性。</p>
<pre><code class="language-python">{sin; cos; tan; ..} = import &quot;math&quot;
</code></pre>
<p>After that, you can use <code>sin, cos, tan</code> locally.</p>
<p>You can do the same with records.</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x; y; ...} = record
</code></pre>
<p>If you want to expand all, use <code>{*} = record</code>. It is <code>open</code> in OCaml.</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{*} = records
assert x == 1 and y == 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="装饰器修饰符"><a class="header" href="#装饰器修饰符">装饰器(修饰符)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/29_decorator.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/29_decorator.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>装饰器用于向类型或函数添加或演示特定状态或行为。
装饰器的语法如下。</p>
<pre><code class="language-python">@deco
X=...
</code></pre>
<p>你可以有多个装饰器，只要它们不冲突。</p>
<p>装饰器不是一个特殊的对象，它只是一个单参数函数。 装饰器等价于下面的伪代码。</p>
<pre><code class="language-python">X=...
X = deco(X)
</code></pre>
<p>Erg 不允许重新分配变量，因此上面的代码不起作用。
对于简单的变量，它与<code>X = deco(...)</code> 相同，但对于即时块和子例程，你不能这样做，所以你需要一个装饰器。</p>
<pre><code class="language-python">@deco
f x =
    y = ...
    x + y

# 还可以防止代码变成水平的
@LongNameDeco1
@LongNameDeco2
C = Class...
</code></pre>
<p>下面是一些常用的内置装饰器。</p>
<h2 id="可继承"><a class="header" href="#可继承">可继承</a></h2>
<p>指示定义类型是可继承的类。 如果为参数 <code>scope</code> 指定 <code>&quot;public&quot;</code>，甚至可以继承外部模块的类。 默认情况下它是<code>&quot;private&quot;</code>，不能被外部继承。</p>
<h2 id="最后"><a class="header" href="#最后">最后</a></h2>
<p>使该方法不可覆盖。 将它添加到类中使其成为不可继承的类，但由于它是默认值，因此没有意义。</p>
<h2 id="覆盖-1"><a class="header" href="#覆盖-1">覆盖</a></h2>
<p>覆盖属性时使用。 默认情况下，如果您尝试定义与基类相同的属性，Erg 将抛出错误。</p>
<h2 id="实现"><a class="header" href="#实现">实现</a></h2>
<p>表示参数 trait 已实现。</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
Sub = Trait {
    .`_-_` = Self.(Self) -&gt; Self
}

C = Class({i = Int}, Impl := Add and Sub)
C.
    @Impl Add
    `_+_` self, other = C.new {i = self::i + other::i}
    @Impl Sub
    `_-_` self, other = C.new {i = self::i - other::}
</code></pre>
<h2 id="附"><a class="header" href="#附">附</a></h2>
<p>指定默认情况下随 trait 附带的附件补丁。
这允许您重现与 Rust 特征相同的行为。</p>
<pre><code class="language-python"># foo.er
Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
@Attach AddForInt, AddForOdd
ClosedAdd = Subsume Add(Self)

AddForInt = Patch(Int, Impl := ClosedAdd)
AddForInt.AddO = Int
AddForOdd = Patch(Odd, Impl := ClosedAdd)
AddForOdd.AddO = Even
</code></pre>
<p>当从其他模块导入特征时，这将自动应用附件补丁。</p>
<pre><code class="language-Python"># 本来应该同时导入IntIsBinAdd和OddIsBinAdd，但是如果是附件补丁可以省略
{BinAdd; ...} = import &quot;foo&quot;

assert Int. AddO == Int
assert Odd.AddO == Even
</code></pre>
<p>在内部，它只是使用 trait 的 .attach 方法附加的。 可以使用 trait 的 <code>.detach</code> 方法消除冲突。</p>
<pre><code class="language-python">@Attach X
T = Trait...
assert X in T. attaches
U = T.detach(X).attach(Y)
assert X not in U. attaches
assert Y in U. attaches
</code></pre>
<h2 id="已弃用"><a class="header" href="#已弃用">已弃用</a></h2>
<p>指示变量规范已过时且不推荐使用。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<p>表示这是一个测试子例程。 测试子程序使用 <code>erg test</code> 命令运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理系统"><a class="header" href="#错误处理系统">错误处理系统</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/30_error_handling.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/30_error_handling.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>主要使用Result类型。
在 Erg 中，如果您丢弃 Error 类型的对象(顶层不支持)，则会发生错误。</p>
<h2 id="异常与-python-互操作"><a class="header" href="#异常与-python-互操作">异常，与 Python 互操作</a></h2>
<p>Erg 没有异常机制(Exception)。 导入 Python 函数时</p>
<ul>
<li>将返回值设置为 <code>T 或 Error</code> 类型</li>
<li><code>T or Panic</code> 类型(可能导致运行时错误)</li>
</ul>
<p>有两个选项，<code>pyimport</code> 默认为后者。 如果要作为前者导入，请使用
在 <code>pyimport</code> <code>exception_type</code> 中指定 <code>Error</code> (<code>exception_type: {Error, Panic}</code>)。</p>
<h2 id="异常和结果类型"><a class="header" href="#异常和结果类型">异常和结果类型</a></h2>
<p><code>Result</code> 类型表示可能是错误的值。 <code>Result</code> 的错误处理在几个方面优于异常机制。
首先，从类型定义中可以看出子程序可能会报错，实际使用时也很明显。</p>
<pre><code class="language-python"># Python
try:
    x = foo().bar()
    y = baz()
    qux()
except e:
    print(e)
</code></pre>
<p>在上面的示例中，仅凭此代码无法判断哪个函数引发了异常。 即使回到函数定义，也很难判断函数是否抛出异常。</p>
<pre><code class="language-python"># Erg
try!:
    do!:
        x = foo!()?.bar()
        y = baz!()
        qux!()?
    e =&gt;
        print! e
</code></pre>
<p>另一方面，在这个例子中，我们可以看到 <code>foo!</code> 和 <code>qux!</code> 会引发错误。
确切地说，<code>y</code> 也可能是 <code>Result</code> 类型，但您最终必须处理它才能使用里面的值。</p>
<p>使用 <code>Result</code> 类型的好处不止于此。 <code>Result</code> 类型也是线程安全的。 这意味着错误信息可以(轻松)在并行执行之间传递。</p>
<h2 id="语境"><a class="header" href="#语境">语境</a></h2>
<p>由于 <code>Error</code>/<code>Result</code> 类型本身不会产生副作用，不像异常，它不能有发送位置(Context)等信息，但是如果使用 <code>.context</code> 方法，可以将信息放在 <code>错误</code>对象。 可以添加。 <code>.context</code> 方法是一种使用 <code>Error</code> 对象本身并创建新的 <code>Error</code> 对象的方法。 它们是可链接的，并且可以包含多个上下文。</p>
<pre><code class="language-python">f() =
    todo() \
        .context &quot;to be implemented in ver 1.2&quot; \
        .context &quot;and more hints ...&quot;

f()
# Error: not implemented yet
# hint: to be implemented in ver 1.2
# hint: and more hints ...
</code></pre>
<p>请注意，诸如 <code>.msg</code> 和 <code>.kind</code> 之类的 <code>Error</code> 属性不是次要的，因此它们不是上下文，并且不能像最初创建时那样被覆盖。</p>
<h2 id="堆栈跟踪"><a class="header" href="#堆栈跟踪">堆栈跟踪</a></h2>
<p><code>Result</code> 类型由于其方便性在其他语言中经常使用，但与异常机制相比，它的缺点是难以理解错误的来源。
因此，在 Erg 中，<code>Error</code> 对象具有名为 <code>.stack</code> 的属性，并再现了类似伪异常机制的堆栈跟踪。
<code>.stack</code> 是调用者对象的数组。 每次 Error 对象被<code>return</code>(包括通过<code>?</code>)时，它都会将它的调用子例程推送到<code>.stack</code>。
如果它是 <code>?</code>ed 或 <code>.unwrap</code>ed 在一个不可能 <code>return</code> 的上下文中，它会因为回溯而恐慌。</p>
<pre><code class="language-python">f x =
    ...
    y = foo.try_some(x)?
    ...

g x =
    y = f(x)?
    ...

i = g(1)?
# Traceback (most recent call first):
# ...
# Foo.try_some, line 10, file &quot;foo.er&quot;
# 10 | y = foo.try_some(x)?
# module::f, line 23, file &quot;foo.er&quot;
# 23 | y = f(x)?
# module::g, line 40, file &quot;foo.er&quot;
# 40 | i = g(1)?
# Error: ...
</code></pre>
<h2 id="恐慌"><a class="header" href="#恐慌">恐慌</a></h2>
<p>Erg 还有一种处理不可恢复错误的机制，称为 <strong>panicing</strong>。
不可恢复的错误是由外部因素引起的错误，例如软件/硬件故障、严重到无法继续执行代码的错误或程序员未预料到的错误。 等如果发生这种情况，程序将立即终止，因为程序员的努力无法恢复正常运行。 这被称为&quot;恐慌&quot;。</p>
<p>恐慌是通过 <code>panic</code> 功能完成的。</p>
<pre><code class="language-python">panic &quot;something went wrong!&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道运算符"><a class="header" href="#管道运算符">管道运算符</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/31_pipeline.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/31_pipeline.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>管道运算符的使用方式如下：</p>
<pre><code class="language-python">assert f(g(x)) == (x |&gt; g |&gt; f)
assert f(g(x, y)) == ((x, y) |&gt; g |&gt; f)
</code></pre>
<p>换句话说，<code>Callable(object)</code> 的顺序可以更改为 <code>object |&gt; Callable</code>。
管道运算符也可用于方法。 对于方法，<code>object.method(args)</code> 更改为 <code>object |&gt;.method(args)</code>。
它看起来只是更多的<code>|&gt;</code>，但由于粘合强度较低，您可以减少<code>()</code>的数量。</p>
<pre><code class="language-python">rand = -1.0..1.0 |&gt;.sample!()
log rand # 0.2597...

1+1*2 |&gt;.times do log(&quot;a&quot;, end := &quot;&quot;) # aaa

evens = 1..100 |&gt;.iter |&gt;.filter i -&gt; i % 2 == 0 |&gt;.collect Array
# 在没有管道操作符的情况下实现，
_evens = (1..100).iter().filter(i -&gt; i % 2 == 0).collect(Array)
# or
__evens = 1..100 \
    .iter() \
    .filter i -&gt; i % 2 == 0 \
    .collect Array
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与-python-集成"><a class="header" href="#与-python-集成">与 Python 集成</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="打包系统"><a class="header" href="#打包系统">打包系统</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/33_package_system.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/33_package_system.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg包大致可以分为app包，即应用程序，以及lib包，即库。
应用包的入口点是<code>src/app.er</code>。 <code>app.er</code> 中定义的<code>main</code> 函数被执行。
lib 包的入口点是<code>src/lib.er</code>。导入包相当于导入 <code>lib.er</code>。</p>
<p>一个包有一个称为模块的子结构，在 Erg 中是一个 Erg 文件或由 Erg 文件组成的目录。外部 Erg 文件/目录是作为模块对象的可操作对象。</p>
<p>为了将目录识别为模块，有必要在目录中放置一个&quot;(目录名称).er&quot;文件。
这类似于 Python 的 <code>__init__.py</code>，但与 <code>__init__.py</code> 不同的是，它放在目录之外。</p>
<p>例如，考虑以下目录结构。</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.er
    └─ qux.er
</code></pre>
<p>您可以在 <code>app.er</code> 中导入 <code>foo</code> 和 <code>bar</code> 模块。由于 <code>bar.er</code> 文件，<code>bar</code> 目录可以被识别为一个模块。
<code>foo</code> 模块是由文件组成的模块，<code>bar</code> 模块是由目录组成的模块。 <code>bar</code> 模块还包含 <code>baz</code> 和 <code>qux</code> 模块。
该模块只是 <code>bar</code> 模块的一个属性，可以从 <code>app.er</code> 访问，如下所示。</p>
<pre><code class="language-python"># app.er
foo = import &quot;foo&quot;
bar = import &quot;bar&quot;
baz = bar.baz
# or `baz = import &quot;bar/baz&quot;`

main args =
    ...
</code></pre>
<p>请注意用于访问子模块的 <code>/</code> 分隔符。 这是因为可以有诸如 <code>bar.baz.er</code> 之类的文件名。
不鼓励使用此类文件名，因为 <code>.er</code> 前缀在 Erg 中是有意义的。
例如，用于测试的模块。 以 <code>.test.er</code> 结尾的文件是一个(白盒)测试模块，它在运行测试时执行一个用 <code>@Test</code> 修饰的子例程。</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  └─ foo.test.er
./src

```python
# app.er
foo = import &quot;foo&quot;

main args =
    ...
</code></pre>
<p>此外，以 .private.er 结尾的文件是私有模块，只能由同一目录中的模块访问。</p>
<pre><code class="language-console">└─┬
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.private.er
    └─ qux.er
</code></pre>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;
bar.qux
bar.baz # AttributeError: module 'baz' is private
</code></pre>
<pre><code class="language-python"># qux.er
baz = import &quot;baz&quot;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="生成器"><a class="header" href="#生成器">生成器</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/34_generator.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/34_generator.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>生成器是在块中使用 <code>yield!</code> 过程的特殊过程。</p>
<pre><code class="language-python">g!() =
    yield! 1
    yield! 2
    yield! 3
</code></pre>
<p><code>yield!</code> 是在调用<code>self!.yield!</code> 的子程序块中定义的过程。 和<code>return</code>一样，它把传递给它的值作为返回值返回，但它具有保存block当前执行状态，再次调用时从头开始执行的特性。
生成器既是过程又是迭代器； Python 生成器是一个创建迭代器的函数，而 Erg 直接迭代。 过程本身通常不是可变对象(没有<code>！</code>)，但生成器是可变对象，因为它自己的内容可以随着每次执行而改变。</p>
<pre><code class="language-python"># Generator!
g!: Generator!((), Int)
assert g!() == 1
assert g!() == 2
assert g!() == 3
</code></pre>
<p>Python 风格的生成器可以定义如下。</p>
<pre><code class="language-python">make_g() = () =&gt;
    yield! 1
    yield! 2
    yield! 3
make_g: () =&gt; Generator!
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="指数"><a class="header" href="#指数">指数</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/indexes.md&amp;commit_hash=438bcb89ea692f219b30f3a3ba107888b23eae98"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/indexes.md%26commit_hash%3D438bcb89ea692f219b30f3a3ba107888b23eae98" alt="badge" /></a></p>
<p>有关不在此索引中的 API，请参阅 <a href="../API/index.html">此处</a>。
有关术语，请参见 <a href="../dev_guide/terms.html">此处</a>。</p>
<h2 id="符号"><a class="header" href="#符号">符号</a></h2>
<ul>
<li>!
<ul>
<li>!-type → <a href="./type/mut.html">可变性</a></li>
</ul>
</li>
<li><a href="./00_basic.html">#</a></li>
<li>$</li>
<li>%</li>
<li>&amp;
<ul>
<li>&amp;&amp;</li>
</ul>
</li>
<li>′ (single quote)</li>
<li>()</li>
<li>*
<ul>
<li><a href="./01_literal.html">*-less multiplication</a></li>
</ul>
</li>
<li>+ (前置)
<ul>
<li>+_ → + (前置)</li>
</ul>
</li>
<li>+ (中置)</li>
<li>,</li>
<li>− (前置)
<ul>
<li>−_ → − (前置)</li>
</ul>
</li>
<li>− (中置)
<ul>
<li>−&gt;</li>
</ul>
</li>
<li>. → [可见性]</li>
<li>/</li>
<li>:
<ul>
<li>:: → [可见性]</li>
</ul>
</li>
<li>;</li>
<li>&lt;
<ul>
<li>&lt;:</li>
<li>&lt;&lt;</li>
<li>&lt;=</li>
</ul>
</li>
<li>=
<ul>
<li>==</li>
<li>=&gt;</li>
</ul>
</li>
<li>&gt;
<ul>
<li>&gt;&gt;</li>
<li>&gt;=</li>
</ul>
</li>
<li>?</li>
<li>@</li>
<li>[]</li>
<li></li>
<li>^
<ul>
<li>^^</li>
</ul>
</li>
<li>_
<ul>
<li>_+_ → + (infix)</li>
<li>_-_ → − (infix)
*``</li>
</ul>
</li>
<li>{}
<ul>
<li>{} type</li>
</ul>
</li>
<li>{:}</li>
<li>{=}
<ul>
<li>{=} type</li>
</ul>
</li>
<li>|
<ul>
<li>||</li>
</ul>
</li>
<li>~</li>
</ul>
<h2 id="字母"><a class="header" href="#字母">字母</a></h2>
<h3 id="a"><a class="header" href="#a">A</a></h3>
<ul>
<li>algebraic type</li>
<li>And</li>
<li>and</li>
<li>assert</li>
<li>attribute</li>
</ul>
<h3 id="b"><a class="header" href="#b">B</a></h3>
<ul>
<li>Base</li>
<li>Bool</li>
</ul>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li>Class</li>
</ul>
<h3 id="d"><a class="header" href="#d">D</a></h3>
<ul>
<li>Deprecated</li>
<li>distinct</li>
</ul>
<h3 id="e"><a class="header" href="#e">E</a></h3>
<ul>
<li>enum type</li>
<li>Eq</li>
<li>Erg</li>
</ul>
<h3 id="f"><a class="header" href="#f">F</a></h3>
<ul>
<li>for</li>
</ul>
<h3 id="g"><a class="header" href="#g">G</a></h3>
<h3 id="h"><a class="header" href="#h">H</a></h3>
<h3 id="i"><a class="header" href="#i">I</a></h3>
<ul>
<li>if</li>
<li>import</li>
<li>in</li>
<li>Int</li>
</ul>
<h3 id="j"><a class="header" href="#j">J</a></h3>
<h3 id="k"><a class="header" href="#k">K</a></h3>
<h3 id="l"><a class="header" href="#l">L</a></h3>
<ul>
<li>let-polymorphism → [rank 1 polymorphism]</li>
<li>log</li>
</ul>
<h3 id="m"><a class="header" href="#m">M</a></h3>
<ul>
<li>match</li>
</ul>
<h3 id="n"><a class="header" href="#n">N</a></h3>
<ul>
<li>Nat</li>
<li>Never</li>
<li>None</li>
<li>None</li>
<li>Not</li>
<li>not</li>
</ul>
<h3 id="o"><a class="header" href="#o">O</a></h3>
<ul>
<li>Option</li>
<li>Or</li>
<li>or</li>
<li>Ord</li>
</ul>
<h3 id="p"><a class="header" href="#p">P</a></h3>
<ul>
<li>panic</li>
<li><a href="./../API/procs.html#print">print!</a></li>
<li>Python</li>
</ul>
<h3 id="q"><a class="header" href="#q">Q</a></h3>
<h3 id="r"><a class="header" href="#r">R</a></h3>
<ul>
<li>ref</li>
<li>ref!</li>
<li>Result</li>
<li>rootobj</li>
</ul>
<h3 id="s"><a class="header" href="#s">S</a></h3>
<ul>
<li>self</li>
<li><a href="./type/special.html">Self</a></li>
<li><a href="./07_side_effect.html">side-effect</a></li>
<li>Str</li>
</ul>
<h3 id="t"><a class="header" href="#t">T</a></h3>
<ul>
<li>Traits</li>
<li>True</li>
<li>Type</li>
<li>type</li>
</ul>
<h3 id="u"><a class="header" href="#u">U</a></h3>
<h3 id="v"><a class="header" href="#v">V</a></h3>
<h3 id="w"><a class="header" href="#w">W</a></h3>
<ul>
<li>while!</li>
</ul>
<h3 id="x"><a class="header" href="#x">X</a></h3>
<h3 id="y"><a class="header" href="#y">Y</a></h3>
<h3 id="z"><a class="header" href="#z">Z</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
