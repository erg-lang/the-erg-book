<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Erg Book</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="00_basic.html"><strong aria-hidden="true">1.</strong> 基本</a></li><li class="chapter-item expanded "><a href="01_literal.html"><strong aria-hidden="true">2.</strong> 字面量</a></li><li class="chapter-item expanded "><a href="02_name.html"><strong aria-hidden="true">3.</strong> 變量和常量</a></li><li class="chapter-item expanded "><a href="03_declaration.html"><strong aria-hidden="true">4.</strong> 聲明</a></li><li class="chapter-item expanded "><a href="04_function.html"><strong aria-hidden="true">5.</strong> 函數</a></li><li class="chapter-item expanded "><a href="05_builtin_funcs.html"><strong aria-hidden="true">6.</strong> 內置函數</a></li><li class="chapter-item expanded "><a href="06_operator.html"><strong aria-hidden="true">7.</strong> 運算符</a></li><li class="chapter-item expanded "><a href="07_side_effect.html"><strong aria-hidden="true">8.</strong> 副作用</a></li><li class="chapter-item expanded "><a href="08_procedure.html"><strong aria-hidden="true">9.</strong> 程序</a></li><li class="chapter-item expanded "><a href="09_builtin_procs.html"><strong aria-hidden="true">10.</strong> 內置程序</a></li><li class="chapter-item expanded "><a href="10_array.html"><strong aria-hidden="true">11.</strong> 數組</a></li><li class="chapter-item expanded "><a href="11_tuple.html"><strong aria-hidden="true">12.</strong> 元組</a></li><li class="chapter-item expanded "><a href="12_dict.html"><strong aria-hidden="true">13.</strong> 字典</a></li><li class="chapter-item expanded "><a href="13_record.html"><strong aria-hidden="true">14.</strong> 記錄(Record)</a></li><li class="chapter-item expanded "><a href="14_set.html"><strong aria-hidden="true">15.</strong> Set</a></li><li class="chapter-item expanded "><a href="15_type.html"><strong aria-hidden="true">16.</strong> 類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/01_type_system.html"><strong aria-hidden="true">16.1.</strong> 類型系統</a></li><li class="chapter-item expanded "><a href="type/02_basic.html"><strong aria-hidden="true">16.2.</strong> 基礎</a></li><li class="chapter-item expanded "><a href="type/03_trait.html"><strong aria-hidden="true">16.3.</strong> Trait</a></li><li class="chapter-item expanded "><a href="type/04_class.html"><strong aria-hidden="true">16.4.</strong> 類</a></li><li class="chapter-item expanded "><a href="type/05_inheritance.html"><strong aria-hidden="true">16.5.</strong> 繼承</a></li><li class="chapter-item expanded "><a href="type/06_nst_vs_sst.html"><strong aria-hidden="true">16.6.</strong> NST 與 SST</a></li><li class="chapter-item expanded "><a href="type/07_patch.html"><strong aria-hidden="true">16.7.</strong> 補丁</a></li><li class="chapter-item expanded "><a href="type/08_value.html"><strong aria-hidden="true">16.8.</strong> 值類型</a></li><li class="chapter-item expanded "><a href="type/09_attributive.html"><strong aria-hidden="true">16.9.</strong> 屬性類型</a></li><li class="chapter-item expanded "><a href="type/10_interval.html"><strong aria-hidden="true">16.10.</strong> 區間類型</a></li><li class="chapter-item expanded "><a href="type/11_enum.html"><strong aria-hidden="true">16.11.</strong> 枚舉類型</a></li><li class="chapter-item expanded "><a href="type/12_refinement.html"><strong aria-hidden="true">16.12.</strong> 強化類型</a></li><li class="chapter-item expanded "><a href="type/13_algebraic.html"><strong aria-hidden="true">16.13.</strong> 代數類型</a></li><li class="chapter-item expanded "><a href="type/14_dependent.html"><strong aria-hidden="true">16.14.</strong> 依賴類型</a></li><li class="chapter-item expanded "><a href="type/15_quantified.html"><strong aria-hidden="true">16.15.</strong> 量化類型</a></li><li class="chapter-item expanded "><a href="type/16_subtyping.html"><strong aria-hidden="true">16.16.</strong> 子類型</a></li><li class="chapter-item expanded "><a href="type/17_type_casting.html"><strong aria-hidden="true">16.17.</strong> 類型轉換</a></li><li class="chapter-item expanded "><a href="type/18_mut.html"><strong aria-hidden="true">16.18.</strong> 可變類型</a></li><li class="chapter-item expanded "><a href="type/advanced.html"><strong aria-hidden="true">16.19.</strong> 高級類型</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="type/advanced/default_param.html"><strong aria-hidden="true">16.19.1.</strong> 默認參數</a></li><li class="chapter-item expanded "><a href="type/advanced/erasure.html"><strong aria-hidden="true">16.19.2.</strong> 類型擦除</a></li><li class="chapter-item expanded "><a href="type/advanced/existential.html"><strong aria-hidden="true">16.19.3.</strong> 存在類型</a></li><li class="chapter-item expanded "><a href="type/advanced/GADTs.html"><strong aria-hidden="true">16.19.4.</strong> GADTs</a></li><li class="chapter-item expanded "><a href="type/advanced/keyword_param.html"><strong aria-hidden="true">16.19.5.</strong> 關鍵字參數</a></li><li class="chapter-item expanded "><a href="type/advanced/kind.html"><strong aria-hidden="true">16.19.6.</strong> Kind(類型的類型)</a></li><li class="chapter-item expanded "><a href="type/advanced/marker_trait.html"><strong aria-hidden="true">16.19.7.</strong> 標記Trait</a></li><li class="chapter-item expanded "><a href="type/advanced/mut_struct.html"><strong aria-hidden="true">16.19.8.</strong> 可變結構</a></li><li class="chapter-item expanded "><a href="type/advanced/phantom.html"><strong aria-hidden="true">16.19.9.</strong> 幻象類型</a></li><li class="chapter-item expanded "><a href="type/advanced/projection.html"><strong aria-hidden="true">16.19.10.</strong> 投影類型</a></li><li class="chapter-item expanded "><a href="type/advanced/quantified_dependent.html"><strong aria-hidden="true">16.19.11.</strong> 量化依賴類型</a></li><li class="chapter-item expanded "><a href="type/advanced/shared.html"><strong aria-hidden="true">16.19.12.</strong> 共享引用</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="16_iterator.html"><strong aria-hidden="true">17.</strong> 迭代器</a></li><li class="chapter-item expanded "><a href="17_mutability.html"><strong aria-hidden="true">18.</strong> 可變性</a></li><li class="chapter-item expanded "><a href="18_ownership.html"><strong aria-hidden="true">19.</strong> 所有權</a></li><li class="chapter-item expanded "><a href="19_visibility.html"><strong aria-hidden="true">20.</strong> 可見性</a></li><li class="chapter-item expanded "><a href="20_naming_rule.html"><strong aria-hidden="true">21.</strong> 命名規則</a></li><li class="chapter-item expanded "><a href="21_lambda.html"><strong aria-hidden="true">22.</strong> Lambda</a></li><li class="chapter-item expanded "><a href="22_subroutine.html"><strong aria-hidden="true">23.</strong> 子程序</a></li><li class="chapter-item expanded "><a href="23_closure.html"><strong aria-hidden="true">24.</strong> 閉包</a></li><li class="chapter-item expanded "><a href="24_module.html"><strong aria-hidden="true">25.</strong> 模塊</a></li><li class="chapter-item expanded "><a href="25_object_system.html"><strong aria-hidden="true">26.</strong> 對象系統</a></li><li class="chapter-item expanded "><a href="26_pattern_matching.html"><strong aria-hidden="true">27.</strong> 模式匹配</a></li><li class="chapter-item expanded "><a href="27_comprehension.html"><strong aria-hidden="true">28.</strong> 推導式</a></li><li class="chapter-item expanded "><a href="28_spread_syntax.html"><strong aria-hidden="true">29.</strong> 擴展語法</a></li><li class="chapter-item expanded "><a href="29_decorator.html"><strong aria-hidden="true">30.</strong> 裝飾器</a></li><li class="chapter-item expanded "><a href="30_error_handling.html"><strong aria-hidden="true">31.</strong> 錯誤處理</a></li><li class="chapter-item expanded "><a href="31_pipeline.html"><strong aria-hidden="true">32.</strong> 管道運算符</a></li><li class="chapter-item expanded "><a href="32_integration_with_Python.html"><strong aria-hidden="true">33.</strong> 與 Python 集成</a></li><li class="chapter-item expanded "><a href="33_package_system.html"><strong aria-hidden="true">34.</strong> 包系統</a></li><li class="chapter-item expanded "><a href="34_generator.html"><strong aria-hidden="true">35.</strong> 生成器</a></li><li class="chapter-item expanded "><a href="indexes.html"><strong aria-hidden="true">36.</strong> 索引</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Erg Book</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="基本"><a class="header" href="#基本">基本</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/00_basic.md&amp;commit_hash=13f2d31aee9012f60b7a40d4b764921f1419cdfe"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/00_basic.md%26commit_hash%3D13f2d31aee9012f60b7a40d4b764921f1419cdfe" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>: 本文檔不完整。它未經校對(樣式、正確鏈接、誤譯等)。此外，Erg 的語法可能在版本 0.* 期間發生破壞性更改，并且文檔可能沒有相應更新。請事先了解這一點
如果您在本文檔中發現任何錯誤，請報告至 <a href="https://forms.gle/HtLYRfYzWCAaeTGb6">此處的表單</a> 或 <a href="https://github.com/erg-lang/erg/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.yaml">GitHub repo</a>。我們將不勝感激您的建議</p>
</blockquote>
<p>本文檔描述 Erg 的基本語法
如果您已經有使用 Python 等語言的經驗，請參閱 <a href="quick_tour.html">快速瀏覽</a> 了解概覽
還有一個單獨的 <a href="../API/index.html">標準 API</a> 和 <a href="../dev_guide/index.html">Erg 貢獻者的內部文檔</a>。如果您需要語法或 Erg 本身的詳細說明, 請參閱那些文檔</p>
<h2 id="你好世界"><a class="header" href="#你好世界">你好，世界!</a></h2>
<p>首先，讓我們做&quot;Hello World&quot;</p>
<pre><code class="language-python">print!(&quot;Hello, World!&quot;)
</code></pre>
<p>這與 Python 和同一家族中的其他語言幾乎相同。最顯著的Trait是<code>!</code>，后面會解釋它的含義
在 Erg 中，括號 <code>()</code> 可以省略，除非在解釋上有一些混淆
括號的省略與 Ruby 類似，但不能省略可以以多種方式解釋的括號</p>
<pre><code class="language-python">print! &quot;Hello, World!&quot; # OK
print! &quot;Hello,&quot;, &quot;World!&quot; # OK
print!() # OK
print! # OK, 但這并不意味著調用，只是將 `print!` 作為可調用對象

print! f x # OK, 解釋為 `print!(f(x))`
print!(f(x, y)) # OK
print! f(x, y) # OK
print! f(x, g y) # OK
print! f x, y # NG, 可以理解為 `print!(f(x), y)` 或 `print!(f(x, y))` print!
print!(f x, y) # NG, 可以表示&quot;print！(f(x)，y)&quot;或&quot;print！(f(x，y))&quot;
print! f(x, g y, z) # NG, 可以表示&quot;print！(x，g(y)，z)&quot;或&quot;print！(x，g(y，z))&quot;
</code></pre>
<h2 id="腳本"><a class="header" href="#腳本">腳本</a></h2>
<p>Erg 代碼稱為腳本。腳本可以以文件格式 (.er) 保存和執行</p>
<h2 id="repl文件執行"><a class="header" href="#repl文件執行">REPL/文件執行</a></h2>
<p>要啟動 REPL，只需鍵入: </p>
<pre><code class="language-sh">&gt; erg
</code></pre>
<p><code>&gt;</code> mark is a prompt, just type <code>erg</code>.
Then the REPL should start.</p>
<pre><code class="language-sh">&gt; erg
Starting the REPL server...
Connecting to the REPL server...
Erg interpreter 0.2.4 (tags/?:, 2022/08/17  0:55:12.95) on x86_64/windows
&gt;&gt;&gt;
</code></pre>
<p>Or you can compile from a file.</p>
<pre><code class="language-sh">&gt; 'print! &quot;hello, world!&quot;' &gt;&gt; hello.er

&gt; erg hello.er
hello, world!
</code></pre>
<h2 id="注釋"><a class="header" href="#注釋">注釋</a></h2>
<p><code>#</code> 之后的代碼作為注釋被忽略。使用它來解釋代碼的意圖或暫時禁用代碼</p>
<pre><code class="language-python"># Comment
# `#` and after are ignored until a new line is inserted
# [
Multi-line comment
Treated as a comment all the way up to the corresponding `]#`
]# 
</code></pre>
<h2 id="表達式分隔符"><a class="header" href="#表達式分隔符">表達式，分隔符</a></h2>
<p>腳本是一系列表達式。表達式是可以計算或評估的東西，在 Erg 中幾乎所有東西都是表達式
每個表達式由分隔符分隔 - 新行或分號 <code>;</code>-
Erg 腳本基本上是從左到右、從上到下進行評估的</p>
<pre><code class="language-python">n = 1 # 賦值表達式
f(1, 2) # 函數調用表達式
1 + 1 # 運算符調用表達式
f(1, 2); 1 + 1
</code></pre>
<p>如下所示，有一種稱為 Instant block 的語法，它將塊中評估的最后一個表達式作為變量的值
這與沒有參數的函數不同，它不添加 <code>()</code>。請注意，即時塊僅在運行中評估一次</p>
<pre><code class="language-python">i =
    x = 1
    x + 1
assert i == 2
</code></pre>
<p>這不能用分號 (<code>;</code>) 完成</p>
<pre><code class="language-python">i = (x = 1; x + 1) # 語法錯誤: 不能在括號中使用 `;`
</code></pre>
<h2 id="縮進"><a class="header" href="#縮進">縮進</a></h2>
<p>Erg 和 Python 一樣，使用縮進來表示塊。有五個運算符(特殊形式)觸發塊的開始: <code>=</code>、<code>-&gt;</code>、<code>=&gt;</code>、<code>do</code> 和 <code>do!</code>(此外，<code>:</code> 和 <code>|</code> ，雖然不是運算符，但也會產生縮進)。每個的含義將在后面描述</p>
<pre><code class="language-python">f x, y =
    x + y

for! 0..9, i =&gt;
    print!

for! 0..9, i =&gt;
    print! i; print! i

ans = match x:
    0 -&gt; &quot;zero&quot;
    _: 0..9 -&gt; &quot;1 dight&quot;
    _: 10..99 -&gt; &quot;2 dights&quot;
    _ -&gt; &quot;unknown&quot;
</code></pre>
<p>如果一行太長，可以使用 <code>\</code> 將其斷開</p>
<pre><code class="language-python"># 這不是表示 `x + y + z` 而是表示 `x; +y; +z`
X
+ y
+ z

# 這意味著`x + y + z`
x \
+ y \
+ z
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="字面量"><a class="header" href="#字面量">字面量</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/01_literal.md&amp;commit_hash=00350f64a40b12f763a605bc16748d09379ab182"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/01_literal.md%26commit_hash%3D00350f64a40b12f763a605bc16748d09379ab182" alt="badge" /></a></p>
<h2 id="基本字面量"><a class="header" href="#基本字面量">基本字面量</a></h2>
<h3 id="整數字面量"><a class="header" href="#整數字面量">整數字面量</a></h3>
<pre><code class="language-python">0, -0, 1, -1, 2, -2, 3, -3, ...
</code></pre>
<h3 id="比率文字"><a class="header" href="#比率文字">比率文字</a></h3>
<pre><code class="language-python">0.00, -0.0, 0.1, 400.104, ...
</code></pre>
<p>如果&quot;比率&quot;文字的整數或小數部分為<code>0</code>，則可以省略<code>0</code></p>
<pre><code class="language-python">assert 1.0 == 1.
assert 0.5 == .5
</code></pre>
<blockquote>
<p><strong>注意</strong>: 這個函數 <code>assert</code> 用于表明 <code>1.0</code> 和 <code>1.</code> 相等
后續文檔可能會使用 <code>assert</code> 來表示結果是相等的</p>
</blockquote>
<h3 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h3>
<p>可以使用任何 Unicode 可表示的字符串
與 Python 不同，引號不能包含在 <code>'</code> 中。如果要在字符串中使用 <code>&quot;</code>，請使用 <code>\&quot;</code></p>
<pre><code class="language-python">&quot;&quot;, &quot;a&quot;, &quot;abc&quot;, &quot;111&quot;, &quot;1# 3f2-3*8$&quot;, &quot;こんにちは&quot;, &quot;?????????? ??????????&quot;, ...
</code></pre>
<p><code>{}</code> 允許您在字符串中嵌入表達式。這稱為字符串插值
如果要輸出 <code>{</code>、<code>}</code> 本身，請使用 <code>\{</code>、<code>\}</code></p>
<pre><code class="language-python">assert &quot;1 + 1 is 2&quot; == &quot;{1} + {1} is {1+1}&quot;
s = &quot;1+1&quot;
assert &quot;\{1+1}\&quot; == &quot;\{{s}\}&quot;
</code></pre>
<h3 id="指數字面量"><a class="header" href="#指數字面量">指數字面量</a></h3>
<p>這是學術計算中常用的表示指數符號的文字。它是&quot;比率&quot;類型的一個實例
該符號與 Python 中的符號相同</p>
<pre><code class="language-python">1e-34, 0.4e-10, 2.455+e5, 245e5, 25E5, ...
</code></pre>
<pre><code class="language-python">assert 1e-10 == 0.0000000001
</code></pre>
<h2 id="復合字面量"><a class="header" href="#復合字面量">復合字面量</a></h2>
<p>這些文字中的每一個都有自己的文檔分別描述它們，因此請參閱該文檔以獲取詳細信息</p>
<h3 id="a-href10_arrayhtml數組字面量a"><a class="header" href="#a-href10_arrayhtml數組字面量a"><a href="./10_array.html">數組字面量</a></a></h3>
<pre><code class="language-python">[], [1], [1, 2, 3], [&quot;1&quot;, &quot;2&quot;,], [1, &quot;1&quot;, True, [1]], ...
</code></pre>
<h3 id="a-href11_tuplehtml元組字面量a"><a class="header" href="#a-href11_tuplehtml元組字面量a"><a href="./11_tuple.html">元組字面量</a></a></h3>
<pre><code class="language-python">(), (1, 2, 3), (1, &quot;hello&quot;, True), ...
</code></pre>
<h3 id="a-href12_dicthtml字典字面量a"><a class="header" href="#a-href12_dicthtml字典字面量a"><a href="./12_dict.html">字典字面量</a></a></h3>
<pre><code class="language-python">{:}, {&quot;one&quot;: 1}, {&quot;one&quot;: 1, &quot;two&quot;: 2}, {&quot;1&quot;: 1, &quot;2&quot;: 2}, {1: &quot;1&quot;, 2: True, &quot;three&quot;: [1]}, ...
</code></pre>
<h3 id="a-href13_recordhtmlrecord-字面量a"><a class="header" href="#a-href13_recordhtmlrecord-字面量a"><a href="./13_record.html">Record 字面量</a></a></h3>
<pre><code class="language-python">{=}, {one = 1}, {one = 1; two = 2}, {.name = &quot;John&quot;; .age = 12}, {.name = Str; .age = Nat}, ...
</code></pre>
<h3 id="a-href14_sethtmlset-字面量a"><a class="header" href="#a-href14_sethtmlset-字面量a"><a href="./14_set.html">Set 字面量</a></a></h3>
<pre><code class="language-python">{}, {1}, {1, 2, 3}, {&quot;1&quot;, &quot;2&quot;, &quot;1&quot;}, {1, &quot;1&quot;, True, [1]} ...
</code></pre>
<p>與 <code>Array</code> 字面量不同的是，<code>Set</code> 中刪除了重復元素</p>
<pre><code class="language-python">assert {1, 2, 1} == {1, 2}
</code></pre>
<h3 id="看起來像文字但不是"><a class="header" href="#看起來像文字但不是">看起來像文字但不是</a></h3>
<h2 id="布爾對象"><a class="header" href="#布爾對象">布爾對象</a></h2>
<pre><code class="language-python">True, False
</code></pre>
<h3 id="none-對象"><a class="header" href="#none-對象">None 對象</a></h3>
<pre><code class="language-python">None
</code></pre>
<h2 id="range-對象"><a class="header" href="#range-對象">Range 對象</a></h2>
<pre><code class="language-python">assert 0..5 == {1, 2, 3, 4, 5}
assert 0..10 in 5
assert 0..&lt;10 notin 10
assert 0..9 == 0..&lt;10
</code></pre>
<h2 id="float-對象"><a class="header" href="#float-對象">Float 對象</a></h2>
<pre><code class="language-python">assert 0.0f64 == 0
assert 0.0f32 == 0.0f64
</code></pre>
<p>浮點對象是通過將 <code>Ratio</code> 對象乘以 <code>f64</code> 構造的，后者是 <code>Float 64</code> 單位對象</p>
<h2 id="complex-對象"><a class="header" href="#complex-對象">Complex 對象</a></h2>
<pre><code class="language-python">1+2im, 0.4-1.2im, 0im, im
</code></pre>
<p>一個&quot;復雜&quot;對象只是一個虛數單位對象<code>im</code>的算術組合</p>
<h2 id="-less-乘法"><a class="header" href="#-less-乘法">*-less 乘法</a></h2>
<p>在 Erg 中，您可以省略 <code>*</code> 來表示乘法，只要解釋上沒有混淆即可。但是，運算符的組合強度設置為強于 <code>*</code></p>
<pre><code class="language-python"># same as `assert (1*m) / (1*s) == 1*(m/s)`
assert 1m / 1s == 1 (m/s)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="變量和常量"><a class="header" href="#變量和常量">變量和常量</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/02_name.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/02_name.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="變量"><a class="header" href="#變量">變量</a></h2>
<p>變量是一種代數； Erg 中的代數 - 如果沒有混淆，有時簡稱為變量 - 指的是命名對象并使它們可從代碼的其他地方引用的功能</p>
<p>變量定義如下
<code>n</code> 部分稱為變量名(或標識符)，<code>=</code> 是賦值運算符，<code>1</code> 部分是賦值</p>
<pre><code class="language-python">n = 1
</code></pre>
<p>以這種方式定義的&quot;n&quot;此后可以用作表示整數對象&quot;1&quot;的變量。該系統稱為分配(或綁定)
我們剛剛說過<code>1</code>是一個對象。稍后我們將討論對象是什么，但現在我們假設它是可以賦值的，即在賦值運算符的右側(<code>=</code> 等)</p>
<p>如果要指定變量的&quot;類型&quot;，請執行以下操作。類型大致是一個對象所屬的集合，后面會解釋
這里我們指定<code>n</code>是自然數(<code>Nat</code>)類型</p>
<pre><code class="language-python">n: Nat = 1
</code></pre>
<p>請注意，與其他語言不同，不允許多次分配</p>
<pre><code class="language-python"># NG
l1 = l2 = [1, 2, 3] # 語法錯誤: 不允許多重賦值
# OK
l1 = [1, 2, 3]
l2 = l1.clone()
</code></pre>
<p>也不能重新分配給變量。稍后將描述可用于保存可變狀態的語法</p>
<pre><code class="language-python">i = 1
i = i + 1 # 分配錯誤: 不能分配兩次
</code></pre>
<p>您可以在內部范圍內定義具有相同名稱的變量，但您只是覆蓋它，而不是破壞性地重寫它的值。如果您返回外部范圍，該值也會返回
請注意，這是與 Python &quot;語句&quot;范圍不同的行為
這種功能通常稱為陰影。但是，與其他語言中的陰影不同，您不能在同一范圍內進行陰影</p>
<pre><code class="language-python">x = 0
# x = 1 # 賦值錯誤: 不能賦值兩次
if x.is_zero(), do:
    x = 1 # 與同名的外部 x 不同
    assert x == 1
assert x == 0
</code></pre>
<p>乍一看，以下內容似乎可行，但仍然不可能。這是一個設計決定，而不是技術限制</p>
<pre><code class="language-python">x = 0
if x.is_zero(), do:
    x = x + 1 # 名稱錯誤: 無法定義變量引用同名變量
    assert x == 1
assert x == 0
</code></pre>
<h2 id="常量"><a class="header" href="#常量">常量</a></h2>
<p>常數也是一種代數。如果標識符以大寫字母開頭，則將其視為常量。它們被稱為常量，因為一旦定義，它們就不會改變
<code>N</code> 部分稱為常量名(或標識符)。否則，它與變量相同</p>
<pre><code class="language-python">N = 0
if True, do:
    N = 1 # 賦值錯誤: 常量不能被遮蔽
    pass()
</code></pre>
<p>常量在定義的范圍之外是不可變的。他們不能被遮蔽。由于這個屬性，常量可以用于模式匹配。模式匹配在后面解釋</p>
<p>例如，常量用于數學常量、有關外部資源的信息和其他不可變值</p>
<p>除了 <a href="./type/01_type_system.html">types</a> 之外的對象標識符使用全大寫(所有字母大寫的樣式)是常見的做法</p>
<pre><code class="language-python">PI = 3.141592653589793
URL = &quot;https://example.com&quot;
CHOICES = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre>
<pre><code class="language-python">PI = 3.141592653589793
match! x:
    PI =&gt; print! &quot;π&quot;
    other =&gt; print! &quot;other&quot;
</code></pre>
<p>當 <code>x</code> 為 <code>3.141592653589793</code> 時，上面的代碼會打印 <code>π</code>。如果 <code>x</code> 更改為任何其他數字，它會打印 <code>other</code></p>
<p>有些對象不能綁定為常量。例如，可變對象。可變對象是其狀態可以改變的對象，后面會詳細介紹
這是因為只有常量表達式才能分配給常量的規則。常量表達式也將在后面討論</p>
<pre><code class="language-python">X = 1 # OK
X = !1 # 類型錯誤: 無法定義 Int！ 對象作為常量
</code></pre>
<h2 id="刪除變量"><a class="header" href="#刪除變量">刪除變量</a></h2>
<p>您可以使用 <code>Del</code> 函數刪除變量。依賴于變量的所有其他變量(即直接引用變量值的變量)也將被刪除</p>
<pre><code class="language-python">x = 1
y = 2
Z = 3
f a = x + a

assert f(2) == 3
Del x
Del y, Z

f(2) # 名稱錯誤: f 未定義(在第 6 行中刪除)
</code></pre>
<p>注意 <code>Del</code> 只能刪除用戶自定義模塊中定義的變量。無法刪除諸如&quot;True&quot;之類的內置常量</p>
<pre><code class="language-python">Del True # 類型錯誤: 無法刪除內置常量
Del print! # TypeError: 無法刪除內置變量
</code></pre>
<h2 id="附錄-賦值和等價"><a class="header" href="#附錄-賦值和等價">附錄: 賦值和等價</a></h2>
<p>請注意，當 <code>x = a</code> 時，<code>x == a</code> 不一定為真。一個例子是<code>Float.NaN</code>。這是 IEEE 754 定義的浮點數的正式規范</p>
<pre><code class="language-python">x = Float.NaN
assert x ! = NaN
assert x ! = x
</code></pre>
<p>還有其他對象首先沒有定義等價關系</p>
<pre><code class="language-python">f = x -&gt; x**2 + 2x + 1
g = x -&gt; (x + 1)**2
f == g # 類型錯誤: 無法比較函數對象

C = Class {i: Int}
D = Class {i: Int}
C == D # 類型錯誤: 無法比較類對象
</code></pre>
<p>嚴格來說，<code>=</code> 不會將右側的值直接分配給左側的標識符
在函數和類對象的情況下，執行&quot;修改&quot;，例如將變量名稱信息賦予對象。但是，結構類型并非如此</p>
<pre><code class="language-python">f x = x
print! f # &lt;函數 f&gt;
g x = x + 1
print! g # &lt;函數 g&gt;

C = Class {i: Int}
print! C # &lt;類 C&gt;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="宣言declaration"><a class="header" href="#宣言declaration">宣言(Declaration)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/03_declaration.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/03_declaration.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>聲明是用于指定要使用的變量類型的語法
可以在代碼中的任何地方進行聲明，但單獨的聲明并不引用變量。它們必須被初始化
分配后，可以檢查聲明以確保類型與分配它的對象兼容</p>
<pre><code class="language-python">i: Int
# 可以與賦值同時聲明，如 i: Int = 2
i = 2
i: Num
i: Nat
i: -2..2
i: {2}
</code></pre>
<p>賦值后的聲明類似于<code>assert</code>的類型檢查，但具有在編譯時檢查的特點
在運行時通過<code>assert</code>進行類型檢查可以檢查&quot;可能是Foo類型&quot;，但是在編譯時通過<code>:</code>進行類型檢查是嚴格的: 如果類型未確定為&quot;類型Foo&quot;，則不會通過 檢查會出現錯誤</p>
<pre><code class="language-python">i = (-1..10).sample!
assert i in Nat # 這可能會通過
i: Int # 這會通過
i: Nat # 這不會通過(-1 不是 Nat 的元素)
</code></pre>
<p>函數可以用兩種不同的方式聲明</p>
<pre><code class="language-python">f: (x: Int, y: Int) -&gt; Int
f: (Int, Int) -&gt; Int
</code></pre>
<p>如果顯式聲明參數名稱，如果在定義時名稱不同，則會導致類型錯誤。如果你想給參數名稱任意命名，你可以用第二種方式聲明它們。在這種情況下，類型檢查只會看到方法名稱及其類型</p>
<pre><code class="language-python">T = Trait {
    .f = (x: Int, y: Int): Int
}

C = Class(U, Impl := T)
C.f(a: Int, b: Int): Int = ... # 類型錯誤: `.f` 必須是 `(x: Int, y: Int) -&gt; Int` 的類型，而不是 `(a: Int, b: Int) -&gt; Int`
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="功能"><a class="header" href="#功能">功能</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/04_function.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/04_function.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>函數是一個塊，它接受一個&quot;參數&quot;，對其進行處理，并將其作為&quot;返回值&quot;返回。定義如下</p>
<pre><code class="language-python">add x, y = x + y
# 或者
add(x, y) = x + y
</code></pre>
<p>在函數名之后指定的名稱稱為參數
相反，傳遞給函數的對象稱為參數
函數 <code>add</code> 是一個以 <code>x</code> 和 <code>y</code> 作為參數并返回它們之和的函數，<code>x + y</code>
可以按如下方式調用(應用/調用)定義的函數</p>
<pre><code class="language-python">add 1, 2
# or
add(1, 2)
</code></pre>
<h2 id="冒號應用風格"><a class="header" href="#冒號應用風格">冒號應用風格</a></h2>
<p>函數像<code>f x, y, ...</code>一樣被調用，但是如果單行參數太多，可以使用<code>:</code>(冒號)來應用它們</p>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2, some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python">f some_long_name_variable_1 + some_long_name_variable_2:
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<pre><code class="language-python">f:
    some_long_name_variable_1 + some_long_name_variable_2
    some_long_name_variable_3 * some_long_name_variable_4
</code></pre>
<p>以上三個代碼的含義相同。例如，這種風格在使用 <code>if</code> 函數時也很有用</p>
<pre><code class="language-python">result = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
</code></pre>
<p>在 <code>:</code> 之后，除了注釋之外，不得編寫任何代碼，并且必須始終在新行上</p>
<h2 id="關鍵字參數"><a class="header" href="#關鍵字參數">關鍵字參數</a></h2>
<p>如果使用大量參數定義函數，則存在以錯誤順序傳遞參數的危險
在這種情況下，使用關鍵字參數調用函數是安全的</p>
<pre><code class="language-python">f x, y, z, w, v, u: Int = ...
</code></pre>
<p>上面定義的函數有很多參數，并且排列順序混亂。您不應該創建這樣的函數，但是在使用別人編寫的代碼時可能會遇到這樣的代碼。因此，我們使用關鍵字參數。如果使用關鍵字參數，則值會從名稱傳遞到正確的參數，即使它們的順序錯誤</p>
<pre><code class="language-python">f u: 6, v: 5, w: 4, x: 1, y: 2, z: 3
</code></pre>
<p>請注意，緊跟在 <code>:</code> 之后的關鍵字參數和新行被視為冒號調用樣式</p>
<pre><code class="language-python"># 意思是 `f(x: y)`
f x: y

# 意思是 `f(x, y)`
f x:
    y
</code></pre>
<h2 id="定義錯誤參數"><a class="header" href="#定義錯誤參數">定義錯誤參數</a></h2>
<p>當某些參數大部分是固定的并且您希望能夠省略它們時，使用默認參數</p>
<p>默認參數由<code>:=</code>(walrus運算符)指定。如果未指定 <code>base</code>，則將 <code>math.E</code> 分配給 <code>base</code></p>
<pre><code class="language-python">math_log x: Ratio, base := math.E = ...

assert math_log(100, 10) == 2
assert math_log(100) == math_log(100, math.E)
</code></pre>
<p>請注意，不指定參數和指定<code>None</code>是有區別的</p>
<pre><code class="language-python">p! x := 0 = print!
p!(2) # 2
p!() # 0
p!(None) # None
</code></pre>
<p>也可以與類型規范和模式一起使用</p>
<pre><code class="language-python">math_log x, base: Ratio := math.E = ...
f [x, y] := [1, 2] = ...
</code></pre>
<p>但是，在默認參數中，不能調用過程(稍后描述)或分配可變對象</p>
<pre><code class="language-python">f x := p! 1 = ... # NG
</code></pre>
<p>此外，剛剛定義的參數不能用作傳遞給默認參數的值</p>
<pre><code class="language-python">f x := 1, y := x = ... # NG
</code></pre>
<h2 id="可變長度參數"><a class="header" href="#可變長度參數">可變長度參數</a></h2>
<p>輸出其參數的日志(記錄)的 <code>log</code> 函數可以采用任意數量的參數</p>
<pre><code class="language-python">記錄&quot;你好&quot;、&quot;世界&quot;、&quot;！&quot; # 你好世界 ！
</code></pre>
<p>要定義這樣的函數，請將 <code>...</code> 添加到參數中。這樣，函數將參數作為可變長度數組接收</p>
<pre><code class="language-python">f ...x =
    for x, i -&gt;
        log i

# x == [1, 2, 3, 4, 5]
f 1, 2, 3, 4, 5
</code></pre>
<h2 id="具有多種模式的函數定義"><a class="header" href="#具有多種模式的函數定義">具有多種模式的函數定義</a></h2>
<pre><code class="language-python">fib n: Nat =
    match n:
        0 -&gt; 0
        1 -&gt; 1
        n -&gt; fib(n - 1) + fib(n - 2)
</code></pre>
<p>像上面這樣的函數，其中 <code>match</code> 直接出現在定義下，可以重寫如下</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
fib(n: Nat): Nat = fib(n - 1) + fib(n - 2)
</code></pre>
<p>注意一個函數定義有多個模式不是所謂的重載(multiple definition)； 一個函數只有一個定義。在上面的示例中，&quot;n&quot;必須與&quot;0&quot;或&quot;1&quot;屬于同一類型。此外，與 <code>match</code> 一樣，模式匹配是從上到下完成的</p>
<p>如果不同類的實例混合在一起，最后一個定義必須指定函數參數的類型為<code>Or</code></p>
<pre><code class="language-python">f &quot;aa&quot; = ...
f 1 = ...
# `f x = ... ` 無效
f x: Int or Str = ...
</code></pre>
<p>此外，像 <code>match</code> 一樣，它也必須是詳盡的</p>
<pre><code class="language-python">fib 0 = 0
fib 1 = 1
# 模式錯誤: fib 參數的模式并不詳盡
</code></pre>
<p>但是，可以通過使用稍后描述的 <a href="./type/12_refinement.html">refinement type</a> 顯式指定類型來使其詳盡無遺</p>
<pre><code class="language-python">fib: 0..1 -&gt; 0..1
fib 0 = 0
fib 1 = 1
# OK
</code></pre>
<h2 id="遞歸函數"><a class="header" href="#遞歸函數">遞歸函數</a></h2>
<p>遞歸函數是在其定義中包含自身的函數</p>
<p>作為一個簡單的例子，讓我們定義一個執行階乘計算的函數<code>factorial</code>。階乘是&quot;將所有小于或等于的正數相乘&quot;的計算
5 的階乘是 <code>5*4*3*2*1 == 120</code></p>
<pre><code class="language-python">factorial 0 = 1
factorial 1 = 1
factorial(n: Nat): Nat = n * factorial(n - 1)
</code></pre>
<p>首先，從階乘的定義來看，0和1的階乘都是1
反過來，2的階乘是<code>2*1 == 2</code>，3的階乘是<code>3*2*1 == 6</code>，4的階乘是<code>4*3*2*1 == 24 </code>
如果我們仔細觀察，我們可以看到一個數 n 的階乘是前一個數 n-1 乘以 n 的階乘
將其放入代碼中，我們得到 <code>n * factorial(n - 1)</code>
由于 <code>factorial</code> 的定義包含自身，<code>factorial</code> 是一個遞歸函數</p>
<p>提醒一下，如果您不添加類型規范，則會這樣推斷</p>
<pre><code class="language-python">factorial: |T &lt;: Sub(Int, T) and Mul(Int, Int) and Eq(Int)| T -&gt; Int
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial(n - 1)
</code></pre>
<p>但是，即使您可以推理，您也應該明確指定遞歸函數的類型。在上面的例子中，像&quot;factorial(-1)&quot;這樣的代碼可以工作，但是</p>
<pre><code class="language-python">factorial(-1) == -1 * factorial(-2) == -1 * -2 * factorial(-3) == ...
</code></pre>
<p>并且這種計算不會停止。遞歸函數必須仔細定義值的范圍，否則您可能會陷入無限循環
所以類型規范也有助于避免接受意外的值</p>
<h2 id="編譯時函數"><a class="header" href="#編譯時函數">編譯時函數</a></h2>
<p>函數名以大寫字母開頭，表示編譯時函數。用戶定義的編譯時函數必須將所有參數作為常量，并且必須指定它們的類型
編譯時函數的功能有限。在編譯時函數中只能使用常量表達式，即只有一些運算符(例如求積、比較和類型構造操作)和編譯時函數。要傳遞的參數也必須是常量表達式
作為回報，優點是計算可以在編譯時完成</p>
<pre><code class="language-python">Add(X, Y: Nat): Nat = X + Y
assert Add(1, 2) == 3

Factorial 0 = 1
Factorial(X: Nat): Nat = X * Factorial(X - 1)
assert Factorial(10) == 3628800

math = import &quot;math&quot;
Sin X = math.sin X # 常量錯誤: 此函數在編譯時不可計算
</code></pre>
<p>編譯時函數也用于多態類型定義</p>
<pre><code class="language-python">Option T: Type = T or NoneType
Option: Type -&gt; Type
</code></pre>
<h2 id="附錄-功能對比"><a class="header" href="#附錄-功能對比">附錄: 功能對比</a></h2>
<p>Erg 沒有為函數定義 <code>==</code>。這是因為通常沒有函數的結構等價算法</p>
<pre><code class="language-python">f = x: Int -&gt; (x + 1)**2
g = x: Int -&gt; x**2 + 2x + 1

assert f == g # 類型錯誤: 無法比較函數
</code></pre>
<p>盡管 <code>f</code> 和 <code>g</code> 總是返回相同的結果，但要做出這樣的決定是極其困難的。我們必須向編譯器教授代數
所以 Erg 完全放棄了函數比較，并且 <code>(x -&gt; x) == (x -&gt; x)</code> 也會導致編譯錯誤。這是與 Python 不同的規范，應該注意</p>
<pre><code class="language-python"># Python，奇怪的例子
f = lambda x: x
assert f == f
assert (lambda x: x) ! = (lambda x: x)
</code></pre>
<h2 id="appendix2--completion"><a class="header" href="#appendix2--completion">Appendix2: ()-completion</a></h2>
<pre><code class="language-python">f x: Object = ...
# 將完成到
f(x: Object) = ...

f a
# 將完成到
f(a)

f a, b # 類型錯誤: f() 接受 1 個位置參數，但給出了 2 個
f(a, b) # # 類型錯誤: f() 接受 1 個位置參數，但給出了 2 個
f((a, b)) # OK
</code></pre>
<p>函數類型<code>T -&gt; U</code>實際上是<code>(T,) -&gt; U</code>的語法糖</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="內置函數"><a class="header" href="#內置函數">內置函數</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/05_builtin_funcs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/05_builtin_funcs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="如果"><a class="header" href="#如果">如果</a></h2>
<p><code>if</code> 是一個根據條件改變處理的函數</p>
<pre><code class="language-python">result: Option Int = if! Bool.sample!(), do:
    log &quot;True was chosen&quot;
    1
print! result # None (or 1)
</code></pre>
<p><code>.sample!()</code> 返回一組隨機值。如果返回值為真，<code>print! &quot;真&quot;</code>被執行
如果條件為假，您還可以指定要執行的操作； 第二個 do 塊稱為 else 塊</p>
<pre><code class="language-python">result: Nat = if Bool.sample!():
    do:
        log &quot;True was chosen&quot;
        1
    do:
        log &quot;False was chosen&quot;
        0
print! result # 1 (or 0)
</code></pre>
<p>如果進程是單行，則可以省略縮進</p>
<pre><code class="language-python">result = if Bool.sample!():
    do 1
    do 0
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>你可以使用 <code>for</code> 來編寫一個重復的過程</p>
<pre><code class="language-python">match_s(ss: Iterator(Str), pat: Pattern): Option Str =
    for ss, s -&gt;
        if pat.match(s).is_some():
            break s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="運算符"><a class="header" href="#運算符">運算符</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/06_operator.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/06_operator.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>運算符是表示操作的符號。操作數是運算符(左)右側的東西</p>
<p>運算符是一種函數，因此它們本身就是可以綁定到變量的一流對象。綁定時，需要用```括起來
對于<code>+</code>(和<code>-</code>)，有一元和二元運算符，所以必須指定<code>_+_</code>(二元運算)/<code>+_</code>(一元運算)</p>
<pre><code class="language-python">add = `+` # 語法錯誤: 指定 `_+_` 或 `+_`
add=`_+_`
assert f(1, 2) == 3
assert f(&quot;a&quot;, &quot;b&quot;) == &quot;ab&quot;

g = `*` # OK, 這只是二進制
assert g(1, 2) == 2
</code></pre>
<p>一些稱為特殊形式的基本運算符不能被綁定</p>
<pre><code class="language-python">def = `=` # 語法錯誤: 無法綁定 `=` 運算符，這是一種特殊形式
# NG: def x, 1
function = `-&gt;` # 語法錯誤: 無法綁定 `-&gt;` 運算符，這是一種特殊形式
# NG: function x, x + 1
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="副作用和程序"><a class="header" href="#副作用和程序">副作用和程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/07_side_effect.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/07_side_effect.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>我們一直忽略了解釋&quot;！&quot;的含義，但現在它的含義終于要揭曉了。這個 <code>!</code> 表示這個對象是一個帶有&quot;副作用&quot;的&quot;過程&quot;。過程是具有副作用的函數</p>
<pre><code class="language-python">f x = print! x # EffectError: 不能為函數分配有副作用的對象
# 提示: 將名稱更改為 'f!'
</code></pre>
<p>上面的代碼會導致編譯錯誤。這是因為您在函數中使用了過程。在這種情況下，您必須將其定義為過程</p>
<pre><code class="language-python">p! x = print! x
</code></pre>
<p><code>p!</code>, <code>q!</code>, ... 是過程的典型變量名
以這種方式定義的過程也不能在函數中使用，因此副作用是完全隔離的</p>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>函數和過程中的每一個都可以是方法。函數式方法只能對<code>self</code>進行不可變引用，而程序性方法可以對<code>self</code>進行可變引用
<code>self</code> 是一個特殊的參數，在方法的上下文中是指調用對象本身。引用 <code>self</code> 不能分配給任何其他變量</p>
<pre><code class="language-python">C!.
    method ref self =
        x = self # 所有權錯誤: 無法移出`self`
        x
</code></pre>
<p>程序方法也可以采取 <code>self</code> 的 <a href="./18_ownership.html">ownership</a>。從方法定義中刪除 <code>ref</code> 或 <code>ref!</code></p>
<pre><code class="language-python">n = 1
s = n.into(Str) # '1'
n # 值錯誤: n 被 .into 移動(第 2 行)
</code></pre>
<p>在任何給定時間，只有一種程序方法可以具有可變引用。此外，在獲取可變引用時，不能從原始對象獲取更多可變引用。從這個意義上說，<code>ref!</code> 會對<code>self</code> 產生副作用</p>
<p>但是請注意，可以從可變引用創建(不可變/可變)引用。這允許在程序方法中遞歸和 <code>print!</code> 的<code>self</code></p>
<pre><code class="language-python">T -&gt; T # OK (move)
T -&gt; Ref T # OK (move)
T =&gt; Ref! T # OK (only once)
Ref T -&gt; T # NG
Ref T -&gt; Ref T # OK
Ref T =&gt; Ref!
T -&gt; Ref T # NG
T -&gt; Ref T # OK
T =&gt; Ref!
</code></pre>
<h2 id="附錄-副作用的嚴格定義"><a class="header" href="#附錄-副作用的嚴格定義">附錄: 副作用的嚴格定義</a></h2>
<p>代碼是否具有副作用的規則無法立即理解
直到你能理解它們，我們建議你暫時把它們定義為函數，如果出現錯誤，添加<code>！</code>將它們視為過程
但是，對于那些想了解該語言的確切規范的人，以下是對副作用的更詳細說明</p>
<p>首先，必須聲明返回值的等價與 Erg 中的副作用無關
有些過程對于任何給定的 <code>x</code> 都會導致 <code>p!(x) == p!(x)</code>(例如，總是返回 <code>None</code>)，并且有些函數會導致 <code>f(x) ！ = f(x)</code></p>
<p>前者的一個例子是<code>print!</code>，后者的一個例子是下面的函數</p>
<pre><code class="language-python">nan _ = Float.NaN
assert nan(1) ! = nan(1)
</code></pre>
<p>還有一些對象，例如類，等價確定本身是不可能的</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}
assert T == U

C = Class {i = Int}
D = Class {i = Int}
assert C == D # 類型錯誤: 無法比較類
</code></pre>
<p>言歸正傳: Erg 中&quot;副作用&quot;的準確定義是</p>
<ul>
<li>訪問可變的外部信息</li>
</ul>
<p>&quot;外部&quot;一般是指外部范圍； Erg 無法觸及的計算機資源和執行前/執行后的信息不包含在&quot;外部&quot;中。&quot;訪問&quot;包括閱讀和寫作</p>
<p>例如，考慮 <code>print!</code> 過程。乍一看，<code>print!</code> 似乎沒有重寫任何變量。但如果它是一個函數，它可以重寫外部變量，例如，使用如下代碼: </p>
<pre><code class="language-python">camera = import &quot;some_camera_module&quot;
ocr = import &quot;some_ocr_module&quot;

n = 0
_ =
    f x = print x # 假設我們可以使用 print 作為函數
    f(3.141592)
cam = camera.new() # 攝像頭面向 PC 顯示器
image = cam.shot!()
n = ocr.read_num(image) # n = 3.141592
</code></pre>
<p>將&quot;camera&quot;模塊視為為特定相機產品提供 API 的外部庫，將&quot;ocr&quot;視為用于 OCR(光學字符識別)的庫
直接的副作用是由 <code>cam.shot!()</code> 引起的，但顯然這些信息是從 <code>f</code> 泄露的。因此，<code>print!</code> 本質上不可能是一個函數</p>
<p>然而，在某些情況下，您可能希望臨時檢查函數中的值，而不想為此目的在相關函數中添加 <code>!</code>。在這種情況下，可以使用 <code>log</code> 函數
<code>log</code> 打印整個代碼執行后的值。這樣，副作用就不會傳播</p>
<pre><code class="language-python">log &quot;this will be printed after execution&quot;
print! &quot;this will be printed immediately&quot;
# 這將立即打印
# 這將在執行后打印
</code></pre>
<p>如果沒有反饋給程序，或者換句話說，如果沒有外部對象可以使用內部信息，那么信息的&quot;泄漏&quot;是可以允許的。只需要不&quot;傳播&quot;信息</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="程序"><a class="header" href="#程序">程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/08_procedure.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/08_procedure.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>處理可變對象時需要過程，但將可變對象作為參數并不一定使其成為過程
這是一個函數接受一個可變對象(不是過程)</p>
<pre><code class="language-python">peek_str s: Str! = log s
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="內置程序"><a class="header" href="#內置程序">內置程序</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/09_builtin_procs.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/09_builtin_procs.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="id"><a class="header" href="#id">id！</a></h2>
<p>返回對象的唯一標識號
盡管在純 Erg 語義中，結構相同的對象之間沒有區別，但實際上對象在內存中具有不同的位置
<code>id!</code> 返回一個代表這個位置的數字</p>
<pre><code class="language-python"></code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/10_array.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/10_array.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>數組是最基本的__collection(聚合)__
集合是一個可以在其中包含多個對象的對象</p>
<pre><code class="language-python">a = [1, 2, 3]
a: [Int; 3] # 類型說明: 分號后的數字為元素個數
# 如果元素個數未知，可以省略
a: [Int]

mut_a = [!1, !2, !3]
mut_a[0].inc!()
assert mut_a == [2, 2, 3]
</code></pre>
<p>通常，數組不能包含不同類型的對象</p>
<pre><code class="language-python.">[1, &quot;a&quot;] # 類型錯誤: 第一個元素是 Int，但第二個元素是 Str
</code></pre>
<p>但是，您可以通過像這樣顯式指定類型來繞過限制</p>
<pre><code class="language-python">[1, &quot;a&quot;]: [Int or Str].
</code></pre>
<h2 id="切片"><a class="header" href="#切片">切片</a></h2>
<p>一個數組也可以同時取出多個值。這稱為切片</p>
<pre><code class="language-python">l = [1, 2, 3, 4]
# 與 Python 中的 l[1:3] 相同
assert l[1.. &lt;3] == [2, 3]
assert l[1..2] == [2, 3]
# 與 l[1] 相同
assert l[1..1] == [2]
# 與 Python 中的 l[::2] 相同
assert l[..].step(2) == [2, 4]
</code></pre>
<p>通過切片獲得的對象是數組的(不可變的)副本</p>
<pre><code class="language-python">print! Typeof l[1..2] # [Int; 4]
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="元組"><a class="header" href="#元組">元組</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/11_tuple.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/11_tuple.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>元組類似于數組，但可以保存不同類型的對象
這樣的集合稱為不等集合。相比之下，同構集合包括數組、集合等</p>
<pre><code class="language-python">t = (1, True, &quot;a&quot;)
(i, b, s) = t
assert(i == 1 and b == True and s == &quot;a&quot;)
</code></pre>
<p>元組<code>t</code>可以以<code>t.n</code>的形式檢索第n個元素； 請注意，與 Python 不同，它不是 <code>t[n]</code>
這是因為訪問元組元素更像是一個屬性(在編譯時檢查元素的存在，并且類型可以根據 <code>n</code> 改變)而不是方法(數組的 <code>[]</code> 是一種方法)</p>
<pre><code class="language-python">assert t.0 == 1
assert t.1 == True
assert t.2 == &quot;a&quot;
</code></pre>
<p>括號 <code>()</code> 在不嵌套時是可選的</p>
<pre><code class="language-python">t = 1, True, &quot;a&quot;
i, b, s = t
</code></pre>
<p>元組可以保存不同類型的對象，因此它們不能像數組一樣被迭代</p>
<pre><code class="language-python">t: ({1}, {2}, {3}) = (1, 2, 3)
(1, 2, 3).iter().map(x -&gt; x + 1) # 類型錯誤: 類型 ({1}, {2}, {3}) 沒有方法 `.iter()`
# 如果所有類型都相同，則可以像數組一樣用`(T; n)`表示，但這仍然不允許迭代
t: (Int; 3) = (1, 2, 3)
assert (Int; 3) == (Int, Int, Int)
</code></pre>
<p>但是，非同質集合(如元組)可以通過向上轉換、相交等方式轉換為同質集合(如數組)
這稱為均衡</p>
<pre><code class="language-python">(Int, Bool, Str) can be [T; 3] where T :&gt; Int, T :&gt; Bool, T :&gt; Str
</code></pre>
<pre><code class="language-python">t: (Int, Bool, Str) = (1, True, &quot;a&quot;) # 非同質
a: [Int or Bool or Str; 3] = [1, True, &quot;a&quot;] # 同質的
_a: [Show; 3] = [1, True, &quot;a&quot;] # 同質的
_a.iter().map(x -&gt; log x) # OK
t.try_into([Show; 3])? .iter().map(x -&gt; log x) # OK
</code></pre>
<h2 id="單元"><a class="header" href="#單元">單元</a></h2>
<p>零元素的元組稱為 <strong>unit</strong>。一個單元是一個值，但也指它自己的類型</p>
<pre><code class="language-python">unit = ()
(): ()
</code></pre>
<p>Unit 是所有元素 0 元組的父類</p>
<pre><code class="language-python">() &gt; (Int; 0)
() &gt; (Str; 0)
</code></pre>
<p>該對象的用途是用于沒有參數和沒有返回值的過程等。Erg 子例程必須有參數和返回值。但是，在某些情況下，例如過程，可能沒有有意義的參數或返回值，只有副作用。在這種情況下，我們將單位用作&quot;無意義的正式值&quot;</p>
<pre><code class="language-python"># ↓ Actually, this parenthesis is a unit
p!() =.
    # `print!` does not return a meaningful value
    print! &quot;Hello, world!&quot;
p!: () =&gt; ()
</code></pre>
<p>但是，在這種情況下，Python 傾向于使用&quot;無&quot;而不是單位
在 Erg 中，當您從一開始就確定操作不會返回有意義的值(例如在過程中)時，您應該使用 <code>()</code>，并且當操作可能失敗并且您可能會返回 <code>None</code> 將一無所獲，例如在檢索元素時</p>
<h2 id="參數和元組"><a class="header" href="#參數和元組">參數和元組</a></h2>
<p>實際上，Erg 的所有 <code>Callable</code> 對象都是一個參數和一個返回值； 一個接受 N 個參數的子例程只是接收&quot;一個具有 N 個元素的元組&quot;作為參數</p>
<pre><code class="language-python"># f x = ... 被隱式假設為 f(x) = ... 被認為是
f x = x
assert f(1) == 1
f(1, 2, 3) # 參數錯誤: f 接受 1 個位置參數，但給出了 3 個
g x: Int, . . y: Int = y
assert (2, 3) == g 1, 2, 3
</code></pre>
<p>這也解釋了函數類型</p>
<pre><code class="language-python">assert f in T: {(T,) -&gt; T | T}
assert g in {(Int, ... (Int; N)) -&gt; (Int; N) | N: Nat}
</code></pre>
<p>準確地說，函數的輸入不是元組，而是&quot;具有默認屬性的命名元組&quot;。這是一個特殊的元組，只能在函數參數中使用，可以像記錄一樣命名，并且可以有默認值</p>
<pre><code class="language-python">f(x: Int, y=0) = x + y
f: (Int, y=Int) -&gt; Int

f(x=0, y=1)
f(y=1, x=0)
f(x=0)
f(0)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="字典"><a class="header" href="#字典">字典</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/12_dict.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/12_dict.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Dict 是鍵/值對的集合</p>
<pre><code class="language-python">ids = {&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301}
assert ids[&quot;Alice&quot;] == 145
</code></pre>
<p>如果鍵是&quot;哈希&quot;對象，則鍵不必是字符串</p>
<pre><code class="language-python"># 不推薦使用范圍對象作為鍵(與切片混淆)
r = {1..3: &quot;1~3&quot;, 4..6: &quot;4~6&quot;, 7..9: &quot;7~9&quot;}
assert r[1..3] == &quot;1~3&quot;
l = {[]: &quot;empty&quot;, [1]: &quot;1&quot;}
assert l[[]] == &quot;empty&quot;
</code></pre>
<p>對于字典來說，順序無關緊要。它也不能有重復的元素。在這方面，Dict 與 Set 類似
您可以說 Dict 是具有值的 Set</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Bob&quot;: 214, &quot;Charlie&quot;: 301} == {&quot;Alice&quot;: 145, &quot;Charlie&quot;: 301, &quot;Bob&quot;: 214}
</code></pre>
<p>從 dict 文字生成 dict 時，會檢查重復鍵
任何重復都會導致編譯錯誤</p>
<pre><code class="language-python">{&quot;Alice&quot;: 145, &quot;Alice&quot;: 1} # Key錯誤: 重復鍵`Alice`
</code></pre>
<p>空字典是用 <code>{:}</code> 創建的。請注意，<code>{}</code> 表示一個空集</p>
<pre><code class="language-python">mut_dict = !{:}
mut_dict.insert! &quot;Alice&quot;, 145
mut_dict.insert! &quot;Bob&quot;, 214
assert mut_dict[&quot;Alice&quot;] == 145
</code></pre>
<h2 id="異構字典"><a class="header" href="#異構字典">異構字典</a></h2>
<p>不需要有單一的鍵/值類型。這樣的字典稱為 _<em>heterogenous dict</em></p>
<pre><code class="language-python">d: {Str: Int, Int: Str} = {&quot;a&quot;: 1, 1: &quot;a&quot;}
assert d[&quot;a&quot;] == 1
assert d[1] == &quot;a&quot;
</code></pre>
<p>但是，不能將相同類型的值分配給不同類型的鍵，或者將不同類型的值分配給相同類型的鍵
在這種情況下，請改用 Or 類型</p>
<pre><code class="language-python">invalid1 = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
invalid2 = {1: &quot;a&quot;, 2: 2}

# Erg 類型推斷不推斷 Or 類型，因此需要類型說明
valid1: {Int or Str: Str} = {1: &quot;a&quot;, &quot;a&quot;: &quot;b&quot;}
valid2: {Int: Int or Str} = {1: &quot;a&quot;, 2: 2}
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="記錄record"><a class="header" href="#記錄record">記錄(Record)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/13_record.md&amp;commit_hash=00350f64a40b12f763a605bc16748d09379ab182"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/13_record.md%26commit_hash%3D00350f64a40b12f763a605bc16748d09379ab182" alt="badge" /></a></p>
<p>記錄是一個集合，它結合了通過鍵訪問的 Dict 和在編譯時檢查其訪問的元組的屬性
如果您了解 JavaScript，請將其視為一種(更增強的)對象字面量表示法</p>
<pre><code class="language-python">john = {.name = &quot;John&quot;; .age = 21}

assert john.name == &quot;John&quot;
assert john.age == 21
assert john in {.name = Str; .age = Nat}
john[&quot;name&quot;] # 錯誤: john 不可訂閱
</code></pre>
<p><code>.name</code> 和 <code>.age</code> 部分稱為屬性，而 <code>&quot;John&quot;</code> 和 <code>21</code> 部分稱為屬性值</p>
<p>與 JavaScript 對象字面量的區別在于它們不能作為字符串訪問。也就是說，屬性不僅僅是字符串
這是因為對值的訪問是在編譯時確定的，而且字典和記錄是不同的東西。換句話說，<code>{&quot;name&quot;: &quot;John&quot;}</code> 是一個字典，<code>{name = &quot;John&quot;}</code> 是一個記錄
那么我們應該如何使用字典和記錄呢?
一般來說，我們建議使用記錄。記錄具有在編譯時檢查元素是否存在以及能夠指定 _<em>visibility</em> 的優點
指定可見性等同于在 Java 和其他語言中指定公共/私有。有關詳細信息，請參閱 <a href="./19_visibility.html">可見性</a> 了解詳細信息</p>
<pre><code class="language-python">a = {x = 1; .y = x + 1}
a.x # 屬性錯誤: x 是私有的
# 提示: 聲明為 `.x`
assert a.y == 2
</code></pre>
<p>對于熟悉 JavaScript 的人來說，上面的示例可能看起來很奇怪，但簡單地聲明 <code>x</code> 會使其無法從外部訪問</p>
<p>您還可以顯式指定屬性的類型</p>
<pre><code class="language-python">anonymous = {
    .name: Option! Str = !
    .age = 20
}
anonymous.name.set! &quot;John&quot;
</code></pre>
<p>一個記錄也可以有方法</p>
<pre><code class="language-python">o = {
    .i = !0
    .inc! ref! self = self.i.inc!()
}

assert o.i == 0
o.inc!()
assert o.i == 1
</code></pre>
<p>關于記錄有一個值得注意的語法。當記錄的所有屬性值都是類(不是結構類型)時，記錄本身表現為一個類型，其自身的屬性作為必需屬性
這種類型稱為記錄類型。有關詳細信息，請參閱 [記錄] 部分</p>
<pre><code class="language-python"># 記錄
john = {.name = &quot;John&quot;}
# 記錄 type
john: {.name = Str}
Named = {.name = Str}
john: Named

greet! n: Named =
    print! &quot;Hello, I am {n.name}&quot;
john # &quot;你好，我是約翰 print！

Named.name # Str
</code></pre>
<h2 id="解構記錄"><a class="header" href="#解構記錄">解構記錄</a></h2>
<p>記錄可以按如下方式解構</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x = a; y = b} = record
assert a == 1
assert b == 2

point = {x = 2; y = 3; z = 4}
match point:
    {x = 0; y = 0; z = 0} -&gt; &quot;origin&quot;
    {x = _; y = 0; z = 0} -&gt; &quot;on the x axis&quot;
    {x = 0; ...} -&gt; &quot;x = 0&quot;
    {x = x; y = y; z = z} -&gt; &quot;({x}, {y}, {z})&quot;
</code></pre>
<p>當存在與屬性同名的變量時，<code>x = ...</code>也可以縮寫為<code>x</code>，例如<code>x = x</code>或<code>x = .x</code>到<code>x</code>，和<code> .x = .x</code> 或 <code>.x = x</code> 到 <code>.x</code>
但是，當只有一個屬性時，必須在其后加上<code>;</code>以與集合區分開來</p>
<pre><code class="language-python">x = 1
y = 2
xy = {x; y}
a = 1
b = 2
ab = {.a; .b}
assert ab.a == 1
assert ab.b == 2

record = {x;}
tuple = {x}
assert tuple.1 == 1
</code></pre>
<p>此語法可用于解構記錄并將其分配給變量</p>
<pre><code class="language-python"># 一樣 `{x = x; y = y} = xy`
{x; y} = xy
assert x == 1
assert y == 2
# 一樣 `{.a = a; .b = b} = ab`
{a; b} = ab
assert a == 1
assert b == 2
</code></pre>
<h2 id="空記錄"><a class="header" href="#空記錄">空記錄</a></h2>
<p>空記錄由<code>{=}</code>表示。空記錄也是它自己的類，如 Unit</p>
<pre><code class="language-python">empty_record = {=}
empty_record: {=}
# Object: Type = {=}
empty_record: Object
empty_record: Structural {=}
{x = 3; y = 5}: Structural {=}
</code></pre>
<p>空記錄不同于空 Dict <code>{:}</code> 或空集 <code>{}</code>。特別要注意的是，它與 <code>{}</code> 的含義相反(在 Python 中，<code>{}</code> 是一個空字典，而在 Erg 中它是 Erg 中的 <code>!{:}</code>)
作為枚舉類型，<code>{}</code> 是一個空類型，其元素中不包含任何內容。<code>Never</code> 類型是這種類型的一個分類
相反，記錄類 <code>{=}</code> 沒有必需的實例屬性，因此所有對象都是它的元素。<code>Object</code> 是 this 的別名
一個<code>Object</code>(<code>Object</code>的一個補丁)是<code>的一個元素。__sizeof__</code> 和其他非常基本的提供方法</p>
<pre><code class="language-python">AnyPatch = Patch Structural {=}
    . __sizeof__ self = ...
    .clone self = ...
    ...
Never = Class {}
</code></pre>
<p>請注意，沒有其他類型或類在結構上與 <code>{}</code>、<code>Never</code> 類型等效，如果用戶在右側使用 <code>{}</code>、<code>Class {}</code> 定義類型，則會出錯
這意味著，例如，<code>1..10 或 -10。-1</code>，但 <code>1..10 和 -10... -1</code>。例如，當它應該是 1..10 或 -10...-1 時是 <code>-1</code>
此外，如果您定義的類型(例如 <code>Int 和 Str</code>)會導致組合 <code>Object</code>，則會警告您只需將其設置為 <code>Object</code></p>
<h2 id="即時封鎖"><a class="header" href="#即時封鎖">即時封鎖</a></h2>
<p>Erg 有另一種語法 Instant 塊，它只返回最后評估的值。不能保留屬性</p>
<pre><code class="language-python">x =
    x = 1
    y = x + 1
    y ** 3
assert x == 8

y =
    .x = 1 # 語法錯誤: 無法在實體塊中定義屬性
</code></pre>
<h2 id="數據類"><a class="header" href="#數據類">數據類</a></h2>
<p>如果您嘗試自己實現方法，則必須直接在實例中定義裸記錄(由記錄文字生成的記錄)
這是低效的，并且隨著屬性數量的增加，錯誤消息等變得難以查看和使用</p>
<pre><code class="language-python">john = {
    name = &quot;John Smith&quot;
    age = !20
    .greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    .inc_age! ref! self = self::age.update! x -&gt; x + 1
}
john + 1
# 類型錯誤: {name = Str; 沒有實現 + 年齡=詮釋； 。迎接！ =參考(自我)。() =&gt; 無； inc_age！ =參考！ () =&gt; 無}, 整數
</code></pre>
<p>因此，在這種情況下，您可以繼承一個記錄類。這樣的類稱為數據類
這在 <a href="./type/04_class.html">class</a> 中有描述</p>
<pre><code class="language-python">Person = Inherit {name = Str; age = Nat}
Person.
    greet! ref self = print! &quot;Hello, my name is {self::name} and I am {self::age} years old.&quot;
    inc_age! ref! self = self::age.update! x -&gt; x + 1

john = Person.new {name = &quot;John Smith&quot;; age = 20}
john + 1
# 類型錯誤: Person、Int 沒有實現 +
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="set"><a class="header" href="#set">Set</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/14_set.md&amp;commit_hash=b07c17708b9141bbce788d2e5b3ad4f365d342fa"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/14_set.md%26commit_hash%3Db07c17708b9141bbce788d2e5b3ad4f365d342fa" alt="badge" /></a></p>
<p>一個Set代表一個集合，它在結構上是一個重復的無序數組</p>
<pre><code class="language-python">assert Set.from([1, 2, 3, 2, 1]) == {1, 2, 3}
assert {1, 2} == {1, 1, 2} # 重復的被自動刪除
assert {1, 2} == {2, 1}
</code></pre>
<p>它也可以用類型和長度來聲明</p>
<pre><code class="language-python">a: {Int; 3} = {0, 1, 2} # OK
b: {Int; 3} = {0, 0, 0} # NG，重復的內容被刪除，長度也會改變
# [
TypeError: the type of b is mismatched
expected:  Set(Int, 3)
but found: Set({0, }, 1)
]# 
</code></pre>
<p>此外，只有實現<code>Eq</code>跟蹤的對象才能成為集合的元素</p>
<p>因此，不可能使用Floats等作為集合元素</p>
<pre><code class="language-python">d = {0.0, 1.0} # NG
# [
1│ d = {0.0, 1.0}
        ^^^^^^^^
TypeError: the type of _ is mismatched:
expected:  Eq(Float)
but found: {0.0, 1.0, }
]# 
</code></pre>
<p>Set可以執行集合操作</p>
<pre><code class="language-python">assert 1 in {1, 2, 3}
assert not 1 in {}
assert {1} or {2} == {1, 2}
assert {1, 2} and {2, 3} == {2}
assert {1, 2} not {2} == {1}
</code></pre>
<p>Set是同質集合。為了使不同類的對象共存，它們必須同質化</p>
<pre><code class="language-python">s: {Int or Str} = {&quot;a&quot;, 1, &quot;b&quot;, -1}
</code></pre>
<h2 id="sets為類型"><a class="header" href="#sets為類型">Sets為類型</a></h2>
<p>Sets也可以被視為類型。這種類型稱為 <em>枚舉類型</em></p>
<pre><code class="language-python">i: {1, 2, 3} = 1
assert i in {1, 2, 3}
</code></pre>
<p>Set的元素直接是類型的元素
請注意，這些Set本身是不同的</p>
<pre><code class="language-python">mut_set = {1, 2, 3}.into {Int; !3}
mut_set.insert!(4)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型"><a class="header" href="#類型">類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/15_type.md&amp;commit_hash=d15cbbf7b33df0f78a575cff9679d84c36ea3ab1"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/15_type.md%26commit_hash%3Dd15cbbf7b33df0f78a575cff9679d84c36ea3ab1" alt="badge" /></a></p>
<p>類型是 Erg 中一個非常重要的特性，所以我們有一個 <a href="./type/01_type_system.html">dedicated section</a>。請看那里</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erg-的類型系統"><a class="header" href="#erg-的類型系統">Erg 的類型系統</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/01_type_system.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/01_type_system.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>下面簡單介紹一下 Erg 的類型系統。詳細信息在其他部分進行說明</p>
<h2 id="如何定義"><a class="header" href="#如何定義">如何定義</a></h2>
<p>Erg 的獨特功能之一是(普通)變量、函數(子例程)和類型(Kind)定義之間的語法沒有太大區別。所有都是根據普通變量和函數定義的語法定義的</p>
<pre><code class="language-python">f i: Int = i + 1
f # &lt;函數 f&gt;
f(1) # 2
f.method self = ... # 語法錯誤: 無法為子例程定義方法

T I: Int = {...}
T # &lt;kind 'T'&gt;
T(1) # 類型 T(1)
T.method self = ...
D = Class {private = Int; .public = Int}
D # &lt;類 'D'&gt;
o1 = {private = 1; .public = 2} # o1 是一個不屬于任何類的對象
o2 = D.new {private = 1; .public = 2} # o2 是 D 的一個實例
o2 = D.new {.public = 2} # 初始化錯誤: 類 'D' 需要屬性 'private'(: Int) 但未定義
</code></pre>
<h2 id="classification"><a class="header" href="#classification">Classification</a></h2>
<p>Erg 中的所有對象都是強類型的
頂層類型是<code>{=}</code>，實現了<code>__repr__</code>、<code>__hash__</code>、<code>clone</code>等(不是必須的方法，這些屬性不能被覆蓋)
Erg 的類型系統包含結構子類型 (SST)。該系統類型化的類型稱為結構類型
結構類型主要分為三種: Attributive(屬性類型)、Refinement(細化類型)和Algebraic(代數類型)</p>
<table><thead><tr><th></th><th>Record</th><th>Enum</th><th>Interval</th><th>Union</th><th>Intersection</th><th>Diff</th></tr></thead><tbody>
<tr><td>kind</td><td>Attributive</td><td>Refinement</td><td>Refinement</td><td>Algebraic</td><td>Algebraic</td><td>Algebraic</td></tr>
<tr><td>generator</td><td>record</td><td>set</td><td>range operator</td><td>or operator</td><td>and operator</td><td>not operator</td></tr>
</tbody></table>
<p>也可以使用名義子類型(NST)，將 SST 類型轉換為 NST 類型稱為類型的名義化。結果類型稱為名義類型
在 Erg 中，名義類型是類和Trait。當我們簡單地說類/Trait時，我們通常指的是記錄類/Trait</p>
<table><thead><tr><th></th><th>Type</th><th>Abstraction</th><th>Subtyping procedure</th></tr></thead><tbody>
<tr><td>NST</td><td>NominalType</td><td>Trait</td><td>Inheritance</td></tr>
<tr><td>SST</td><td>StructuralType</td><td>Structural Trait</td><td>(Implicit)</td></tr>
</tbody></table>
<p>整個名義類型的類型(<code>NominalType</code>)和整個結構類型的類型(<code>StructuralType</code>)是整個類型(<code>Type</code>)的類型的子類型</p>
<p>Erg 可以將參數(類型參數)傳遞給類型定義。帶有類型參數的 <code>Option</code>、<code>Array</code> 等稱為多項式類型。這些本身不是類型，但它們通過應用參數成為類型。諸如 <code>Int</code>、<code>Str</code> 等沒有參數的類型稱為簡單類型(標量類型)</p>
<p>一個類型可以看成一個集合，并且存在包含關系。例如，&quot;Num&quot;包含&quot;Add&quot;、&quot;Sub&quot;等，&quot;Int&quot;包含&quot;Nat&quot;
所有類的上類是<code>Object == Class {:}</code>，所有類型的下類是<code>Never == Class {}</code>。這在下面描述</p>
<h2 id="類型-1"><a class="header" href="#類型-1">類型</a></h2>
<p>像 <code>Array T</code> 這樣的類型可以看作是 <code>Type -&gt; Type</code> 類型的函數，它以 <code>T</code> 類型為參數并返回 <code>Array T</code> 類型(在類型論中也稱為 Kind)。像 <code>Array T</code> 這樣的類型專門稱為多態類型，而 <code>Array</code> 本身稱為一元 Kind</p>
<p>已知參數和返回類型的函數的類型表示為<code>(T, U) -&gt; V</code>。如果要指定同一類型的整個雙參數函數，可以使用 <code>|T| (T, T) -&gt; T</code>，如果要指定整個 N 參數函數，可以使用 <code>Func N</code>。但是，<code>Func N</code> 類型沒有關于參數數量或其類型的信息，因此所有返回值在調用時都是<code>Obj</code> 類型</p>
<p><code>Proc</code> 類型表示為 <code>() =&gt; Int</code> 等等。此外，<code>Proc</code> 類型實例的名稱必須以 <code>!</code> 結尾</p>
<p><code>Method</code> 類型是一個函數/過程，其第一個參數是它所屬的對象 <code>self</code>(通過引用)。對于依賴類型，也可以在應用方法后指定自己的類型。這是 <code>T!(!N)</code> 類型和 <code>T!(N ~&gt; N-1)。() =&gt; Int</code> 等等</p>
<p>Erg 的數組(Array)就是 Python 所說的列表。<code>[詮釋; 3]</code>是一個數組類，包含三個<code>Int</code>類型的對象</p>
<blockquote>
<p><strong>Note</strong>: <code>(Type; N)</code> 既是類型又是值，所以可以這樣使用</p>
<pre><code class="language-python.">Types = (Int, Str, Bool)

for! Types, T =&gt;
    print! T
# Int Str Bool
a: Types = (1, &quot;aaa&quot;, True)
</code></pre>
</blockquote>
<pre><code class="language-python">pop|T, N|(l: [T; N]): ([T; N-1], T) =
    [...l, last] = l
    (l, last)

lpop|T, N|(l: [T; N]): (T, [T; N-1]) =
    [first, ...l] = l
    (first, l)
</code></pre>
<p>以 <code>!</code> 結尾的類型可以重寫內部結構。例如，<code>[T; !N]</code> 類是一個動態數組
要從&quot;T&quot;類型的對象創建&quot;T!&quot;類型的對象，請使用一元運算符&quot;!&quot;</p>
<pre><code class="language-python">i: Int! = !1
i.update! i -&gt; i + 1
assert i == 2
arr = [1, 2, 3]
arr.push! 4 # 導入錯誤
mut_arr = [1, 2, 3].into [Int; !3]
mut_arr.push4
assert mut_arr == [1, 2, 3, 4].
</code></pre>
<h2 id="類型定義"><a class="header" href="#類型定義">類型定義</a></h2>
<p>類型定義如下</p>
<pre><code class="language-python">Point2D = {.x = Int; .y = Int}
</code></pre>
<p>請注意，如果從變量中省略 <code>.</code>，它將成為類型中使用的私有變量。但是，這也是必需的屬性
由于類型也是對象，因此類型本身也有屬性。這樣的屬性稱為類型屬性。在類的情況下，它們也稱為類屬性</p>
<h2 id="數據類型"><a class="header" href="#數據類型">數據類型</a></h2>
<p>如前所述，Erg 中的&quot;類型&quot;大致表示一組對象</p>
<p>下面是 <code>Add</code> 類型的定義，需要 <code>+</code>(中間運算符)。<code>R, O</code> 是所謂的類型參數，可以是真正的類型(類)，例如 <code>Int</code> 或 <code>Str</code>。在其他語言中，類型參數被賦予特殊的符號(泛型、模板等)，但在 Erg 中，它們可以像普通參數一樣定義
類型參數也可以用于類型對象以外的類型。例如數組類型<code>[Int; 3]</code> 是 <code>Array Int, 3</code> 的語法糖。如果類型實現重疊，用戶必須明確選擇一個</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}
</code></pre>
<p>.<code>_+_</code>是Add.<code>_+_</code>的縮寫。前綴運算符 .<code>+_</code> 是 <code>Num</code> 類型的方法</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
NumImpl = Patch Num
NumImpl.
    `+_`(self): Self = self
    ...
</code></pre>
<p>多態類型可以像函數一樣對待。通過將它們指定為 <code>Mul Int、Str</code> 等，它們可以是單態的(在許多情況下，它們是用實際參數推斷出來的，而沒有指定它們)</p>
<pre><code class="language-python">1 + 1
`_+_` 1, 1
Nat.`_+_` 1, 1
Int.`_+_` 1, 1
</code></pre>
<p>前四行返回相同的結果(準確地說，底部的返回 <code>Int</code>)，但通常使用頂部的
<code>Ratio.</code><em>+</em><code>(1, 1)</code> 將返回 <code>2.0</code> 而不會出錯
這是因為 <code>Int &lt;: Ratio</code>，所以 <code>1</code> 向下轉換為 <code>Ratio</code>
但這不是演員</p>
<pre><code class="language-python">i = 1
if i: # 類型錯誤: i: Int 不能轉換為 Bool，請改用 Int.is_zero()
    log &quot;a&quot;
    log &quot;b&quot;
</code></pre>
<p>這是因為 <code>Bool &lt;: Int</code> (<code>True == 1</code>, <code>False == 0</code>)。轉換為子類型通常需要驗證</p>
<h2 id="類型推理系統"><a class="header" href="#類型推理系統">類型推理系統</a></h2>
<p>Erg 使用靜態鴨子類型，因此幾乎不需要顯式指定類型</p>
<pre><code class="language-python">f x, y = x + y
</code></pre>
<p>在上面的代碼中，帶有 <code>+</code> 的類型，即 <code>Add</code> 是自動推斷的； Erg 首先推斷出最小的類型。如果<code>f 0, 1</code>，它將推斷<code>f x: {0}，y: {1}</code>，如果<code>n: Nat; f n, 1</code>，它會推斷<code>f x: Nat, y: {1}</code>。最小化之后，增加類型直到找到實現。在 <code>{0}, {1}</code> 的情況下，<code>Nat</code> 與 <code>Nat</code> 是單態的，因為 <code>Nat</code> 是具有 <code>+</code> 實現的最小類型
如果是 <code>{0}, {-1}</code>，它與 <code>Int</code> 是單態的，因為它不匹配 <code>Nat</code>。如果子類型和超類型之間沒有關系，則首先嘗試具有最低濃度(實例數)(或者在多態類型的情況下參數更少)的那個
<code>{0}</code> 和 <code>{1}</code> 是枚舉類型，它們是部分類型，例如 <code>Int</code> 和 <code>Nat</code>
例如，可以為枚舉類型指定名稱和請求/實現方法。在有權訪問該類型的命名空間中，滿足請求的對象可以使用實現方法</p>
<pre><code class="language-python">Binary = Patch {0, 1}
Binary.
    # self 包含一個實例。在此示例中，為 0 或 1
    # 如果你想重寫self，你必須追加！ 必須添加到類型名稱和方法名稱
    is_zero(self) = match self:
        0 -&gt; True
        1 -&gt; False # 你也可以使用 _ -&gt; False
    is_one(self) = not self.is_zero()
    to_bool(self) = match self:
        0 -&gt; False
        1 -&gt; True
</code></pre>
<p>此后，代碼&quot;0.to_bool()&quot;是可能的(盡管&quot;0 as Bool == False&quot;是內置定義的)
這是一個實際上可以重寫 <code>self</code> 的類型的示例，如代碼所示</p>
<pre><code class="language-python">Binary! = Patch {0, 1}!
Binary!
    switch! ref! self = match! self:
        0 =&gt; self = 1
        1 =&gt; self = 0

b = !1
b.switch!()
print! b # =&gt; 0
</code></pre>
<h2 id="結構類型匿名類型"><a class="header" href="#結構類型匿名類型">結構類型(匿名類型)</a></h2>
<pre><code class="language-python">Binary = {0, 1}
</code></pre>
<p>上面代碼中的 <code>Binary</code> 是一個類型，其元素是 <code>0</code> 和 <code>1</code>。它也是 <code>Int</code> 類型的子類型，它同時具有 <code>0</code> 和 <code>1</code>
像 <code>{}</code> 這樣的對象本身就是一種類型，可以在分配或不分配給上述變量的情況下使用
這樣的類型稱為結構類型。當我們想強調它作為后者而不是類(命名類型)的用途時，它也被稱為未命名類型。<code>{0, 1}</code>這樣的結構類型稱為枚舉類型，還有區間類型、記錄類型等</p>
<h3 id="類型標識"><a class="header" href="#類型標識">類型標識</a></h3>
<p>無法指定以下內容。例如，您不能指定 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code> 和 <code>Int</code>
例如，<code>Int</code>和<code>Str</code>都是<code>Add</code>，但是<code>Int</code>和<code>Str</code>不能相加</p>
<pre><code class="language-python">add l: Add, r: Add =
    l + r # 類型錯誤: `_+_` 沒有實現: |T, U &lt;: Add| (T, U) -&gt; &lt;失敗&gt;
</code></pre>
<p>此外，下面的類型 <code>A</code> 和 <code>B</code> 不被認為是同一類型。但是，類型&quot;O&quot;被認為是匹配的</p>
<pre><code class="language-python">... |R1; R2; O; A &lt;: Add(R1, O); B &lt;: Add(R2, O)|
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="類型的基本語法"><a class="header" href="#類型的基本語法">類型的基本語法</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/02_basic.md&amp;commit_hash=a0c1380a6fa5236518ac4ff455edbd3af50b0560"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/02_basic.md%26commit_hash%3Da0c1380a6fa5236518ac4ff455edbd3af50b0560" alt="badge" /></a></p>
<h2 id="類型規范"><a class="header" href="#類型規范">類型規范</a></h2>
<p>在 Erg 中，可以在 <code>:</code> 之后指定變量的類型，如下所示。這可以與作業同時完成</p>
<pre><code class="language-python">i: Int # 將變量 i 聲明為 Int 類型
i: Int = 1
j = 1 # 類型說明可以省略
</code></pre>
<p>您還可以指定普通表達式的類型</p>
<pre><code class="language-python">i = 1: Int
f([1, &quot;a&quot;]: [Int or Str])
</code></pre>
<p>對于簡單的變量賦值，大多數類型說明可以省略
在定義子例程和類型時，類型規范更有用</p>
<pre><code class="language-python"># 參數的類型規范
f x, y: Array Int = ...
T X, Y: Array Int = ...
</code></pre>
<p>請注意，在上述情況下，<code>x, y</code> 都是 <code>Array Int</code></p>
<pre><code class="language-python"># 大寫變量的值必須是常量表達式
f X: Int = X
</code></pre>
<p>或者，如果你不需要關于類型參數的完整信息，你可以用 <code>_</code> 省略它</p>
<pre><code class="language-python">g v: [T; _] = ...
</code></pre>
<p>但是請注意，類型規范中的 <code>_</code> 意味著 <code>Object</code></p>
<pre><code class="language-python">f x: _, y: Int = x + y # 類型錯誤: Object 和 Int 之間沒有實現 +
</code></pre>
<h2 id="子類型規范"><a class="header" href="#子類型規范">子類型規范</a></h2>
<p>除了 <code>:</code>(類型聲明運算符)，Erg 還允許您使用 <code>&lt;:</code>(部分類型聲明運算符)來指定類型之間的關系
<code>&lt;:</code> 的左邊只能指定一個類。使用 <code>Subtypeof</code> 或類似的運算符來比較結構類型</p>
<p>這也經常在定義子例程或類型時使用，而不是簡單地指定變量</p>
<pre><code class="language-python"># 參數的子類型規范
f X &lt;: T = ...

# 所需屬性的子類型規范(.Iterator 屬性必須是 Iterator 類型的子類型)
Iterable T = Trait {
    .Iterator = {Iterator} # {Iterator} == {I: Type | I &lt;: Iterator}
    .iter = Self.() -&gt; Self.Iterator T
    ...
}
</code></pre>
<p>也可以在定義類時使用子類型規范來靜態檢查該類是否是指定類型的子類型</p>
<pre><code class="language-python"># C 類是 Show 的子類型
C = Class Object, Impl := Show
C.show self = ... # 顯示所需的屬性
</code></pre>
<p>您也可以僅在特定情況下指定子類型</p>
<pre><code class="language-python">K T: Eq
K Int &lt;: Show and Eq
K T = Class Object
K(T).
    `==` self, other = ...
K(Int).
    show self = ...
</code></pre>
<p>實現結構類型時建議使用子類型規范
這是因為，由于結構子類型的性質，拼寫錯誤或類型規范錯誤在實現所需屬性時不會導致錯誤</p>
<pre><code class="language-python">C = Class Object
C.shoe self = ... # Show 由于 Typo 沒有實現(它被認為只是一種獨特的方法)
</code></pre>
<h2 id="屬性定義"><a class="header" href="#屬性定義">屬性定義</a></h2>
<p>只能在模塊中為Trait和類定義屬性</p>
<pre><code class="language-python">C = Class()
C.pub_attr = &quot;this is public&quot;
C::private_attr = &quot;this is private&quot;

c = C.new()
assert c.pub_attr == &quot;this is public&quot;
</code></pre>
<p>定義批處理定義的語法稱為批處理定義，其中在 <code>C.</code> 或 <code>C::</code> 之后添加換行符，并且定義在縮進下方組合在一起</p>
<pre><code class="language-python">C = Class()
C.pub1 = ...
C.pub2 = ...
C::priv1 = ...
C::priv2 = ...
# 相當于
C = Class()
C.
    pub1 = ...
    C. pub2 = ...
C::
    priv1 = ...
    priv2 = ...
</code></pre>
<h2 id="別名"><a class="header" href="#別名">別名</a></h2>
<p>類型可以有別名。這允許縮短長類型，例如記錄類型</p>
<pre><code class="language-python">Id = Int
Point3D = {x = Int; y = Int; z = Int}
IorS = Int or Str
Vector = Array Int
</code></pre>
<p>此外，當顯示錯誤時，如果定義了復合類型(在上面的示例中，右側類型不是第一個類型)，編譯器將為它們使用別名</p>
<p>但是，每個模塊只允許一個相同類型的別名，多個別名將導致警告
這意味著應將具有不同用途的類型定義為單獨的類型
目的還在于防止在已經具有別名的類型之上添加別名</p>
<pre><code class="language-python">Id = Int
UserId = Int # 類型警告: 重復別名: Id 和 UserId

Ids = Array Id
Ints = Array Int # 類型警告: 重復別名: Isd 和 Ints

IorS = Int or Str
IorSorB = IorS or Bool
IorSorB_ = Int or Str or Bool # 類型警告: 重復別名: IorSorB 和 IorSorB_

Point2D = {x = Int; y = Int}
Point3D = {.... Point2D; z = Int}
Point = {x = Int; y = Int; z = Int} # 類型警告: 重復別名: Point3D 和 Point
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="trait"><a class="header" href="#trait">trait</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/03_trait.md&amp;commit_hash=14657486719a134f494e107774ac8f9d5a63f083"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/03_trait.md%26commit_hash%3D14657486719a134f494e107774ac8f9d5a63f083" alt="badge" /></a></p>
<p>Trait 是一種名義類型，它將類型屬性要求添加到記錄類型
它類似于 Python 中的抽象基類 (ABC)，但區別在于能夠執行代數運算</p>
<pre><code class="language-python">Norm = Trait {.x = Int; .y = Int; .norm = Self.() -&gt; Int}
</code></pre>
<p>trait不區分屬性和方法</p>
<p>注意，trait 只能聲明，不能實現(實現是通過一個叫做 patching 的特性來實現的，后面會討論)
可以通過指定部分類型來檢查Trait在類中的實現</p>
<pre><code class="language-python">Point2D &lt;: Norm
Point2D = Class {.x = Int; .y = Int}
Point2D.norm self = self.x**2 + self.y**2
</code></pre>
<p>Error if the required attributes are not implemented.</p>
<pre><code class="language-python">Point2D &lt;: Norm # 類型錯誤: Point2D 不是 Norm 的子類型
Point2D = Class {.x = Int; .y = Int}
</code></pre>
<p>Trait與結構類型一樣，可以應用組合、替換和消除等操作(例如&quot;T 和 U&quot;)。由此產生的Trait稱為即時Trait</p>
<pre><code class="language-python">T = Trait {.x = Int}
U = Trait {.y = Int}
V = Trait {.x = Int; y: Int}
assert Structural(T and U) == Structural V
assert Structural(V not U) == Structural T
W = Trait {.x = Ratio}
assert Structural(W) ! = Structural(T)
assert Structural(W) == Structural(T.replace {.x = Ratio})
</code></pre>
<p>Trait 也是一種類型，因此可以用于普通類型規范</p>
<pre><code class="language-python">points: [Norm; 2] = [Point2D::new(1, 2), Point2D::new(3, 4)]
assert points.iter().map(x -&gt; x.norm()).collect(Array) == [5, 25].
</code></pre>
<h2 id="trait包含"><a class="header" href="#trait包含">Trait包含</a></h2>
<p>擴展運算符 <code>...</code> 允許您將包含某個Trait的Trait定義為超類型。這稱為Trait的 <strong>subsumption</strong>
在下面的示例中，<code>BinAddSub</code> 包含 <code>BinAdd</code> 和 <code>BinSub</code>
這對應于類中的繼承，但與繼承不同的是，可以使用&quot;和&quot;組合多個基類型。也允許被 <code>not</code> 部分排除的Trait</p>
<pre><code class="language-python">Add R = Trait {
    .AddO = Type
    . `_+_` = Self.(R) -&gt; Self.AddO
}

Sub R = Trait {
    .SubO = Type
    . `_-_` = Self.(R) -&gt; Self.SubO
}

BinAddSub = Subsume Add(Self) and Sub(Self)
</code></pre>
<h2 id="結構trait"><a class="header" href="#結構trait">結構Trait</a></h2>
<p>Trait可以結構化</p>
<pre><code class="language-python">SAdd = Structural Trait {
    . `_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: SAdd| 不能省略
add|A &lt;: SAdd| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

assert add(C.new(1), C.new(2)) == C.new(3)
</code></pre>
<p>名義Trait不能簡單地通過實現請求方法來使用，而必須明確聲明已實現
在以下示例中，<code>add</code>不能與<code>C</code>類型的參數一起使用，因為沒有明確的實現聲明。它必須是<code>C = Class {i = Int}, Impl := Add</code></p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
# |A &lt;: 添加| 可以省略
add|A &lt;: Add| x, y: A = x.`_+_` y

C = Class {i = Int}
C.
    new i = Self.__new__ {i;}
    `_+_` self, other: Self = Self.new {i = self::i + other::i}

add C.new(1), C.new(2) # 類型錯誤: C 不是 Add 的子類
# 提示: 繼承或修補&quot;添加&quot;
</code></pre>
<p>不需要為此實現聲明結構Trait，但類型推斷不起作用。使用時需要指定類型</p>
<h2 id="多態trait"><a class="header" href="#多態trait">多態Trait</a></h2>
<p>Trait可以帶參數。這與多態類型相同</p>
<pre><code class="language-python">Mapper T: Type = Trait {
    .mapIter = {Iterator}
    .map = (self: Self, T -&gt; U) -&gt; Self.MapIter U
}

# ArrayIterator &lt;: Mapper
# ArrayIterator.MapIter == ArrayMapper
# [1, 2, 3].iter(): ArrayIterator Int
# [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;): ArrayMapper Str
assert [1, 2, 3].iter().map(x -&gt; &quot;{x}&quot;).collect(Array) == [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2 id="overridetrait"><a class="header" href="#overridetrait">OverrideTrait</a></h2>
<p>派生Trait可以Override基本Trait的類型定義
在這種情況下，Override方法的類型必須是基方法類型的子類型</p>
<pre><code class="language-python"># `Self.(R) -&gt; O` is a subtype of ``Self.(R) -&gt; O or Panic
Div R, O: Type = Trait {
    . `/` = Self.(R) -&gt; O or Panic
}
SafeDiv R, O = Subsume Div, {
    @Override
    . `/` = Self.(R) -&gt; O
}
</code></pre>
<h2 id="在-api-中實現和解決重復的trait"><a class="header" href="#在-api-中實現和解決重復的trait">在 API 中實現和解決重復的Trait</a></h2>
<p><code>Add</code>、<code>Sub</code> 和 <code>Mul</code> 的實際定義如下所示</p>
<pre><code class="language-python">Add R = Trait {
    .Output = Type
    . `_+_` = Self.(R) -&gt; .Output
}
Sub R = Trait {
    .Output = Type
    . `_-_` = Self.(R) -&gt; .Output
}
Mul R = Trait {
    .Output = Type
    . `*` = Self.(R) -&gt; .Output
}
</code></pre>
<p><code>.Output</code> 重復。如果要同時實現這些多個Trait，請指定以下內容</p>
<pre><code class="language-python">P = Class {.x = Int; .y = Int}
# P|Self &lt;: Add(P)|可簡寫為 P|&lt;: Add(P)|
P|Self &lt;: Add(P)|.
    Output = P
    `_+_` self, other = P.new {.x = self.x + other.x; .y = self.y + other.y}
P|Self &lt;: Mul(Int)|.
    Output = P
    `*` self, other = P.new {.x = self.x * other; .y = self.y * other}
</code></pre>
<p>以這種方式實現的重復 API 在使用時幾乎總是類型推斷，但也可以通過使用 <code>||</code> 顯式指定類型來解決</p>
<pre><code class="language-python">print! P.Output # 類型錯誤: 不明確的類型
print! P|&lt;: Mul(Int)|.Output # &lt;class 'P'&gt;
</code></pre>
<h2 id="附錄-與-rust-trait的區別"><a class="header" href="#附錄-與-rust-trait的區別">附錄: 與 Rust Trait的區別</a></h2>
<p>Erg 的Trait忠實于 [Sch?rli 等人] (https://www.ptidej.net/courses/ift6251/fall06/presentations/061122/061122.doc.pdf) 提出的Trait
為了允許代數運算，Trait被設計為不能有方法實現目錄，但可以在必要時進行修補</p>
<p 對齊='中心'>
     <a href='./02_basic.md'>上一頁</a> | <a href='./04_class.md'>下一步</a>
</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="class"><a class="header" href="#class">Class</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/04_class.md&amp;commit_hash=a9d45b743cc655543e0d7f586426499091cead3d"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/04_class.md%26commit_hash%3Da9d45b743cc655543e0d7f586426499091cead3d" alt="badge" /></a></p>
<p>Erg 中的類大致是一種可以創建自己的元素(實例)的類型
這是一個簡單類的示例</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
# 如果 `.new` 沒有定義，那么 Erg 將創建 `Person.new = Person::__new__`
Person.
    new name, age = Self::__new__ {.name = name; .age = age}

john = Person.new &quot;John Smith&quot;, 25
print! john # &lt;Person object&gt;
print! classof(john) # Person
</code></pre>
<p>賦予&quot;Class&quot;的類型(通常是記錄類型)稱為需求類型(在本例中為&quot;{.name = Str; .age = Nat}&quot;)
可以使用 <code>&lt;Class name&gt;::__new__ {&lt;attribute name&gt; = &lt;value&gt;; 創建實例 ...}</code> 可以創建
<code>{.name = &quot;約翰·史密斯&quot;; .age = 25}</code> 只是一條記錄，但它通過傳遞 <code>Person.new</code> 轉換為 <code>Person</code> 實例
創建此類實例的子例程稱為構造函數
在上面的類中，<code>.new</code> 方法被定義為可以省略字段名等</p>
<p>請注意，以下不帶換行符的定義將導致語法錯誤</p>
<pre><code class="language-python">Person.new name, age = ... # 語法錯誤: 不能直接在對象上定義屬性
</code></pre>
<blockquote>
<p><strong>Warning</strong>: 這是最近添加的規范，后續文檔中可能不會遵循。如果你發現它，請報告它</p>
</blockquote>
<h2 id="實例和類屬性"><a class="header" href="#實例和類屬性">實例和類屬性</a></h2>
<p>在 Python 和其他語言中，實例屬性通常在塊側定義如下，但請注意，這樣的寫法在 Erg 中具有不同的含義</p>
<pre><code class="language-python"># Python
class Person:
    name: str
    age: int
</code></pre>
<pre><code class="language-python"># 在Erg中，這個符號意味著類屬性的聲明(不是實例屬性)
Person = Class()
Person.
    name: Str
    age: Int
</code></pre>
<pre><code class="language-python"># 以上 Python 代碼的 Erg 代碼
Person = Class {
    .name = Str
    .age = Nat
}
</code></pre>
<p>元素屬性(在記錄中定義的屬性)和類型屬性(也稱為實例/類屬性，尤其是在類的情況下)是完全不同的東西。類型屬性是類型本身的屬性。當一個類型的元素本身沒有所需的屬性時，它指的是一個類型屬性。元素屬性是元素直接擁有的唯一屬性
為什么要進行這種區分? 如果所有屬性都是元素屬性，那么在創建對象時復制和初始化所有屬性將是低效的
此外，以這種方式劃分屬性明確了諸如&quot;該屬性是共享的&quot;和&quot;該屬性是分開持有的&quot;之類的角色</p>
<p>下面的例子說明了這一點。<code>species</code> 屬性對所有實例都是通用的，因此將其用作類屬性更自然。但是，屬性 <code>name</code> 應該是實例屬性，因為每個實例都應該單獨擁有它</p>
<pre><code class="language-python">Person = Class {name = Str}
Person::
    species = &quot;human&quot;
Person.
    describe() =
        log &quot;species: {species}&quot;
    greet self =
        log &quot;Hello, My name is {self::name}.&quot;

Person.describe() # 類型: Person
Person.greet() # 類型錯誤: 未綁定的方法 Person.greet 需要一個參數

john = Person.new {name = &quot;John&quot;}
john.describe() # 類型: human
john.greet() # 你好，我是約翰

alice = Person.new {name = &quot;Alice&quot;}
alice.describe() # 類型: human
alice.greet() # 你好，我是愛麗絲
</code></pre>
<p>順便說一下，如果實例屬性和類型屬性具有相同的名稱和相同的類型，則會發生編譯錯誤。這是為了避免混淆</p>
<pre><code class="language-python">C = Class {.i = Int}
C.i = 1 # 屬性錯誤: `.i` 已在實例字段中定義
</code></pre>
<h2 id="類class-類型type"><a class="header" href="#類class-類型type">類(Class), 類型(Type)</a></h2>
<p>請注意，<code>1</code> 的類和類型是不同的
只有一個類 <code>Int</code> 是 <code>1</code> 的生成器。可以通過<code>classof(obj)</code>或<code>obj.__class__</code>獲取對象所屬的類
相比之下，<code>1</code>有無數種。例如，<code>{1}, {0, 1}, 0..12, Nat, Int, Num</code>
但是，可以將最小類型定義為單一類型，在本例中為&quot;{1}&quot;。可以通過<code>Typeof(obj)</code>獲取對象所屬的類型。這是一個編譯時函數
對象可以使用補丁方法以及類方法
Erg 不允許您添加類方法，但您可以使用 <a href="type/./07_patch.html">patch</a> 來擴展類</p>
<p>您還可以從現有類(<a href="type/../29_decorator.html#%E5%8F%AF%E7%B9%BC%E6%89%BF">Inheritable</a> 類)繼承
您可以使用 <code>Inherit</code> 創建一個繼承類。左側的類型稱為派生類，右側的&quot;繼承&quot;的參數類型稱為基類(繼承類)</p>
<pre><code class="language-python">MyStr = Inherit Str
# other: 如果你設置 ``other: Str''，你可以使用 MyStr
MyStr.
    `-` self, other: Str = self.replace other, &quot;&quot;

abc = MyStr.new(&quot;abc&quot;)
# 這里的比較是向上的
assert abc - &quot;b&quot; == &quot;ac&quot;
</code></pre>
<p>與 Python 不同，默認情況下，定義的 Erg 類是 <code>final</code>(不可繼承的)
要使類可繼承，必須將 <code>Inheritable</code> 裝飾器附加到該類
Str` 是可繼承的類之一</p>
<pre><code class="language-python">MyStr = Inherit Str # OK
MyStr2 = Inherit MyStr # NG

@Inheritable
InheritableMyStr = Inherit Str
MyStr3 = Inherit InheritableMyStr # OK
</code></pre>
<p><code>Inherit Object</code> 和 <code>Class()</code> 在實踐中幾乎是等價的。一般使用后者</p>
<p>類具有與類型不同的等價檢查機制
類型基于其結構進行等效性測試</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
Human = {.name = Str; .age = Nat}

assert Person == Human
</code></pre>
<p>class has no equivalence relation defined.</p>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat}
Human = Class {.name = Str; .age = Nat}

Person == Human # 類型錯誤: 無法比較類
</code></pre>
<h2 id="與結構類型的區別"><a class="header" href="#與結構類型的區別">與結構類型的區別</a></h2>
<p>我們說過類是一種可以生成自己的元素的類型，但這并不是嚴格的描述。事實上，一個記錄類型+補丁可以做同樣的事情</p>
<pre><code class="language-python">Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    new name, age = {.name; .age}

john = Person.new(&quot;John Smith&quot;, 25)
</code></pre>
<p>使用類有四個優點
第一個是構造函數經過有效性檢查，第二個是它的性能更高，第三個是您可以使用符號子類型(NST)，第四個是您可以繼承和覆蓋</p>
<p>我們之前看到記錄類型 + 補丁也可以定義一個構造函數(某種意義上)，但這當然不是一個合法的構造函數。這當然不是一個合法的構造函數，因為它可以返回一個完全不相關的對象，即使它調用自己<code>.new</code>。在類的情況下，<code>.new</code> 被靜態檢查以查看它是否生成滿足要求的對象</p>
<p>~</p>
<p>類的類型檢查只是檢查對象的<code>。__class__</code> 對象的屬性。因此可以快速檢查一個對象是否屬于一個類型</p>
<p>~</p>
<p>Erg 在課堂上啟用 NST； NST 的優點包括健壯性
在編寫大型程序時，經常會出現對象的結構巧合匹配的情況</p>
<pre><code class="language-python">Dog = {.name = Str; .age = Nat}
DogImpl = Patch Dog
DogImpl.
    bark = log &quot;Yelp!&quot;
...
Person = {.name = Str; .age = Nat}
PersonImpl = Patch Person
PersonImpl.
    greet self = log &quot;Hello, my name is {self.name}.&quot;

john = {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # &quot;Yelp!&quot;
</code></pre>
<p><code>Dog</code> 和 <code>Person</code> 的結構完全一樣，但讓動物打招呼，讓人類吠叫顯然是無稽之談
前者是不可能的，所以讓它不適用更安全。在這種情況下，最好使用類</p>
<pre><code class="language-python">Dog = Class {.name = Str; .age = Nat}
Dog.bark = log &quot;Yelp!&quot;
...
Person = Class {.name = Str; .age = Nat}
Person.greet self = log &quot;Hello, my name is {self.name}.&quot;

john = Person.new {.name = &quot;John Smith&quot;; .age = 20}
john.bark() # 類型錯誤: `Person` 對象沒有方法 `.bark`
</code></pre>
<p>另一個特點是補丁添加的類型屬性是虛擬的，實現類不作為實體保存
也就是說，<code>T.x</code>、<code>T.bar</code> 是可以通過與 <code>{i = Int}</code> 兼容的類型訪問(編譯時綁定)的對象，并且未在 <code>{i = Int}</code> 或 <code> C</code>
相反，類屬性由類本身持有。因此，它們不能被不處于繼承關系的類訪問，即使它們具有相同的結構</p>
<pre><code class="language-python">C = Class {i = Int}
C.
    foo self = ...
print! dir(C) # [&quot;foo&quot;, ...].

T = Patch {i = Int}
T.
    x = 1
    bar self = ...
print! dir(T) # [&quot;bar&quot;, &quot;x&quot;, ...].
assert T.x == 1
assert {i = 1}.x == 1
print! T.bar # &lt;函數 bar&gt;
{i = Int}.bar # 類型錯誤: Record({i = Int}) 沒有方法 `.bar`
C.bar # 類型錯誤: C 沒有方法 `.bar` 打印！
print! {i = 1}.bar # &lt;方法 bar&gt;
C.new({i = 1}).bar # &lt;方法 bar&gt;
</code></pre>
<h2 id="與數據類的區別"><a class="header" href="#與數據類的區別">與數據類的區別</a></h2>
<p>有兩種類型的類: 常規類，通過<code>Class</code>成為記錄類，以及從記錄類繼承(<code>Inherit</code>)的數據類
數據類繼承了記錄類的功能，具有分解賦值、默認實現的<code>==</code>和<code>hash</code>等特性。另一方面，數據類有自己的等價關系和格式展示
另一方面，如果要定義自己的等價關系或格式顯示，則應使用普通類</p>
<pre><code class="language-python">C = Class {i = Int}
c = C.new {i = 1}
d = C.new {i = 2}
print! c # &lt;C object&gt;
c == d # 類型錯誤: `==` 沒有為 `C` 實現

D = Inherit {i = Int}
e = D::{i = 1} # 與`e = D.new {i = 1}`相同
f = D::{i = 2}
print! e # D(i=1)
assert e ! = f
</code></pre>
<h2 id="枚舉類"><a class="header" href="#枚舉類">枚舉類</a></h2>
<p>為了便于定義&quot;Or&quot;類型的類，提供了一個&quot;Enum&quot;</p>
<pre><code class="language-python">X = Class()
Y = Class()
XorY = Enum X, Y
</code></pre>
<p>每種類型都可以通過<code>XorY.X</code>、<code>XorY.Y</code>來訪問，構造函數可以通過<code>X.new |&gt; XorY.new</code>獲得</p>
<pre><code class="language-python">x1 = XorY.new X.new()
x2 = (X.new |&gt; XorY.new)()
x3 = (Y.new |&gt; XorY.new)()
assert x1 == x2
assert x1 != x3
</code></pre>
<h2 id="類關系"><a class="header" href="#類關系">類關系</a></h2>
<p>類是需求類型的子類型。類中可以使用需求類型的方法(包括補丁方法)</p>
<pre><code class="language-python">T = Trait {.foo = Foo}
C = Class(... , impl: T)
C.
    foo = foo
    bar x = ...
assert C &lt; T
assert C.foo == foo
assert not T &lt; C
assert T.foo == Foo
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="繼承"><a class="header" href="#繼承">繼承</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/05_inheritance.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/05_inheritance.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>繼承允許您定義一個新類，為現有類添加功能或專業化
繼承類似于包含在Trait中。繼承的類成為原始類的子類型</p>
<pre><code class="language-python">NewInt = Inherit Int
NewInt.
    plus1 self = self + 1

assert NewInt.new(1).plus1() == 2
assert NewInt.new(1) + NewInt.new(1) == 2
</code></pre>
<p>如果你希望新定義的類是可繼承的，你必須給它一個 <code>Inheritable</code> 裝飾器</p>
<p>您可以指定一個可選參數 <code>additional</code> 以允許該類具有其他實例屬性，但前提是該類是一個值類。但是，如果類是值類，則不能添加實例屬性</p>
<pre><code class="language-python">@Inheritable
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}

john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

MailAddress = Inherit Str, additional: {owner = Str} # 類型錯誤: 實例變量不能添加到值類中
</code></pre>
<p>Erg 的特殊設計不允許繼承&quot;Never&quot;類型。Erg 的特殊設計不允許繼承 <code>Never</code> 類型，因為 <code>Never</code> 是一個永遠無法實例化的獨特類</p>
<h2 id="枚舉類的繼承"><a class="header" href="#枚舉類的繼承">枚舉類的繼承</a></h2>
<p><a href="type/./13_algebraic.html">Or 類型</a> 也可以被繼承。在這種情況下，您可以通過指定可選參數 <code>Excluding</code> 來刪除任何選項(可以使用 <code>or</code> 進行多項選擇)
不能添加其他選項。添加選項的類不是原始類的子類型</p>
<pre><code class="language-python">Number = Class Int or Float or Complex
Number.abs(self): Float =
    match self:
        i: Int -&gt; i.abs().into Float
        f: Float -&gt; f.abs()
        c: Complex -&gt; c.abs().into Float

# c: 復雜不能出現在匹配選項中
RealNumber = Inherit Number, Excluding: Complex
</code></pre>
<p>同樣，也可以指定<a href="type/./12_refinement.html">細化類型</a></p>
<pre><code class="language-python">Months = Class 0..12
MonthsNot31Days = Inherit Months, Excluding: {1, 3, 5, 7, 8, 10, 12}

StrMoreThan3 = Class StrWithLen N | N &gt;= 3
StrMoreThan4 = Inherit StrMoreThan3, Excluding: StrWithLen N | N == 3
</code></pre>
<h2 id="覆蓋"><a class="header" href="#覆蓋">覆蓋</a></h2>
<p>該類與補丁相同，可以將新方法添加到原始類型，但可以進一步&quot;覆蓋&quot;該類
這種覆蓋稱為覆蓋。要覆蓋，必須滿足三個條件
首先，覆蓋必須有一個 <code>Override</code> 裝飾器，因為默認情況下它會導致錯誤
另外，覆蓋不能改變方法的類型。它必須是原始類型的子類型
如果你重寫了一個被另一個方法引用的方法，你也必須重寫所有被引用的方法</p>
<p>為什么這個條件是必要的?這是因為重寫不僅會改變一種方法的行為，而且可能會影響另一種方法的行為</p>
<p>讓我們從第一個條件開始。此條件是為了防止&quot;意外覆蓋&quot;
換句話說，必須使用 <code>Override</code> 裝飾器來防止派生類中新定義的方法的名稱與基類的名稱沖突</p>
<p>接下來，考慮第二個條件。這是為了類型一致性。由于派生類是基類的子類型，因此它的行為也必須與基類的行為兼容</p>
<p>最后，考慮第三個條件。這種情況是 Erg 獨有的，在其他面向對象語言中并不常見，同樣是為了安全。讓我們看看如果不是這種情況會出現什么問題</p>
<pre><code class="language-python"># 反面示例
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    g! ref! self = self.f!() # 無限遞歸警告: 此代碼陷入無限循環 
    # 覆蓋錯誤: 方法 `.g` 被 `.f` 引用但未被覆蓋
</code></pre>
<p>在繼承類 <code>Inherited!</code> 中，<code>.g!</code> 方法被重寫以將處理轉移到 <code>.f!</code>。但是，基類中的 <code>.f!</code> 方法會將其處理轉移到 <code>.g!</code>，從而導致無限循環。<code>.f</code> 是 <code>Base!</code> 類中的一個沒有問題的方法，但它被覆蓋以一種意想不到的方式使用，并且被破壞了</p>
<p>Erg 已將此規則構建到規范中</p>
<pre><code class="language-python"># OK.
@Inheritable
Base! = Class {x = Int!}
Base!
    f! ref! self =
        print! self::x
        self.g!()
    g! ref! self = self::x.update! x -&gt; x + 1

Inherited! = Inherit Base!
Inherited!
    @Override
    f! ref! self =
        print! self::x
        self::x.update! x -&gt; x + 1
    @Override
    g! ref! self = self.f!()
</code></pre>
<p>然而，這個規范并沒有完全解決覆蓋問題。然而，這個規范并沒有完全解決覆蓋問題，因為編譯器無法檢測覆蓋是否解決了問題
創建派生類的程序員有責任糾正覆蓋的影響。只要有可能，嘗試定義一個別名方法</p>
<h3 id="替換trait或看起來像什么"><a class="header" href="#替換trait或看起來像什么">替換Trait(或看起來像什么)</a></h3>
<p>盡管無法在繼承時替換Trait，但有一些示例似乎可以這樣做</p>
<p>例如，<code>Int</code>，<code>Real</code> 的子類型(實現了 <code>Add()</code>)，似乎重新實現了 <code>Add()</code></p>
<pre><code class="language-python">Int = Class ... , Impl := Add() and ...
</code></pre>
<p>但實際上 <code>Real</code> 中的 <code>Add()</code> 代表 <code>Add(Real, Real)</code>，而在 <code>Int</code> 中它只是被 <code>Add(Int, Int)</code> 覆蓋
它們是兩個不同的Trait(<code>Add</code> 是一個 <a href="type/./advanced/variance.html">covariate</a>，所以<code>Add(Real, Real) :&gt; Add(Int, Int)</code>)</p>
<h2 id="多重繼承"><a class="header" href="#多重繼承">多重繼承</a></h2>
<p>Erg 不允許普通類之間的交集、差異和互補</p>
<pre><code class="language-python">Int and Str # 類型錯誤: 無法合并類
</code></pre>
<p>該規則防止從多個類繼承，即多重繼承</p>
<pre><code class="language-python">IntAndStr = Inherit Int and Str # 語法錯誤: 不允許類的多重繼承
</code></pre>
<p>但是，可以使用多個繼承的 Python 類</p>
<h2 id="多層多級繼承"><a class="header" href="#多層多級繼承">多層(多級)繼承</a></h2>
<p>Erg 繼承也禁止多層繼承。也就是說，您不能定義從另一個類繼承的類
從&quot;Object&quot;繼承的可繼承類可能會異常繼承</p>
<p>同樣在這種情況下，可以使用 Python 的多層繼承類</p>
<h2 id="重寫繼承的屬性"><a class="header" href="#重寫繼承的屬性">重寫繼承的屬性</a></h2>
<p>Erg 不允許重寫從基類繼承的屬性。這有兩個含義</p>
<p>第一個是對繼承的源類屬性的更新操作。例如，它不能重新分配，也不能通過 <code>.update!</code> 方法更新</p>
<p>覆蓋與重寫不同，因為它是一種用更專業的方法覆蓋的操作。覆蓋也必須替換為兼容的類型</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    var = !1
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1

Inherited! = Inherit Base!
Inherited!
    var.update! v -&gt; v + 1
    # 類型錯誤: 不能更新基類變量
    @Override
    inc_pub! ref! self = self.pub + 1
    # 覆蓋錯誤: `.inc_pub!` 必須是 `Self! 的子類型！ () =&gt; ()`
</code></pre>
<p>第二個是對繼承源的(變量)實例屬性的更新操作。這也是被禁止的。基類的實例屬性只能從基類提供的方法中更新
無論屬性的可見性如何，都無法直接更新。但是，它們可以被讀取</p>
<pre><code class="language-python">@Inheritable
Base! = Class {.pub = !Int; pri = !Int}
Base!
    inc_pub! ref! self = self.pub.update! p -&gt; p + 1
    inc_pri! ref! self = self::pri.update! p -&gt; p + 1

self = self.pub.update!
Inherited!
    # OK
    add2_pub! ref! self =
        self.inc_pub!()
        self.inc_pub!()
    # NG, `Child` 不能觸摸 `self.pub` 和 `self::pri`
    add2_pub! ref! self =
        self.pub.update! p -&gt; p + 2
</code></pre>
<p>畢竟 Erg 繼承只能添加新的屬性和覆蓋基類的方法</p>
<h2 id="使用繼承"><a class="header" href="#使用繼承">使用繼承</a></h2>
<p>雖然繼承在正確使用時是一項強大的功能，但它也有一個缺點，即它往往會使類依賴關系復雜化，尤其是在使用多層或多層繼承時。復雜的依賴關系會降低代碼的可維護性
Erg 禁止多重和多層繼承的原因是為了降低這種風險，并且引入了類補丁功能以降低依賴關系的復雜性，同時保留繼承的&quot;添加功能&quot;方面</p>
<p>那么，反過來說，應該在哪里使用繼承呢?一個指標是何時需要&quot;基類的語義子類型&quot;
Erg 允許類型系統自動進行部分子類型確定(例如，Nat，其中 Int 大于或等于 0)
但是，例如，僅依靠 Erg 的類型系統很難創建&quot;表示有效電子郵件地址的字符串類型&quot;。您可能應該對普通字符串執行驗證。然后，我們想為已通過驗證的字符串對象添加某種&quot;保證&quot;。這相當于向下轉換為繼承的類。將 <code>Str object</code> 向下轉換為 <code>ValidMailAddressStr</code> 與驗證字符串是否采用正確的電子郵件地址格式是一一對應的</p>
<pre><code class="language-python">ValidMailAddressStr = Inherit Str
ValidMailAddressStr.
    init s: Str =
        validate s # 郵件地址驗證
        Self.new s

s1 = &quot;invalid mail address&quot;
s2 = &quot;foo@gmail.com&quot;
_ = ValidMailAddressStr.init s1 # 恐慌: 無效的郵件地址
valid = ValidMailAddressStr.init s2
valid: ValidMailAddressStr # 確保電子郵件地址格式正確
</code></pre>
<p>另一個指標是您何時想要實現名義多態性
例如，下面定義的 <code>greet!</code> 過程將接受任何類型為 <code>Named</code> 的對象
但顯然應用 <code>Dog</code> 類型的對象是錯誤的。所以我們將使用 <code>Person</code> 類作為參數類型
這樣，只有 <code>Person</code> 對象、從它們繼承的類和 <code>Student</code> 對象將被接受為參數
這是比較保守的，避免不必要地承擔過多的責任</p>
<pre><code class="language-python">Named = {name = Str; ...}
Dog = Class {name = Str; breed = Str}
Person = Class {name = Str}
Student = Inherit Person, additional: {id = Int}
structural_greet! person: Named =
    print! &quot;Hello, my name is {person::name}.&quot;
greet! person: Person =
    print! &quot;Hello, my name is {person::name}.&quot;

max = Dog.new {name = &quot;Max&quot;, breed = &quot;Labrador&quot;}
john = Person.new {name = &quot;John&quot;}
alice = Student.new {name = &quot;Alice&quot;, id = 123}

structural_greet! max # 你好，我是馬克斯
structural_greet! john # 你好，我是約翰
greet! alice # 你好，我是愛麗絲
greet! max # 類型錯誤: 
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="名義子類型與結構子類型"><a class="header" href="#名義子類型與結構子類型">名義子類型與結構子類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/06_nst_vs_sst.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/06_nst_vs_sst.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<pre><code class="language-python">Months = 0..12

# NST
MonthsClass = Class Months
MonthsClass.
    name self =
        match self:
            1 -&gt; &quot;january&quot;
            2 -&gt; &quot;february&quot;
            3 -&gt; &quot;march&quot;
            ...

# SST
MonthsImpl = Patch Months
MonthsImpl.
    name self =
        match self:
            1 -&gt; &quot;January&quot;
            2 -&gt; &quot;February&quot;
            3 -&gt; &quot;March&quot;
            ...

assert 12 in Months
assert 2.name() == &quot;February&quot;
assert not 12 in MonthsClass
assert MonthsClass.new(12) in MonthsClass
# 它可以使用結構類型，即使包裝在一個類中
assert MonthsClass.new(12) in Months
# 如果兩者都存在，則類方法優先
assert MonthsClass.new(2).name() == &quot;february&quot;
</code></pre>
<h2 id="最后我應該使用哪個nst-還是-sst"><a class="header" href="#最后我應該使用哪個nst-還是-sst">最后，我應該使用哪個，NST 還是 SST?</a></h2>
<p>如果您無法決定使用哪一個，我們的建議是 NST
SST 需要抽象技能來編寫在任何用例中都不會崩潰的代碼。好的抽象可以帶來高生產力，但錯誤的抽象(外觀上的共性)會導致適得其反的結果。(NST 可以通過故意將抽象保持在最低限度來降低這種風險。如果您不是庫實現者，那么僅使用 NST 進行編碼并不是一個壞主意</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="修補"><a class="header" href="#修補">修補</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/07_patch.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/07_patch.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg 不允許修改現有類型和類
這意味著，不可能在類中定義額外的方法，也不能執行特化(一種語言特性，單態化多態聲明的類型并定義專用方法，如在 C++ 中)
但是，在許多情況下，您可能希望向現有類型或類添加功能，并且有一個稱為&quot;修補&quot;的功能允許您執行此操作</p>
<pre><code class="language-python">StrReverse = Patch Str
StrReverse.
    reverse self = self.iter().rev().collect(Str)

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
</code></pre>
<p>補丁的名稱應該是要添加的主要功能的簡單描述
這樣，被修補類型的對象(<code>Str</code>)可以使用修補程序的方法(<code>StrReverse</code>)
實際上，內置方法<code>.reverse</code>并不是<code>Str</code>的方法，而是<code>StrRReverse</code>中添加的方法</p>
<p>但是，補丁方法的優先級低于名義類型(類/trait)的方法，并且不能覆蓋現有類型</p>
<pre><code class="language-python">StrangeInt = Patch Int
StrangeInt.
    `_+_` = Int.`_-_` # 賦值錯誤: . `_+_` 已在 Int 中定義
</code></pre>
<p>如果要覆蓋，則必須從類繼承
但是，基本上建議不要覆蓋并定義具有不同名稱的方法
由于一些安全限制，覆蓋不是很容易做到</p>
<pre><code class="language-python">StrangeInt = Inherit Int
StrangeInt.
# 覆蓋方法必須被賦予覆蓋裝飾器
    # 另外，你需要覆蓋所有依賴于 Int.`_+_` 的 Int 方法
    @Override
    `_+_` = Super.`_-_` # OverrideError: Int.`_+_` 被 ... ````` 引用，所以這些方法也必須被覆蓋
</code></pre>
<h2 id="選擇修補程序"><a class="header" href="#選擇修補程序">選擇修補程序</a></h2>
<p>可以為單一類型定義修復程序，并且可以組合在一起</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
StrMultiReplace = Patch(Str)
StrMultiReverse.
    multi_replace self, pattern_and_targets: [(Pattern, Str)] = ...
StrToCamelCase = Patch(Str)
StrToCamelCase.
    to_camel_case self = ...
StrToKebabCase = Patch(Str)
StrToKebabCase.
    to_kebab_case self = ...

StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
StrBoosterPack = StrReverse and StrMultiReplace and StrToCamelCase and StrToKebabCase
</code></pre>
<pre><code class="language-python">{StrBoosterPack; ...} = import &quot;foo&quot;

assert &quot;abc&quot;.reverse() == &quot;cba&quot;
assert &quot;abc&quot;.multi_replace([(&quot;a&quot;, &quot;A&quot;), (&quot;b&quot;, &quot;B&quot;)]) == &quot;ABc&quot;
assert &quot;to camel case&quot;.to_camel_case() == &quot;toCamelCase&quot;
assert &quot;to kebab case&quot;.to_kebab_case() == &quot;to-kebab-case&quot;
</code></pre>
<p>如果定義了多個修復程序，其中一些可能會導致重復實施</p>
<pre><code class="language-python"># foo.er

StrReverse = Patch(Str)
StrReverse.
    reverse self = ...
# 更高效的實現
StrReverseMk2 = Patch(Str)
StrReverseMk2.
    reverse self = ...

&quot;hello&quot;.reverse() # 補丁選擇錯誤: `.reverse` 的多個選擇: StrReverse, StrReverseMk2
</code></pre>
<p>在這種情況下，您可以使用 <strong>related function</strong> 形式而不是方法形式使其唯一</p>
<pre><code class="language-python">assert StrReverseMk2.reverse(&quot;hello&quot;) == &quot;olleh&quot;
</code></pre>
<p>You can also make it unique by selectively importing.</p>
<pre><code class="language-python">{StrReverseMk2; ...} = import &quot;foo&quot;

assert &quot;hello&quot;.reverse() == &quot;olleh&quot;
</code></pre>
<h2 id="膠水補丁"><a class="header" href="#膠水補丁">膠水補丁</a></h2>
<p>維修程序也可以將類型相互關聯。<code>StrReverse</code> 補丁涉及 <code>Str</code> 和 <code>Reverse</code>
這樣的補丁稱為 <strong>glue patch</strong>
因為 <code>Str</code> 是內置類型，所以用戶需要使用膠水補丁來改造Trait</p>
<pre><code class="language-python">Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch Str, Impl := Reverse
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>每個類型/Trait對只能定義一個膠水補丁
這是因為如果多個膠水修復程序同時&quot;可見&quot;，就不可能唯一確定選擇哪個實現
但是，當移動到另一個范圍(模塊)時，您可以交換維修程序</p>
<pre><code class="language-python">NumericStr = Inherit Str
NumericStr.
    ...

NumStrRev = Patch NumericStr, Impl := Reverse
NumStrRev.
    ...
# 重復修補程序錯誤: 數值Str已與&quot;反向&quot;關聯`
# 提示: 'Str'(NumericStr'的超類)通過'StrReverse'與'Reverse'關聯
</code></pre>
<h2 id="附錄-與-rust-trait的關系"><a class="header" href="#附錄-與-rust-trait的關系">附錄: 與 Rust Trait的關系</a></h2>
<p>Erg 修復程序相當于 Rust 的(改造的)<code>impl</code> 塊</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
trait Reverse {
    fn reverse(self) -&gt; Self;
}

impl Reverse for String {
    fn reverse(self) -&gt; Self {
        self.chars().rev().collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>可以說，Rust 的Trait是 Erg 的Trait和修復程序的Trait。這使得 Rust 的Trait聽起來更方便，但事實并非如此</p>
<pre><code class="language-python"># Erg
Reverse = Trait {
    .reverse = Self.() -&gt; Self
}

StrReverse = Patch(Str, Impl := Reverse)
StrReverse.
    reverse self =
        self.iter().rev().collect(Str)
</code></pre>
<p>因為 impl 塊在 Erg 中被對象化為補丁，所以在從其他模塊導入時可以選擇性地包含。作為副作用，它還允許將外部Trait實現到外部結構
此外，結構類型不再需要諸如 <code>dyn trait</code> 和 <code>impl trait</code> 之類的語法</p>
<pre><code class="language-python"># Erg
reversible: [Reverse; 2] = [[1, 2, 3], &quot;hello&quot;]

iter|T|(i: Iterable T): Iterator T = i.iter()
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
let reversible: [Box&lt;dyn Reverse&gt;; 2] = [Box::new([1, 2, 3]), Box::new(&quot;hello&quot;)];

fn iter&lt;I&gt;(i: I) -&gt; impl Iterator&lt;Item = I::Item&gt; where I: IntoIterator {
    i.into_iter()
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="通用補丁"><a class="header" href="#通用補丁">通用補丁</a></h2>
<p>補丁不僅可以為一種特定類型定義，還可以為&quot;一般功能類型&quot;等定義
在這種情況下，要給出自由度的項作為參數給出(在下面的情況下，<code>T: Type</code>)。以這種方式定義的補丁稱為全對稱補丁
如您所見，全對稱補丁正是一個返回補丁的函數，但它本身也可以被視為補丁</p>
<pre><code class="language-python">FnType T: Type = Patch(T -&gt; T)
FnType(T).
    type = T

assert (Int -&gt; Int).type == Int
</code></pre>
<h2 id="結構補丁"><a class="header" href="#結構補丁">結構補丁</a></h2>
<p>此外，可以為滿足特定結構的任何類型定義修復程序
但是，這比名義上的維修程序和類方法具有較低的優先級</p>
<p>在定義結構修復程序時應使用仔細的設計，因為某些屬性會因擴展而丟失，例如以下內容</p>
<pre><code class="language-python"># 這不應該是 `Structural`
Norm = Structural Patch {x = Int; y = Int}
Norm.
    norm self = self::x**2 + self::y**2

Point2D = Class {x = Int; y = Int}
assert Point2D.new({x = 1; y = 2}).norm() == 5

Point3D = Class {x = Int; y = Int; z = Int}
assert Point3D.new({x = 1; y = 2; z = 3}).norm() == 14 # AssertionError:
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="值類型"><a class="header" href="#值類型">值類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/08_value.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/08_value.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>值類型是可以在編譯時評估的 Erg 內置類型，具體來說: </p>
<pre><code class="language-python">Value = (
    Int
    or Nat
    or Ratio
    or Float
    or Complex
    or Bool
    or Str
    or NoneType
    or Array Const
    or Tuple Const
    or Set Const
    or ConstFunc(Const, _)
    or ConstProc(Const, _)
    or ConstMethod(Const, _)
)
</code></pre>
<p>應用于它們的值類型對象、常量和編譯時子例程稱為 <strong>constant 表達式</strong></p>
<pre><code class="language-python">1, 1.0, 1+2im, True, None, &quot;aaa&quot;, [1, 2, 3], Fib(12)
</code></pre>
<p>小心子程序。子例程可能是也可能不是值類型
由于子程序的實質只是一個指針，因此可以將其視為一個值<a href="type/08_value.html#1"><sup id="f1">1</sup></a>，但是在編譯不是子程序的東西時不能使用 在恒定的上下文中。不是值類型，因為它沒有多大意義</p>
<p>將來可能會添加歸類為值類型的類型</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> Erg 中的術語&quot;值類型&quot;與其他語言中的定義不同。純 Erg 語義中沒有內存的概念，并且因為它被放置在堆棧上而說它是值類型，或者因為它實際上是一個指針而說它不是值類型是不正確的。值類型僅表示它是&quot;值&quot;類型或其子類型。<a href="type/08_value.html#f1">?</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="屬性類型"><a class="header" href="#屬性類型">屬性類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/09_attributive.md&amp;commit_hash=412a6fd1ea507a7afa1304bcef642dfe6b3a0872"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/09_attributive.md%26commit_hash%3D412a6fd1ea507a7afa1304bcef642dfe6b3a0872" alt="badge" /></a></p>
<p>屬性類型是包含 Record 和 Dataclass、Patch、Module 等的類型
屬于屬性類型的類型不是值類型</p>
<h2 id="記錄類型復合"><a class="header" href="#記錄類型復合">記錄類型復合</a></h2>
<p>可以展平復合的記錄類型
例如，<code>{... {.name = Str; .age = Nat}; ... {.name = Str; .id = Nat}}</code> 變成 <code>{.name = Str; .age = 自然； .id = Nat}</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="間隔類型"><a class="header" href="#間隔類型">間隔類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/10_interval.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/10_interval.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p><code>Range</code> 對象最基本的用途是作為迭代器</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>請注意，與 Python 不同，它包含一個結束編號</p>
<p>然而，這不僅僅用于 <code>Range</code> 對象。也可以使用類型。這種類型稱為Interval類型</p>
<pre><code class="language-python">i: 0..10 = 2
</code></pre>
<p><code>Nat</code> 類型等價于 <code>0..&lt;Inf</code> 并且，<code>Int</code> 和 <code>Ratio</code> 等價于 <code>-Inf&lt;..&lt;Inf</code>，
<code>0..&lt;Inf</code> 也可以寫成 <code>0.._</code>。<code>_</code> 表示任何 <code>Int</code> 類型的實例</p>
<p>由于它也可以用作迭代器，所以可以倒序指定，例如<code>10..0</code>，但是<code>&lt;..</code>、<code>..&lt;</code>和<code>&lt;..&lt;</code>不能倒序</p>
<pre><code class="language-python">a = 0..10 # OK
b = 0..&lt;10 # OK
c = 10..0 # OK
d = 10&lt;..0 # 語法錯誤
e = 10..&lt;0 # 語法錯誤
f = 10&lt;..&lt;0 # 語法錯誤
</code></pre>
<p>Range 運算符可用于非數字類型，只要它們是&quot;Ord&quot;不可變類型</p>
<pre><code class="language-python">Alphabet = &quot;A&quot;..&quot;z&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚舉類型"><a class="header" href="#枚舉類型">枚舉類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/11_enum.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/11_enum.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>Set 生成的枚舉類型
枚舉類型可以與類型規范一起使用，但可以通過將它們分類為類或定義修復程序來定義進一步的方法</p>
<p>具有枚舉類型的部分類型系統稱為枚舉部分類型</p>
<pre><code class="language-python">Bool = {True, False}
Status = {&quot;ok&quot;, &quot;error&quot;}
</code></pre>
<p>由于 <code>1..7</code> 可以重寫為 <code>{1, 2, 3, 4, 5, 6, 7}</code>，所以當元素是有限的時，Enum 類型本質上等同于 Range 類型</p>
<pre><code class="language-python">Binary! = Class {0, 1}!.
    invert! ref! self =
        if! self == 0:
            do!
                self.set! 1
            do!
                self.set! 0

b = Binary!.new !0
b.invert!()
</code></pre>
<p>順便說一下，Erg 的 Enum 類型是一個包含其他語言中常見的枚舉類型的概念</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rust
enum Status { Ok, Error }
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Erg
Status = {&quot;Ok&quot;, &quot;Error&quot;}
</code></pre>
<p>Rust 的不同之處在于它使用了結構子類型(SST)</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Status 和 ExtraStatus 之間沒有關系
enum Status { Ok, Error }
enum ExtraStatus { Ok, Error, Unknown }

// 可實施的方法
impl Status {
    // ...
}
impl ExtraStatus {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-python"># Status &gt; ExtraStatus，Status的元素可以使用ExtraStatus的方法
Status = Trait {&quot;Ok&quot;, &quot;Error&quot;}
    # ...
ExtraStatus = Trait {&quot;Ok&quot;, &quot;Error&quot;, &quot;Unknown&quot;}
    # ...
</code></pre>
<p>方法也可以通過補丁添加</p>
<p>使用&quot;或&quot;運算符明確指示包含或向現有 Enum 類型添加選項</p>
<pre><code class="language-python">ExtraStatus = Status or {&quot;Unknown&quot;}
</code></pre>
<p>一個元素所屬的所有類都相同的枚舉類型稱為同質枚舉類型</p>
<p>默認情況下，可以將需求類型為同類枚舉類型的類視為元素所屬類的子類</p>
<p>如果您不想這樣做，可以將其設為包裝類</p>
<pre><code class="language-python">Abc = Class {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}
Abc.new(&quot;A&quot;).is_uppercase()

OpaqueAbc = Class {inner = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}}.
    new inner: {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;} = Self.new {inner;}
OpaqueAbc.new(&quot;A&quot;).is_uppercase() # 類型錯誤
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="細化類型"><a class="header" href="#細化類型">細化類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/12_refinement.md&amp;commit_hash=94015f61ed0018714a6271ecf60ff2ca38733ce6"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/12_refinement.md%26commit_hash%3D94015f61ed0018714a6271ecf60ff2ca38733ce6" alt="badge" /></a></p>
<p>細化類型是受謂詞表達式約束的類型。枚舉類型和區間類型是細化類型的語法糖</p>
<p>細化類型的標準形式是<code>{Elem: Type | (Pred)*}</code>。這意味著該類型是其元素為滿足 <code>Pred</code> 的 <code>Elem</code> 的類型
可用于篩選類型的類型僅為 <a href="type/./08_value.html">數值類型</a></p>
<pre><code class="language-python">Nat = 0.. _
Odd = {N: Int | N % 2 == 1}
Char = StrWithLen 1
# StrWithLen 1 == {_: StrWithLen N | N == 1}
[Int; 3] == {_: Array Int, N | N == 3}
Array3OrMore == {A: Array _, N | N &gt;= 3}
</code></pre>
<p>當有多個 pred 時，可以用 <code>;</code> 或 <code>and</code> 或 <code>or</code> 分隔。<code>;</code> 和 <code>and</code> 的意思是一樣的</p>
<p><code>Odd</code> 的元素是 <code>1, 3, 5, 7, 9, ...</code>
它被稱為細化類型，因為它的元素是現有類型的一部分，就好像它是細化一樣</p>
<p><code>Pred</code> 被稱為(左側)謂詞表達式。和賦值表達式一樣，它不返回有意義的值，左側只能放置一個模式
也就是說，諸如<code>X**2 - 5X + 6 == 0</code>之類的表達式不能用作細化類型的謂詞表達式。在這方面，它不同于右側的謂詞表達式</p>
<pre><code class="language-python">{X: Int | X**2 - 5X + 6 == 0} # 語法錯誤: 謂詞形式無效。只有名字可以在左邊
</code></pre>
<p>如果你知道如何解二次方程，你會期望上面的細化形式等價于<code>{2, 3}</code>
但是，Erg 編譯器對代數的了解很少，因此無法解決右邊的謂詞</p>
<h2 id="智能投射"><a class="header" href="#智能投射">智能投射</a></h2>
<p>很高興您定義了 <code>Odd</code>，但事實上，它看起來不能在文字之外使用太多。要將普通 <code>Int</code> 對象中的奇數提升為 <code>Odd</code>，即將 <code>Int</code> 向下轉換為 <code>Odd</code>，您需要傳遞 <code>Odd</code> 的構造函數
對于細化類型，普通構造函數 <code>.new</code> 可能會出現恐慌，并且有一個名為 <code>.try_new</code> 的輔助構造函數返回一個 <code>Result</code> 類型</p>
<pre><code class="language-python">i = Odd.new (0..10).sample!()
i: Odd # or Panic
</code></pre>
<p>它也可以用作 <code>match</code> 中的類型說明</p>
<pre><code class="language-python"># i: 0..10
i = (0..10).sample!
match i:
    o: Odd -&gt;
        log &quot;i: Odd&quot;
    n: Nat -&gt; # 0..10 &lt; Nat
        log &quot;i: Nat&quot;
</code></pre>
<p>但是，Erg 目前無法做出諸如&quot;偶數&quot;之類的子決策，因為它不是&quot;奇數&quot;等</p>
<h2 id="枚舉區間和篩選類型"><a class="header" href="#枚舉區間和篩選類型">枚舉、區間和篩選類型</a></h2>
<p>前面介紹的枚舉/區間類型是細化類型的語法糖
<code>{a, b, ...}</code> 是 <code>{I: Typeof(a) | I == a 或 I == b 或 ... }</code>，并且 <code>a..b</code> 被去糖化為 <code>{I: Typeof(a) | 我 &gt;= a 和我 &lt;= b}</code></p>
<pre><code class="language-python">{1, 2} == {I: Int | I == 1 or I == 2}
1..10 == {I: Int | I &gt;= 1 and I &lt;= 10}
1... &lt;10 == {I: Int | I &gt;= 1 and I &lt; 10}
</code></pre>
<h2 id="細化模式"><a class="header" href="#細化模式">細化模式</a></h2>
<p>正如 <code>_: {X}</code> 可以重寫為 <code>X</code>(常量模式)，<code>_: {X: T | Pred}</code> 可以重寫為<code>X: T | Pred</code></p>
<pre><code class="language-python"># 方法 `.m` 是為長度為 3 或更大的數組定義的
Array(T, N | N &gt;= 3)
    .m(&amp;self) = ...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代數類型"><a class="header" href="#代數類型">代數類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/13_algebraic.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/13_algebraic.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>代數類型是通過將類型視為代數來操作類型而生成的類型
它們處理的操作包括Union、Intersection、Diff、Complement等
普通類只能進行Union，其他操作會導致類型錯誤</p>
<h2 id="聯合union"><a class="header" href="#聯合union">聯合(Union)</a></h2>
<p>聯合類型可以為類型提供多種可能性。顧名思義，它們是由&quot;或&quot;運算符生成的
一個典型的 Union 是 <code>Option</code> 類型。<code>Option</code> 類型是 <code>T 或 NoneType</code> 補丁類型，主要表示可能失敗的值</p>
<pre><code class="language-python">IntOrStr = Int or Str
assert dict.get(&quot;some key&quot;) in (Int or NoneType)

# 隱式變為 `T != NoneType`
Option T = T or NoneType
</code></pre>
<h2 id="路口"><a class="header" href="#路口">路口</a></h2>
<p>交集類型是通過將類型與 <code>and</code> 操作組合得到的</p>
<pre><code class="language-python">Num = Add and Sub and Mul and Eq
</code></pre>
<p>如上所述，普通類不能與&quot;and&quot;操作結合使用。這是因為實例只屬于一個類</p>
<h2 id="差異"><a class="header" href="#差異">差異</a></h2>
<p>Diff 類型是通過 <code>not</code> 操作獲得的
最好使用 <code>and not</code> 作為更接近英文文本的符號，但建議只使用 <code>not</code>，因為它更適合與 <code>and</code> 和 <code>or</code> 一起使用</p>
<pre><code class="language-python">CompleteNum = Add and Sub and Mul and Div and Eq and Ord
Num = CompleteNum not Div not Ord

True = Bool not {False}
OneTwoThree = {1, 2, 3, 4, 5, 6} - {4, 5, 6, 7, 8, 9, 10}
</code></pre>
<h2 id="補充"><a class="header" href="#補充">補充</a></h2>
<p>補碼類型是通過 <code>not</code> 操作得到的，這是一個一元操作。<code>not T</code> 類型是 <code>{=} not T</code> 的簡寫
類型為&quot;非 T&quot;的交集等價于 Diff，類型為&quot;非 T&quot;的 Diff 等價于交集
但是，不推薦這種寫法</p>
<pre><code class="language-python"># 非零數類型的最簡單定義
NonZero = Not {0}
# 不推薦使用的樣式
{True} == Bool and not {False} # 1 == 2 + - 1
Bool == {True} not not {False} # 2 == 1 - -1
</code></pre>
<h2 id="真代數類型"><a class="header" href="#真代數類型">真代數類型</a></h2>
<p>有兩種代數類型: 可以簡化的表觀代數類型和不能進一步簡化的真實代數類型
&quot;表觀代數類型&quot;包括 Enum、Interval 和 Record 類型的 <code>or</code> 和 <code>and</code>
這些不是真正的代數類型，因為它們被簡化了，并且將它們用作類型說明符將導致警告； 要消除警告，您必須簡化它們或定義它們的類型</p>
<pre><code class="language-python">assert {1, 2, 3} or {2, 3} == {1, 2, 3}
assert {1, 2, 3} and {2, 3} == {2, 3}
assert -2..-1 or 1..2 == {-2, -1, 1, 2}

i: {1, 2} or {3, 4} = 1 # 類型警告: {1, 2} 或 {3, 4} 可以簡化為 {1, 2, 3, 4}
p: {x = Int, ...} and {y = Int; ...} = {x = 1; y = 2; z = 3}
# 類型警告: {x = Int, ...} 和 {y = Int; ...} 可以簡化為 {x = Int; y = 整數； ...}

Point1D = {x = Int; ...}
Point2D = Point1D and {y = Int; ...} # == {x = Int; y = Int; ...}
q: Point2D = {x = 1; y = 2; z = 3}
</code></pre>
<p>真正的代數類型包括類型&quot;或&quot;和&quot;與&quot;。類之間的&quot;或&quot;等類屬于&quot;或&quot;類型</p>
<pre><code class="language-python">assert Int or Str == Or(Int, Str)
assert Int and Marker == And(Int, Marker)
</code></pre>
<p>Diff, Complement 類型不是真正的代數類型，因為它們總是可以被簡化</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="依賴類型"><a class="header" href="#依賴類型">依賴類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/14_dependent.md&amp;commit_hash=00682a94603fed2b531898200a79f2b4a64d5aae"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/14_dependent.md%26commit_hash%3D00682a94603fed2b531898200a79f2b4a64d5aae" alt="badge" /></a></p>
<p>依賴類型是一個特性，可以說是 Erg 的最大特性
依賴類型是將值作為參數的類型。普通的多態類型只能將類型作為參數，但依賴類型放寬了這個限制</p>
<p>依賴類型等價于<code>[T; N]</code>(<code>數組(T，N)</code>)
這種類型不僅取決于內容類型&quot;T&quot;，還取決于內容數量&quot;N&quot;。<code>N</code> 包含一個<code>Nat</code> 類型的對象</p>
<pre><code class="language-python">a1 = [1, 2, 3]
assert a1 in [Nat; 3]
a2 = [4, 5, 6, 7]
assert a1 in [Nat; 4]
assert a1 + a2 in [Nat; 7]
</code></pre>
<p>如果函數參數中傳遞的類型對象與返回類型有關，則寫: </p>
<pre><code class="language-python">narray: |N: Nat| {N} -&gt; [{N}; N]
narray(N: Nat): [N; N] = [N; N]
assert array(3) == [3, 3, 3]
</code></pre>
<p>定義依賴類型時，所有類型參數都必須是常量</p>
<p>依賴類型本身存在于現有語言中，但 Erg 具有在依賴類型上定義過程方法的特性</p>
<pre><code class="language-python">x=1
f x =
    print! f::x, module::x

# Phantom 類型有一個名為 Phantom 的屬性，其值與類型參數相同
T X: Int = Class Impl := Phantom X
T(X).
    x self = self::Phantom

T(1).x() # 1
</code></pre>
<p>可變依賴類型的類型參數可以通過方法應用程序進行轉換
轉換規范是用 <code>~&gt;</code> 完成的</p>
<pre><code class="language-python"># 注意 `Id` 是不可變類型，不能轉換
VM!(State: {&quot;stopped&quot;, &quot;running&quot;}! := _, Id: Nat := _) = Class(..., Impl := Phantom! State)
VM!().
    # 不改變的變量可以通過傳遞`_`省略
    start! ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.initialize_something!()
        self::set_phantom!(&quot;running&quot;)

# 你也可以按類型參數切出(僅在定義它的模塊中)
VM!.new() = VM!(!&quot;stopped&quot;, 1).new()
VM!(&quot;running&quot; ~&gt; &quot;running&quot;).stop!ref!self =
    self.close_something!()
    self::set_phantom!(&quot;stopped&quot;)

vm = VM!.new()
vm.start!()
vm.stop!()
vm.stop!() # 類型錯誤: VM!(!&quot;stopped&quot;, 1) 沒有 .stop!()
# 提示: VM!(!&quot;running&quot;, 1) 有 .stop!()
</code></pre>
<p>您還可以嵌入或繼承現有類型以創建依賴類型</p>
<pre><code class="language-python">MyArray(T, N) = Inherit[T; N]

# self 的類型: Self(T, N) 與 .array 一起變化
MyStruct!(T, N: Nat!) = Class {.array: [T; !N]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型變量量化類型"><a class="header" href="#類型變量量化類型">類型變量，量化類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/15_quantified.md&amp;commit_hash=00682a94603fed2b531898200a79f2b4a64d5aae"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/15_quantified.md%26commit_hash%3D00682a94603fed2b531898200a79f2b4a64d5aae" alt="badge" /></a></p>
<p>類型變量是用于例如指定子程序參數類型的變量，它的類型是任意的(不是單態的)
首先，作為引入類型變量的動機，考慮 <code>id</code> 函數，它按原樣返回輸入</p>
<pre><code class="language-python">id x: Int = x
</code></pre>
<p>返回輸入的&quot;id&quot;函數是為&quot;Int&quot;類型定義的，但這個函數顯然可以為任何類型定義
讓我們使用 <code>Object</code> 來表示最大的類</p>
<pre><code class="language-python">id x: Object = x

i = id 1
s = id &quot;foo&quot;
b = id True
</code></pre>
<p>當然，它現在接受任意類型，但有一個問題: 返回類型被擴展為 <code>Object</code>。返回類型擴展為 <code>Object</code>
如果輸入是&quot;Int&quot;類型，我想查看返回類型&quot;Int&quot;，如果輸入是&quot;Str&quot;類型，我想查看&quot;Str&quot;</p>
<pre><code class="language-python">print! id 1 # &lt;Object object&gt;
id(1) + 1 # 類型錯誤: 無法添加 `Object` 和 `Int
</code></pre>
<p>要確保輸入的類型與返回值的類型相同，請使用 <strong>type 變量</strong>
類型變量在<code>||</code>(類型變量列表)中聲明</p>
<pre><code class="language-python">id|T: Type| x: T = x
assert id(1) == 1
assert id(&quot;foo&quot;) == &quot;foo&quot;
assert id(True) == True
</code></pre>
<p>這稱為函數的 <strong>universal quantification(泛化)</strong>。有細微的差別，但它對應于其他語言中稱為泛型的函數。泛化函數稱為__多態函數__
定義一個多態函數就像為所有類型定義一個相同形式的函數(Erg 禁止重載，所以下面的代碼真的不能寫)</p>
<pre><code class="language-python">id|T: Type| x: T = x
# 偽代碼
id x: Int = x
id x: Str = x
id x: Bool = x
id x: Ratio = x
id x: NoneType = x
...
</code></pre>
<p>此外，類型變量&quot;T&quot;可以推斷為&quot;Type&quot;類型，因為它在類型規范中使用。所以 <code>|T: Type|</code> 可以簡單地縮寫為 <code>|T|</code>
你也可以省略<code>|T, N| 腳; N]</code> 如果可以推斷它不是類型對象(<code>T: Type, N: Nat</code>)</p>
<p>如果類型對于任意類型來說太大，您也可以提供約束
約束也有優勢，例如，子類型規范允許使用某些方法</p>
<pre><code class="language-python"># T &lt;: Add
# =&gt; T 是 Add 的子類
# =&gt; 可以做加法
add|T &lt;: Add| l: T, r: T = l + r
</code></pre>
<p>在本例中，<code>T</code> 必須是<code>Add</code> 類型的子類，并且要分配的<code>l</code> 和<code>r</code> 的實際類型必須相同
在這種情況下，&quot;T&quot;由&quot;Int&quot;、&quot;Ratio&quot;等滿足。因此，例如，&quot;Int&quot;和&quot;Str&quot;的添加沒有定義，因此被拒絕</p>
<p>您也可以像這樣鍵入它</p>
<pre><code class="language-python">f|
    Y, Z: Type
    X &lt;: Add Y, O1
    O1 &lt;: Add Z, O2
    O2 &lt;: Add X, _
| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>如果注釋列表很長，您可能需要預先聲明它</p>
<pre><code class="language-python">f: |Y, Z: Type, X &lt;: Add(Y, O1), O1 &lt;: Add(Z, O2), O2 &lt;: Add(X, O3)| (X, Y, Z) -&gt; O3
f|X, Y, Z| x: X, y: Y, z: Z =
    x + y + z + x
</code></pre>
<p>與許多具有泛型的語言不同，所有聲明的類型變量都必須在臨時參數列表(<code>x: X, y: Y, z: Z</code> 部分)或其他類型變量的參數中使用
這是 Erg 語言設計的一個要求，即所有類型變量都可以從真實參數中推斷出來
因此，無法推斷的信息，例如返回類型，是從真實參數傳遞的； Erg 允許從實參傳遞類型</p>
<pre><code class="language-python">Iterator T = Trait {
    # 從參數傳遞返回類型
    # .collect: |K: Type -&gt; Type| Self(T). ({K}) -&gt; K(T)
    .collect(self, K: Type -&gt; Type): K(T) = ...
    ...
}

it = [1, 2, 3].iter().map i -&gt; i + 1
it.collect(Array) # [2, 3, 4].
</code></pre>
<p>類型變量只能在 <code>||</code> 期間聲明。但是，一旦聲明，它們就可以在任何地方使用，直到它們退出作用域</p>
<pre><code class="language-python">f|X|(x: X): () =
    y: X = x.clone()
    log X.__name__
    log X

f 1
# Int
# &lt;class Int&gt;
</code></pre>
<p>您也可以在使用時明確單相如下</p>
<pre><code class="language-python">f: Int -&gt; Int = id|Int|
</code></pre>
<p>在這種情況下，指定的類型優先于實際參數的類型(匹配失敗將導致類型錯誤，即實際參數的類型錯誤)
即如果傳遞的實際對象可以轉換為指定的類型，則進行轉換； 否則會導致編譯錯誤</p>
<pre><code class="language-python">assert id(1) == 1
assert id|Int|(1) in Int
assert id|Ratio|(1) in Ratio
# 你也可以使用關鍵字參數
assert id|T: Int|(1) == 1
id|Int|(&quot;str&quot;) # 類型錯誤: id|Int| is type `Int -&gt; Int`但得到了 Str
</code></pre>
<p>當此語法與理解相沖突時，您需要將其括在 <code>()</code> 中</p>
<pre><code class="language-python"># {id|Int| x | x &lt;- 1..10} 將被解釋為 {id | ...}
{(id|Int| x) | x &lt;- 1..10}
</code></pre>
<p>不能使用與已存在的類型相同的名稱來聲明類型變量。這是因為所有類型變量都是常量</p>
<pre><code class="language-python">I: Type
# ↓ 無效類型變量，已經存在
f|I: Type| ... = ...
</code></pre>
<h2 id="在方法定義中輸入參數"><a class="header" href="#在方法定義中輸入參數">在方法定義中輸入參數</a></h2>
<p>默認情況下，左側的類型參數被視為綁定變量</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(T, N).
    foo(x) = ...
</code></pre>
<p>使用另一個類型變量名稱將導致警告</p>
<pre><code class="language-python">K(T: Type, N: Nat) = ...
K(U, M). # 警告: K 的類型變量名是 'T' 和 'N'
    foo(x) = ...
</code></pre>
<p>自定義以來，所有命名空間中的常量都是相同的，因此它們當然不能用于類型變量名稱</p>
<pre><code class="language-python">N = 1
K(N: Nat) = ... # 名稱錯誤: N 已定義

L(M: Nat) = ...
# 僅當 M == N == 1 時才定義
L(N).
    foo(self, x) = ...
# 為任何定義 M: Nat
L(M).
    .bar(self, x) = ...
</code></pre>
<p>每個類型參數不能有多個定義，但可以定義具有相同名稱的方法，因為未分配類型參數的依賴類型(非原始類型)和分配的依賴類型(原始類型)之間沒有關系 )</p>
<pre><code class="language-python">K(I: Int) = ...
K.
    # K 不是真正的類型(atomic Kind)，所以我們不能定義方法
    # 這不是方法(更像是靜態方法)
    foo(x) = ...
K(0).
    foo(self, x): Nat = ...
</code></pre>
<h2 id="所有對稱類型"><a class="header" href="#所有對稱類型">所有對稱類型</a></h2>
<p>上一節中定義的 <code>id</code> 函數是一個可以是任何類型的函數。那么 <code>id</code> 函數本身的類型是什么?</p>
<pre><code class="language-python">print! classof(id) # |T: Type| T -&gt; T
</code></pre>
<p>我們得到一個類型<code>|T: Type| T -&gt; T</code>。這稱為一個 <strong>封閉的全稱量化類型/全稱類型</strong>，即<code>['a. ...]'</code> 在 ML 和 <code>forall t. ...</code> 在 Haskell 中。為什么使用形容詞&quot;關閉&quot;將在下面討論</p>
<p>封閉的全稱量化類型有一個限制: 只有子程序類型可以被通用量化，即只有子程序類型可以放在左子句中。但這已經足夠了，因為子程序是 Erg 中最基本的控制結構，所以當我們說&quot;我要處理任意 X&quot;時，即我想要一個可以處理任意 X 的子程序。所以，量化類型具有相同的含義 作為多態函數類型。從現在開始，這種類型基本上被稱為多態函數類型</p>
<p>與匿名函數一樣，多態類型具有任意類型變量名稱，但它們都具有相同的值</p>
<pre><code class="language-python">assert (|T: Type| T -&gt; T) == (|U: Type| U -&gt; U)
</code></pre>
<p>當存在 alpha 等價時，等式得到滿足，就像在 lambda 演算中一樣。由于對類型的操作有一些限制，所以總是可以確定等價的(如果我們不考慮 stoppage 屬性)</p>
<h2 id="多態函數類型的子類型化"><a class="header" href="#多態函數類型的子類型化">多態函數類型的子類型化</a></h2>
<p>多態函數類型可以是任何函數類型。這意味著與任何函數類型都存在子類型關系。讓我們詳細看看這種關系</p>
<p>類型變量在左側定義并在右側使用的類型，例如 <code>OpenFn T: Type = T -&gt; T</code>，稱為 <strong>open 通用類型</strong>
相反，在右側定義和使用類型變量的類型，例如 <code>ClosedFn = |T: Type| T -&gt; T</code>，被稱為 <strong>封閉的通用類型</strong></p>
<p>開放通用類型是所有同構&quot;真&quot;類型的超類型。相反，封閉的通用類型是所有同構真類型的子類型</p>
<pre><code class="language-python">(|T: Type| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)
</code></pre>
<p>您可能還記得封閉的較小/開放的較大
但為什么會這樣呢? 為了更好地理解，讓我們考慮每個實例</p>
<pre><code class="language-python"># id: |T: Type| T -&gt; T
id|T|(x: T): T = x

# iid: Int -&gt; Int
iid(x: Int): Int = x

# 按原樣返回任意函數
id_arbitrary_fn|T|(f1: T -&gt; T): (T -&gt; T) = f
# id_arbitrary_fn(id) == id
# id_arbitrary_fn(iid) == iid

# return the poly correlation number as it is
id_poly_fn(f2: (|T| T -&gt; T)): (|T| T -&gt; T) = f
# id_poly_fn(id) == id
id_poly_fn(iid) # 類型錯誤

# 按原樣返回 Int 類型函數
id_int_fn(f3: Int -&gt; Int): (Int -&gt; Int) = f
# id_int_fn(id) == id|Int|
# id_int_fn(iid) == iid
</code></pre>
<p>由于 <code>id</code> 是 <code>|T: Type| 類型T -&gt; T</code>，可以賦值給<code>Int-&gt; Int</code>類型的參數<code>f3</code>，我們可以考慮<code>(|T| T -&gt; T) &lt; (Int -&gt; Int)</code>
反之，<code>Int -&gt; Int</code>類型的<code>iid</code>不能賦值給<code>(|T| T -&gt; T)</code>類型的參數<code>f2</code>，但可以賦值給<code>(|T| T -&gt; T)</code>的參數<code>f1</code>輸入 <code>T -&gt; T</code>，所以 <code>(Int -&gt; Int) &lt; (T -&gt; T)</code>
因此，確實是<code>(|T| T -&gt; T) &lt; (Int -&gt; Int) &lt; (T -&gt; T)</code></p>
<h2 id="量化類型和依賴類型"><a class="header" href="#量化類型和依賴類型">量化類型和依賴類型</a></h2>
<p>依賴類型和量化類型(多態函數類型)之間有什么關系，它們之間有什么區別?
我們可以說依賴類型是一種接受參數的類型，而量化類型是一種賦予參數任意性的類型</p>
<p>重要的一點是封閉的多態類型本身沒有類型參數。例如，多態函數類型<code>|T| T -&gt; T</code> 是一個接受多態函數 <strong>only</strong> 的類型，它的定義是封閉的。您不能使用其類型參數<code>T</code>來定義方法等</p>
<p>在 Erg 中，類型本身也是一個值，因此帶參數的類型(例如函數類型)可能是依賴類型。換句話說，多態函數類型既是量化類型又是依賴類型</p>
<pre><code class="language-python">PolyFn = Patch(|T| T -&gt; T)
PolyFn.
    type self = T # 名稱錯誤: 找不到&quot;T&quot;
DepFn T = Patch(T -&gt; T)
DepFn.
    type self =
        log &quot;by DepFn&quot;
        T

assert (Int -&gt; Int).type() == Int # 由 DepFn
assert DepFn(Int).type() == Int # 由 DepFn
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子類型"><a class="header" href="#子類型">子類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/16_subtyping.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/16_subtyping.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<p>在 Erg 中，可以使用比較運算符 <code>&lt;</code>、<code>&gt;</code> 確定類包含</p>
<pre><code class="language-python">Nat &lt; Int
Int &lt; Object
1... _ &lt; Nat
{1, 2} &gt; {1}
{=} &gt; {x = Int}
{I: Int | I &gt;= 1} &lt; {I: Int | I &gt;= 0}
</code></pre>
<p>請注意，這與 <code>&lt;:</code> 運算符的含義不同。它聲明左側的類是右側類型的子類型，并且僅在編譯時才有意義</p>
<pre><code class="language-python">C &lt;: T # T: 結構類型
f|D &lt;: E| ...

assert F &lt; G
</code></pre>
<p>您還可以為多態子類型規范指定 <code>Self &lt;: Add</code>，例如 <code>Self(R, O) &lt;: Add(R, O)</code></p>
<h2 id="結構類型和類類型關系"><a class="header" href="#結構類型和類類型關系">結構類型和類類型關系</a></h2>
<p>結構類型是結構類型的類型，如果它們具有相同的結構，則被認為是相同的對象</p>
<pre><code class="language-python">T = Structural {i = Int}
U = Structural {i = Int}

assert T == U
t: T = {i = 1}
assert t in T
assert t in U
</code></pre>
<p>相反，類是符號類型的類型，不能在結構上與類型和實例進行比較</p>
<pre><code class="language-python">C = Class {i = Int}
D = Class {i = Int}

assert C == D # 類型錯誤: 無法比較類
c = C.new {i = 1}
assert c in C
assert not c in D
</code></pre>
<h2 id="子程序的子類型化"><a class="header" href="#子程序的子類型化">子程序的子類型化</a></h2>
<p>子例程的參數和返回值只采用一個類
換句話說，您不能直接將結構類型或Trait指定為函數的類型
必須使用部分類型規范將其指定為&quot;作為該類型子類型的單個類&quot;</p>
<pre><code class="language-python"># OK
f1 x, y: Int = x + y
# NG
f2 x, y: Add = x + y
# OK
# A 是一些具體的類
f3&lt;A &lt;: Add&gt; x, y: A = x + y
</code></pre>
<p>子程序中的類型推斷也遵循此規則。當子例程中的變量具有未指定的類型時，編譯器首先檢查它是否是其中一個類的實例，如果不是，則在Trait范圍內查找匹配項。如果仍然找不到，則會發生編譯錯誤。此錯誤可以通過使用結構類型來解決，但由于推斷匿名類型可能會給程序員帶來意想不到的后果，因此它被設計為由程序員使用 <code>Structural</code> 顯式指定</p>
<h2 id="類向上轉換"><a class="header" href="#類向上轉換">類向上轉換</a></h2>
<pre><code class="language-python">i: Int
i as (Int or Str)
i as (1..10)
i as {I: Int | I &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型轉換"><a class="header" href="#類型轉換">類型轉換</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/17_type_casting.md&amp;commit_hash=b713e6f5cf9570255ccf44d14166cb2a9984f55a"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/17_type_casting.md%26commit_hash%3Db713e6f5cf9570255ccf44d14166cb2a9984f55a" alt="badge" /></a></p>
<h2 id="向上轉換"><a class="header" href="#向上轉換">向上轉換</a></h2>
<p>因為 Python 是一種使用鴨子類型的語言，所以沒有強制轉換的概念。沒有必要向上轉換，本質上也沒有向下轉換
但是，Erg 是靜態類型的，因此有時必須進行強制轉換
一個簡單的例子是 <code>1 + 2.0</code>: <code>+</code>(Int, Ratio) 或 Int(&lt;: Add(Ratio, Ratio)) 操作在 Erg 語言規范中沒有定義。這是因為 <code>Int &lt;: Ratio</code>，所以 1 向上轉換為 1.0，即 Ratio 的一個實例</p>
<p>~~ Erg擴展字節碼在BINARY_ADD中增加了類型信息，此時類型信息為Ratio-Ratio。在這種情況下，BINARY_ADD 指令執行 Int 的轉換，因此沒有插入指定轉換的特殊指令。因此，例如，即使您在子類中重寫了某個方法，如果您將父類指定為類型，則會執行類型強制，并在父類的方法中執行該方法(在編譯時執行名稱修改以引用父母的方法)。編譯器只執行類型強制驗證和名稱修改。運行時不強制轉換對象(當前。可以實現強制轉換指令以優化執行)。~~</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    # Override 需要 Override 裝飾器
    @Override
    greet!() = print! &quot;Hello from Child&quot;

greet! p: Parent = p.greet!()

parent = Parent.new()
child = Child.new()

parent # 來自Parent的問候！
child #  來自child的問候！
</code></pre>
<p>此行為不會造成與 Python 的不兼容。首先，Python 沒有指定變量的類型，所以可以這么說，所有的變量都是類型變量。由于類型變量會選擇它們可以適應的最小類型，因此如果您沒有在 Erg 中指定類型，則可以實現與 Python 中相同的行為</p>
<pre><code class="language-python">@Inheritable
Parent = Class()
Parent.
    greet!() = print! &quot;Hello from Parent&quot;

Child = Inherit Parent
Child.
    greet!() = print! &quot;Hello from Child&quot; Child.

greet! some = some.greet!()

parent = Parent.new()
child = Child.new()

parent # 來自Parent的問候！
child  # 來自child的問候！
</code></pre>
<p>您還可以使用 <code>.from</code> 和 <code>.into</code>，它們會為相互繼承的類型自動實現</p>
<pre><code class="language-python">assert 1 == 1.0
assert Ratio.from(1) == 1.0
assert 1.into&lt;Ratio&gt;() == 1.0
</code></pre>
<h2 id="向下轉換"><a class="header" href="#向下轉換">向下轉換</a></h2>
<p>由于向下轉換通常是不安全的并且轉換方法很重要，我們改為實現<code>TryFrom.try_from</code></p>
<pre><code class="language-python">IntTryFromFloat = Patch Int
IntTryFromFloat.
    try_from r: Float =
        if r.ceil() == r:
            then: r.ceil()
            else: Error &quot;conversion failed&quot;.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變類型"><a class="header" href="#可變類型">可變類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/18_mut.md&amp;commit_hash=00682a94603fed2b531898200a79f2b4a64d5aae"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/18_mut.md%26commit_hash%3D00682a94603fed2b531898200a79f2b4a64d5aae" alt="badge" /></a></p>
<blockquote>
<p><strong>Warning</strong>: 本節中的信息是舊的并且包含一些錯誤</p>
</blockquote>
<p>默認情況下，Erg 中的所有類型都是不可變的，即它們的內部狀態無法更新
但是你當然也可以定義可變類型。變量類型用 <code>!</code> 聲明</p>
<pre><code class="language-python">Person! = Class({name = Str; age = Nat!})
Person!.
    greet! ref! self = print! &quot;Hello, my name is {self::name}. I am {self::age}.&quot;
    inc_age!ref!self = self::name.update!old -&gt; old + 1
</code></pre>
<p>準確地說，基類型是可變類型或包含可變類型的復合類型的類型必須在類型名稱的末尾有一個&quot;！&quot;。沒有 <code>!</code> 的類型可以存在于同一個命名空間中，并被視為單獨的類型
在上面的例子中，<code>.age</code> 屬性是可變的，<code>.name</code> 屬性是不可變的。如果即使一個屬性是可變的，那么整個屬性也是可變的</p>
<p>可變類型可以定義重寫實例的過程方法，但具有過程方法并不一定使它們可變。例如數組類型<code>[T; N]</code> 實現了一個 <code>sample!</code> 隨機選擇一個元素的方法，但當然不會破壞性地修改數組</p>
<p>對可變對象的破壞性操作主要是通過 .update! 方法完成的。<code>.update!</code> 方法是一個高階過程，它通過應用函數 <code>f</code> 來更新 <code>self</code></p>
<pre><code class="language-python">i = !1
i.update! old -&gt; old + 1
assert i == 2
</code></pre>
<p><code>.set!</code> 方法只是丟棄舊內容并用新值替換它。.set!x = .update!_ -&gt; x</p>
<pre><code class="language-python">i = !1
i.set! 2
assert i == 2
</code></pre>
<p><code>.freeze_map</code> 方法對不變的值進行操作</p>
<pre><code class="language-python">a = [1, 2, 3].into [Nat; !3]
x = a.freeze_map a: [Nat; 3] -&gt; a.iter().map(i -&gt; i + 1).filter(i -&gt; i % 2 == 0).collect(Array)
</code></pre>
<p>在多態不可變類型中，該類型的類型參數&quot;T&quot;被隱式假定為不可變</p>
<pre><code class="language-python"># ImmutType &lt; Type
KT: ImmutType = Class ...
K!T: Type = Class ...
</code></pre>
<p>在標準庫中，變量 <code>(...)!</code> 類型通常基于不可變 <code>(...)</code> 類型。但是，<code>T!</code> 和 <code>T</code> 類型沒有特殊的語言關系，并且不能這樣構造 <a href="type/18_mut.html#1"><sup id="f1">1</sup></a> </p>
<p>請注意，有幾種類型的對象可變性
下面我們將回顧內置集合類型的不可變/可變語義</p>
<pre><code class="language-python"># 數組類型
## 不可變類型
[T; N] # 不能執行可變操作
## 可變類型
[T; N] # 可以一一改變內容
[T; !N] # 可變長度，內容不可變但可以通過添加/刪除元素來修改
[!T; N] # 內容是不可變的對象，但是可以替換成不同的類型(實際上可以通過不改變類型來替換)
[!T; !N] # 類型和長度可以改變
[T; !N] # 內容和長度可以改變
[!T!; N] # 內容和類型可以改變
[!T!; !N] # 可以執行各種可變操作
</code></pre>
<p>當然，您不必全部記住和使用它們
對于可變數組類型，只需將 <code>!</code> 添加到您想要可變的部分，實際上是 <code>[T; N]</code>, <code>[T!; N]</code>，<code>[T; !N]</code>, <code> [T!; !N]</code> 可以涵蓋大多數情況</p>
<p>這些數組類型是語法糖，實際類型是: </p>
<pre><code class="language-python"># actually 4 types
[T; N] = Array(T, N)
[T; !N] = Array!(T, !N)
[!T; N] = ArrayWithMutType!(!T, N)
[!T; !N] = ArrayWithMutTypeAndLength!(!T, !N)
[T!; !N] = Array!(T!, !N)
[!T!; N] = ArrayWithMutType!(!T!, N)
[!T!; !N] = ArrayWithMutTypeAndLength!(!T!, !N)
</code></pre>
<p>這就是能夠改變類型的意思</p>
<pre><code class="language-python">a = [1, 2, 3].into [!Nat; 3]
a.map!(_ -&gt; &quot;a&quot;)
a: [!Str; 3]
</code></pre>
<p>其他集合類型也是如此</p>
<pre><code class="language-python"># 元組類型
## 不可變類型
(T, U) # 元素個數不變，內容不能變
## 可變類型
(T!, U) # 元素個數不變，第一個元素可以改變
(T，U)！ # 元素個數不變，內容可以替換
...
</code></pre>
<pre><code class="language-python"># 設置類型
## 不可變類型
{T; N} # 不可變元素個數，內容不能改變
## 可變類型
{T！; N} # 不可變元素個數，內容可以改變(一個一個)
{T; N}！ # 可變元素個數，內容不能改變
{T！; N}！ # 可變元素個數，內容可以改變
...
</code></pre>
<pre><code class="language-python"># 字典類型
## 不可變類型
{K: V} # 長度不可變，內容不能改變
## 可變類型
{K:V!} # 恒定長度，值可以改變(一一)
{K: V}！ # 可變長度，內容不能改變，但可以通過添加或刪除元素來增加或刪除，內容類型也可以改變
...
</code></pre>
<pre><code class="language-python"># 記錄類型
## 不可變類型
{x = Int; y = Str} # 內容不能改變
## 可變類型
{x = Int！; y = Str} # 可以改變x的值
{x = Int; y = Str}！ # 替換 {x = Int; 的任何實例 y = Str}
...
</code></pre>
<p>一個類型 <code>(...)</code> 簡單地變成了 <code>T! = (...)!</code> 當 <code>T = (...)</code> 被稱為簡單結構化類型。簡單的結構化類型也可以(語義上)說是沒有內部結構的類型
數組、元組、集合、字典和記錄類型都是非簡單的結構化類型，但 Int 和 Sieve 類型是</p>
<pre><code class="language-python"># 篩子類型
## 枚舉
{1, 2, 3} # 1, 2, 3 之一，不可更改
{1、2、3}！ # 1、2、3，可以改
## 區間類型
1..12 # 1到12，不能改
1..12！ # 1-12中的任意一個，你可以改變
## 篩型(普通型)
{I: Int | I % 2 == 0} # 偶數類型，不可變
{I: Int | I % 2 == 0} # 偶數類型，可以改變
{I: Int | I % 2 == 0}！ # 與上面完全相同的類型，但上面的表示法是首選
</code></pre>
<p>從上面的解釋來看，可變類型不僅包括自身可變的，還包括內部類型可變的
諸如 <code>{x: Int!}</code> 和 <code>[Int!; 之類的類型3]</code> 是內部可變類型，其中內部的對象是可變的，而實例本身是不可變的</p>
<p>對于具有內部結構并在類型構造函數本身上具有 <code>!</code> 的類型 <code>K!(T, U)</code>，<code>*self</code> 可以更改整個對象。也可以進行局部更改
但是，希望盡可能保持本地更改權限，因此如果只能更改 <code>T</code>，最好使用 <code>K(T!, U)</code>
而對于沒有內部結構的類型‘T!’，這個實例只是一個可以交換的‘T’盒子。方法不能更改類型</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> <code>T!</code> 和 <code>T</code> 類型沒有特殊的語言關系是有意的。這是一個設計。如果存在關系，例如命名空間中存在<code>T</code>/<code>T!</code>類型，則無法從其他模塊引入<code>T!</code>/<code>T</code>類型。此外，可變類型不是為不可變類型唯一定義的。給定定義 <code>T = (U, V)</code>，<code>T!</code> 的可能變量子類型是 <code>(U!, V)</code> 和 <code>(U, V!)</code>。<a href="type/18_mut.html#f1">?</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><p>下面，我們將討論更高級的類型系統。初學者不必閱讀所有部分。<a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced.md&amp;commit_hash=d15cbbf7b33df0f78a575cff9679d84c36ea3ab1"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced.md%26commit_hash%3Dd15cbbf7b33df0f78a575cff9679d84c36ea3ab1" alt="badge" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="帶默認參數的函數類型"><a class="header" href="#帶默認參數的函數類型">帶默認參數的函數類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/default_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/default_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>首先，讓我們看一個使用默認參數的示例</p>
<pre><code class="language-python">f: (Int, Int, z := Int) -&gt; Int
f(x, y, z := 0) = x + y + z

g: (Int, Int, z := Int, w := Int) -&gt; Int
g(x, y, z := 0, w := 1) = x + y + z + w

fold: ((Int, Int) -&gt; Int, [Int], acc := Int) -&gt; Int
fold(f, [], acc) = acc
fold(f, arr, acc := 0) = fold(f, arr[1..], f(acc, arr[0]))
assert fold(f, [1, 2, 3]) == 6
assert fold(g, [1, 2, 3]) == 8
</code></pre>
<p><code>:=</code> 之后的參數是默認參數
子類型規則如下:</p>
<pre><code class="language-python">((X, y := Y) -&gt; Z) &lt;: (X -&gt; Z)
((X, y := Y, ...) -&gt; Z) &lt;: ((X, ...) -&gt; Z)
</code></pre>
<p>第一個意味著可以用沒有默認參數的函數來識別具有默認參數的函數
第二個意味著可以省略任何默認參數。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="類型擦除"><a class="header" href="#類型擦除">類型擦除</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/erasure.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/erasure.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>類型擦除是將類型參數設置為 <code>_</code> 并故意丟棄其信息的過程。類型擦除是許多多態語言的特性，但在 Erg 的語法上下文中，將其稱為類型參數擦除更為準確</p>
<p>類型擦除的最常見示例是 <code>[T, _]</code>。數組在編譯時并不總是知道它們的長度。例如，引用命令行參數的 <code>sys.argv</code> 的類型為 <code>[Str, _]</code>。由于 Erg 的編譯器無法知道命令行參數的長度，因此必須放棄有關其長度的信息
然而，一個已經被類型擦除的類型變成了一個未被擦除的類型的超類型(例如<code>[T; N] &lt;: [T; _]</code>)，所以它可以接受更多的對象
類型的對象<code>[T; N]</code> 當然可以使用 <code>[T; _]</code>，但使用后會刪除<code>N</code>信息。如果長度沒有改變，那么可以使用<code>[T; N]</code> 在簽名中。如果長度保持不變，則必須由簽名指示</p>
<pre><code class="language-python"># 保證不改變數組長度的函數(例如，排序)
f: [T; N] -&gt; [T; N] # 沒有的函數 (f: [T; N])
# 沒有的功能(例如過濾器)
g: [T; n] -&gt; [T; _]
</code></pre>
<p>如果您在類型規范本身中使用 <code>_</code>，則類型將向上轉換為 <code>Object</code>
對于非類型類型參數(Int、Bool 等)，帶有 <code>_</code> 的參數將是未定義的</p>
<pre><code class="language-python">i: _ # i: Object
[_; _] == [Object; _] == Array
</code></pre>
<p>類型擦除與省略類型說明不同。一旦類型參數信息被刪除，除非您再次聲明它，否則它不會被返回</p>
<pre><code class="language-python">implicit = (1..5).iter().map(i -&gt; i * 2).to_arr()
explicit = (1..5).iter().map(i -&gt; i * 2).into(Array(Nat))
</code></pre>
<p>在 Rust 中，這對應于以下代碼:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let partial = (1..6).iter().map(|i| i * 2).collect::&lt;Vec&lt;_&gt;&gt;();
<span class="boring">}
</span></code></pre></pre>
<p>Erg 不允許部分省略類型，而是使用高階種類多態性</p>
<pre><code class="language-python"># collect 是采用 Kind 的高階 Kind 方法
hk = (1..5).iter().map(i -&gt; i * 2).collect(Array)
hk: Array(Int)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存在類型"><a class="header" href="#存在類型">存在類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/existential.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/existential.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>如果存在對應于?的for-all類型，那么很自然地假設存在對應于?的存在類型
存在類型并不難。你已經知道存在類型，只是沒有意識到它本身</p>
<pre><code class="language-python">T: Trait
f x: T = ...
</code></pre>
<p>上面的 trait <code>T</code> 被用作存在類型
相比之下，小寫的<code>T</code>只是一個Trait，<code>X</code>是一個for-all類型</p>
<pre><code class="language-python">f|X &lt;: T| x: X = ...
</code></pre>
<p>事實上，existential 類型被 for-all 類型所取代。那么為什么會有存在類型這樣的東西呢?
首先，正如我們在上面看到的，存在類型不涉及類型變量，這簡化了類型規范
此外，由于可以刪除類型變量，因此如果它是一個全推定類型，則可以構造一個等級為 2 或更高的類型</p>
<pre><code class="language-python">show_map f: (|T| T -&gt; T), arr: [Show; _] =
    arr.map x -&gt;
        y = f x
        log y
        y
</code></pre>
<p>但是，如您所見，existential 類型忘記或擴展了原始類型，因此如果您不想擴展返回類型，則必須使用 for-all 類型
相反，僅作為參數且與返回值無關的類型可以寫為存在類型</p>
<pre><code class="language-python"># id(1): 我希望它是 Int
id|T|(x: T): T = x
# |S &lt;: Show|(s: S) -&gt; () 是多余的
show(s: Show): () = log s
</code></pre>
<p>順便說一句，類不稱為存在類型。一個類不被稱為存在類型，因為它的元素對象是預定義的
存在類型是指滿足某種Trait的任何類型，它不是知道實際分配了什么類型的地方。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="廣義代數數據類型-gadt"><a class="header" href="#廣義代數數據類型-gadt">廣義代數數據類型 (GADT)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/GADTs.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/GADTs.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg 可以通過對 Or 類型進行分類來創建廣義代數數據類型 (GADT)</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
Cons T = Class {head = T; rest = List T}, Impl := Unpack
List T: Type = Class(Nil T or Cons T)
List.
    nil|T|() = Self(T).new Nil(T).new()
    cons head, rest | T = Self(T).new Cons(T).new(head, rest)
    head self = match self:
        {head; ...}: Cons_ -&gt; head
        _: Nil -&gt; panic &quot;empty list&quot;
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil.head() # 運行時錯誤: &quot;空list&quot;
</code></pre>
<p>我們說 <code>List.nil|T|() = ...</code> 而不是 <code>List(T).nil() = ...</code> 的原因是我們在使用它時不需要指定類型</p>
<pre><code class="language-python">i = List.nil()
_: List Int = cons 1, i
</code></pre>
<p>這里定義的 <code>List T</code> 是 GADTs，但它是一個幼稚的實現，并沒有顯示 GADTs 的真正價值
例如，上面的 .head 方法會在 body 為空時拋出運行時錯誤，但是這個檢查可以在編譯時進行</p>
<pre><code class="language-python">List: (Type, {&quot;Empty&quot;, &quot;Nonempty&quot;}) -&gt; Type
List T, &quot;Empty&quot; = Class(Impl := Phantom T)
List T, &quot;Nonempty&quot; = Class {head = T; rest = List(T, _)}, Impl := Unpack
List.
    nil|T|() = Self(T, &quot;Empty&quot;).new Nil(T).new()
    cons head, rest | T = Self(T, &quot;Nonempty&quot;).new {head; rest}
List(T, &quot;Nonempty&quot;).
    head {head; ...} = head
{nil; cons; ...} = List

print! cons(1, cons(2, nil())).head() # 1
print! nil().head() # 類型錯誤
</code></pre>
<p>街上經常解釋的 GADT 的一個例子是一個列表，可以像上面那樣通過類型來判斷內容是否為空
Erg 可以進一步細化以定義一個有長度的列表</p>
<pre><code class="language-python">List: (Type, Nat) -&gt; Type
List T, 0 = Class(Impl := Phantom T)
List T, N = Class {head = T; rest = List(T, N-1)}, Impl := Unpack
List.
    nil|T|() = Self(T, 0).new Nil(T).new()
    cons head, rest | T, N = Self(T, N).new {head; rest}
List(_, N | N &gt;= 1).
    head {head; ...} = head
List(_, N | N &gt;= 2).
    pair {head = first; rest = {head = second; ...}} = [first, second]
{nil; cons; ...} = List

print! cons(1, cons(2, nil)).pair() # [1, 2]
print! cons(1, nil).pair() # 類型錯誤
print! cons(1, nil).head() # 1
print! nil. head() # 類型錯誤
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="帶有關鍵字參數的函數類型"><a class="header" href="#帶有關鍵字參數的函數類型">帶有關鍵字參數的函數類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/keyword_param.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/keyword_param.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<pre><code class="language-python">h(f) = f(y: 1, x: 2)
h: |T: type|((y: Int, x: Int) -&gt; T) -&gt; T
</code></pre>
<p>帶有關鍵字參數的函數的子類型化規則如下</p>
<pre><code class="language-python">((x: T, y: U) -&gt; V) &lt;: ((T, U) -&gt; V) # x, y 為任意關鍵字參數
((y: U, x: T) -&gt; V) &lt;: ((x: T, y: U) -&gt; V)
((x: T, y: U) -&gt; V) &lt;: ((y: U, x: T) -&gt; V)
</code></pre>
<p>這意味著可以刪除或替換關鍵字參數
但是你不能同時做這兩件事
也就是說，您不能將 <code>(x: T, y: U) -&gt; V</code> 轉換為 <code>(U, T) -&gt; V</code>
請注意，關鍵字參數僅附加到頂級元組，而不附加到數組或嵌套元組</p>
<pre><code class="language-python">Valid: [T, U] -&gt; V
Invalid: [x: T, y: U] -&gt; V
Valid: (x: T, ys: (U,)) -&gt; V
Invalid: (x: T, ys: (y: U,)) -&gt; V
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kind"><a class="header" href="#kind">Kind</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/kind.md&amp;commit_hash=b07c17708b9141bbce788d2e5b3ad4f365d342fa"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/kind.md%26commit_hash%3Db07c17708b9141bbce788d2e5b3ad4f365d342fa" alt="badge" /></a></p>
<p>一切都在 Erg 中輸入。類型本身也不例外。<strong>kind</strong> 表示&quot;類型的類型&quot;。例如，<code>Int</code> 屬于 <code>Type</code>，就像 <code>1</code> 屬于 <code>Int</code>。<code>Type</code> 是最簡單的一種，<strong>atomic kind</strong>。在類型論符號中，<code>Type</code> 對應于 <code>*</code></p>
<p>在Kind的概念中，實際上重要的是一種或多種Kind(多項式Kind)。單項類型，例如<code>Option</code>，屬于它。一元Kind表示為 <code>Type -&gt; Type</code> <a href="type/advanced/kind.html#1"><sup id="f1">1</sup></a>。諸如 <code>Array</code> 或 <code>Option</code> 之類的 <strong>container</strong> 特別是一種以類型作為參數的多項式類型
正如符號 <code>Type -&gt; Type</code> 所表明的，<code>Option</code> 實際上是一個接收類型 <code>T</code> 并返回類型 <code>Option T</code> 的函數。但是，由于這個函數不是通常意義上的函數，所以通常稱為一元類</p>
<p>注意<code>-&gt;</code>本身，它是一個匿名函數操作符，當它接收一個類型并返回一個類型時，也可以看作是一Kind型</p>
<p>另請注意，不是原子Kind的Kind不是類型。正如 <code>-1</code> 是一個數字但 <code>-</code> 不是，<code>Option Int</code> 是一個類型但 <code>Option</code> 不是。<code>Option</code> 等有時被稱為類型構造函數</p>
<pre><code class="language-python">assert not Option in Type
assert Option in Type -&gt; Type
</code></pre>
<p>所以像下面這樣的代碼會報錯: 
在 Erg 中，方法只能在原子類型中定義，并且名稱 <code>self</code> 不能在方法的第一個參數以外的任何地方使用</p>
<pre><code class="language-python"># K 是一元類型
K: Type -&gt; Type
K T = Class...
K.
foo x = ... # OK，這就像是所謂的靜態方法
     bar self, x = ... # 類型錯誤: 無法為非類型對象定義方法
K(T).
    baz self, x = ... # OK
</code></pre>
<p>二進制或更高類型的示例是 <code>{T: U}</code>(: <code>(Type, Type) -&gt; Type</code>), <code>(T, U, V)</code>(: <code>(Type, Type, Type) - &gt; Type </code>), ... 等等</p>
<p>還有一個零項類型<code>() -&gt; Type</code>。這有時等同于類型論中的原子類型，但在 Erg 中有所區別。一個例子是<code>類</code></p>
<pre><code class="language-python">Nil = Class()
</code></pre>
<h2 id="收容類"><a class="header" href="#收容類">收容類</a></h2>
<p>多項類型之間也存在部分類型關系，或者更確切地說是部分類型關系</p>
<pre><code class="language-python">K T = ...
L = Inherit K
L&lt;: K
</code></pre>
<p>也就是說，對于任何 <code>T</code>，如果 <code>L T &lt;: K T</code>，則 <code>L &lt;: K</code>，反之亦然</p>
<pre><code class="language-python">?T. L T &lt;: K T &lt;=&gt; L &lt;: K
</code></pre>
<h2 id="高階kind"><a class="header" href="#高階kind">高階Kind</a></h2>
<p>還有一種高階Kind。這是一種與高階函數相同的概念，一種自身接收一種類型。<code>(Type -&gt; Type) -&gt; Type</code> 是一種更高的Kind。讓我們定義一個屬于更高Kind的對象</p>
<pre><code class="language-python">IntContainerOf K: Type -&gt; Type = K Int
assert IntContainerOf Option == Option Int
assert IntContainerOf Result == Result Int
assert IntContainerOf in (Type -&gt; Type) -&gt; Type
</code></pre>
<p>多項式類型的有界變量通常表示為 K, L, ...，其中 K 是 Kind 的 K</p>
<h2 id="設置kind"><a class="header" href="#設置kind">設置Kind</a></h2>
<p>在類型論中，有記錄的概念。這與 Erg 記錄 <a href="type/advanced/kind.html#2"><sup id="f2">2</sup></a> 幾乎相同</p>
<pre><code class="language-python"># 這是一條記錄，對應于類型論中所謂的記錄
{x = 1; y = 2}
</code></pre>
<p>當所有的記錄值都是類型時，它是一種類型，稱為記錄類型</p>
<pre><code class="language-python">assert {x = 1; y = 2} in {x = Int; y = Int}
</code></pre>
<p>記錄類型鍵入記錄。一個好的猜測者可能認為應該有一個&quot;記錄類型&quot;來鍵入記錄類型。實際上它是存在的</p>
<pre><code class="language-python">log Typeof {x = Int; y = Int} # {{x = Int; y = Int}}
</code></pre>
<p>像 <code>{{x = Int; 這樣的類型 y = Int}}</code> 是一種記錄類型。這不是一個特殊的符號。它只是一個枚舉類型，只有 <code>{x = Int; y = Int}</code> 作為一個元素</p>
<pre><code class="language-python">Point = {x = Int; y = Int}
Pointy = {Point}
</code></pre>
<p>記錄類型的一個重要屬性是，如果 <code>T: |T|</code> 和 <code>U &lt;: T</code> 則 <code>U: |T|</code>
從枚舉實際上是篩子類型的語法糖這一事實也可以看出這一點</p>
<pre><code class="language-python"># {c} == {X: T | X == c} 對于普通對象，但是不能為類型定義相等性，所以 |T| == {X | X &lt;: T}
{Point} == {P | P &lt;: Point}
</code></pre>
<p>類型約束中的 <code>U &lt;: T</code> 實際上是 <code>U: |T|</code> 的語法糖
作為此類類型的集合的種類通常稱為集合種類。Setkind 也出現在迭代器模式中</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<h2 id="多項式類型的類型推斷"><a class="header" href="#多項式類型的類型推斷">多項式類型的類型推斷</a></h2>
<pre><code class="language-python">Container K: Type -&gt; Type, T: Type = Patch K(T, T)
Container (K).
    f self = ...
Option T: Type = Patch T or NoneType
Option(T).
    f self = ...
Fn T: Type = Patch T -&gt; T
Fn(T).
    f self = ...
Fn2 T, U: Type = Patch T -&gt; U
Fn2(T, U).
    f self = ...

(Int -&gt; Int).f() # 選擇了哪一個?
</code></pre>
<p>在上面的示例中，方法 <code>f</code> 會選擇哪個補丁?
天真，似乎選擇了<code>Fn T</code>，但是<code>Fn2 T，U</code>也是可以的，<code>Option T</code>原樣包含<code>T</code>，所以任何類型都適用，<code>Container K，T</code>也匹配<code>-&gt;(Int, Int)</code>，即 <code>Container(</code>-&gt;<code>, Int)</code> 為 <code>Int -&gt; Int</code>。因此，上述所有四個修復程序都是可能的選擇</p>
<p>在這種情況下，根據以下優先標準選擇修復程序</p>
<ul>
<li>任何 <code>K(T)</code>(例如 <code>T or NoneType</code>)優先匹配 <code>Type -&gt; Type</code> 而不是 <code>Type</code></li>
<li>任何 <code>K(T, U)</code>(例如 <code>T -&gt; U</code>)優先匹配 <code>(Type, Type) -&gt; Type</code> 而不是 <code>Type</code></li>
<li>類似的標準適用于種類 3 或更多</li>
<li>選擇需要較少類型變量來替換的那個。例如，<code>Int -&gt; Int</code> 是 <code>T -&gt; T</code> 而不是 <code>K(T, T)</code>(替換類型變量: K, T)或 <code>T -&gt; U</code>(替換類型變量: T, U )。(替換類型變量: T)優先匹配</li>
<li>如果更換的次數也相同，則報錯為不可選擇</li>
</ul>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> 在類型理論符號中，<code>*=&gt;*</code> <a href="type/advanced/kind.html#f1">?</a></span></p>
<p><span id="2" style="font-size:x-small"><sup>2</sup> 可見性等細微差別。<a href="type/advanced/kind.html#f2">?</a></span></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="標記trait"><a class="header" href="#標記trait">標記Trait</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/marker_trait.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/marker_trait.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>標記Trait是沒有必需屬性的Trait。也就是說，您可以在不實現任何方法的情況下實現 Impl
沒有 required 屬性似乎沒有意義，但由于注冊了它屬于 trait 的信息，因此可以使用 patch 方法或由編譯器進行特殊處理</p>
<p>所有標記Trait都包含在&quot;標記&quot;Trait中
作為標準提供的&quot;光&quot;是一種標記Trait</p>
<pre><code class="language-python">Light = Subsume Marker
</code></pre>
<pre><code class="language-python">Person = Class {.name = Str; .age = Nat} and Light
</code></pre>
<pre><code class="language-python">M = Subsume Marker

MarkedInt = Inherit Int, Impl := M

i = MarkedInt.new(2)
assert i + 1 == 2
assert i in M
</code></pre>
<p>標記類也可以使用 <code>Excluding</code> 參數排除</p>
<pre><code class="language-python">NInt = Inherit MarkedInt, Impl := N, Excluding: M
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="可變結構類型"><a class="header" href="#可變結構類型">可變結構類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/mut_struct.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/mut_struct.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p><code>T!</code> 類型被描述為可以被任何 <code>T</code> 類型對象替換的盒子類型</p>
<pre><code class="language-python">Particle!State: {&quot;base&quot;, &quot;excited&quot;}! = Class(... Impl := Phantom State)
Particle!
    # 此方法將狀態從&quot;base&quot;移動到&quot;excited&quot;
    apply_electric_field!(ref! self(&quot;base&quot; ~&gt; &quot;excited&quot;), field: Vector) = ...
</code></pre>
<p><code>T!</code> 類型可以替換數據，但不能改變其結構
更像是一個真實程序的行為，它不能改變它的大小(在堆上)。這樣的類型稱為不可變結構(mutable)類型</p>
<p>事實上，有些數據結構不能用不變的結構類型來表示
例如，可變長度數組。<code>[T; N]!</code>類型可以包含任何<code>[T; N]</code>，但不能被<code>[T; N+1]</code> 等等</p>
<p>換句話說，長度不能改變。要改變長度，必須改變類型本身的結構</p>
<p>這是通過可變結構(可變)類型實現的</p>
<pre><code class="language-python">v = [Str; !0].new()
v.push! &quot;Hello&quot;
v: [Str; !1].
</code></pre>
<p>對于可變結構類型，可變類型參數用 <code>!</code> 標記。在上述情況下，類型 <code>[Str; !0]</code> 可以更改為 <code>[Str; !1]</code> 等等。即，可以改變長度
順便說一句，<code>[T; !N]</code> 類型是 <code>ArrayWithLength!(T, !N)</code> 類型的糖衣語法</p>
<p>可變結構類型當然可以是用戶定義的。但是請注意，在構造方法方面與不變結構類型存在一些差異</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, !0 = Inherit Nil T
List T, N: Nat! = Class {head = T; rest = List(T, !N-1)}
List(T, !N).
    push! ref! self(N ~&gt; N+1, ...), head: T =
        self.update! old -&gt; Self.new {head; old}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="幻影phantom類"><a class="header" href="#幻影phantom類">幻影(phantom)類</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/phantom.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/phantom.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>幻像類型是標記Trait，其存在僅用于向編譯器提供注釋
作為幻像類型的一種用法，讓我們看一下列表的結構</p>
<pre><code class="language-python">Nil = Class()
List T, 0 = Inherit Nil
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>此代碼導致錯誤</p>
<pre><code class="language-python">3 | List T, 0 = Inherit Nil
                        ^^^
類型構造錯誤: 由于Nil沒有參數T，所以無法用Nil構造List(T, 0)
提示: 使用 'Phantom' trait消耗 T
</code></pre>
<p>此錯誤是在使用 <code>List(_, 0).new Nil.new()</code> 時無法推斷 <code>T</code> 的抱怨
在這種情況下，無論 <code>T</code> 類型是什么，它都必須在右側使用。大小為零的類型(例如長度為零的元組)很方便，因為它沒有運行時開銷</p>
<pre><code class="language-python">Nil T = Class((T; 0))
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}
</code></pre>
<p>此代碼通過編譯。但是理解意圖有點棘手，除非類型參數是類型，否則不能使用它</p>
<p>在這種情況下，幻影類型正是您所需要的。幻像類型是大小為 0 的廣義類型</p>
<pre><code class="language-python">Nil T = Class(Impl := Phantom T)
List T, 0 = Inherit Nil T
List T, N: Nat = Class {head = T; rest = List(T, N-1)}

nil = Nil(Int).new()
assert nil.__size__ == 0
</code></pre>
<p><code>Phantom</code> 擁有<code>T</code> 類型。但實際上 <code>Phantom T</code> 類型的大小是 0 并且不包含 <code>T</code> 類型的對象</p>
<p>此外，<code>Phantom</code> 可以使用除其類型之外的任意類型參數。在下面的示例中，<code>Phantom</code> 包含一個名為 <code>State</code> 的類型參數，它是 <code>Str</code> 的子類型對象
同樣，<code>State</code> 是一個假的類型變量，不會出現在對象的實體中</p>
<pre><code class="language-python">VM! State: {&quot;stopped&quot;, &quot;running&quot;}! = Class(... State)
VM!(&quot;stopped&quot;).
    start ref! self(&quot;stopped&quot; ~&gt; &quot;running&quot;) =
        self.do_something!()
        self::set_phantom!(&quot;running&quot;))
</code></pre>
<p><code>state</code> 是通過 <code>update_phantom!</code> 或 <code>set_phantom!</code> 方法更新的
這是標準補丁為<code>Phantom!</code>(<code>Phantom</code>的變量版本)提供的方法，其用法與變量<code>update!</code>和<code>set!</code>相同。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="投影類型"><a class="header" href="#投影類型">投影類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/projection.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/projection.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>投影類型表示如下代碼中的&quot;Self.AddO&quot;等類型</p>
<pre><code class="language-python">Add R = Trait {
    . `_+_` = Self, R -&gt; Self.AddO
    .AddO = Type
}

AddForInt = Patch(Int, Impl := Add Int)
AddForInt.
    AddO = Int
</code></pre>
<p>類型&quot;Add(R)&quot;可以說是定義了與某個對象的加法的類型。由于方法應該是一個類型屬性，<code>+</code> 類型聲明應該寫在縮進下面
<code>Add</code> 類型的場景是聲明 <code>.AddO = Type</code>，而 <code>.AddO</code> 類型的實體是一個投影類型，由一個作為 <code> 子類型的類型持有 添加</code>。例如，<code>Int.AddO = Int</code>、<code>Odd.AddO = Even</code></p>
<pre><code class="language-python">assert Int &lt; Add
assert Int.AddO == Int
assert Odd &lt; Add
assert Odd.AddO == Even
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="量化依賴類型"><a class="header" href="#量化依賴類型">量化依賴類型</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/quantified_dependent.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/quantified_dependent.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg 有量化和依賴類型。那么很自然地，就可以創建一個將兩者結合起來的類型。那是量化的依賴類型</p>
<pre><code class="language-python">NonNullStr = |N: Nat| StrWithLen N | N ! = 0 # 同 {S | N: Nat; S: StrWithLen N; N ! = 0}
NonEmptyArray = |N: Nat| [_; N | N &gt; 0] # 同 {A | N: Nat; A: Array(_, N); N &gt; 0}
</code></pre>
<p>量化依賴類型的標準形式是&quot;K(A, ... | Pred)&quot;。<code>K</code> 是類型構造函數，<code>A, B</code> 是類型參數，<code>Pred</code> 是條件表達式</p>
<p>作為左值的量化依賴類型只能在與原始類型相同的模塊中定義方法</p>
<pre><code class="language-python">K A: Nat = Class ...
K(A).
    ...
K(A | A &gt;= 1).
    method ref! self(A ~&gt; A+1) = ...
</code></pre>
<p>作為右值的量化依賴類型需要在類型變量列表 (<code>||</code>) 中聲明要使用的類型變量</p>
<pre><code class="language-python"># T 是具體類型
a: |N: Nat| [T; N | N &gt; 1]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="共享參考"><a class="header" href="#共享參考">共享參考</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/type/advanced/shared.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/type/advanced/shared.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>共享引用是必須小心處理的語言特性之一
例如，在 TypeScript 中，以下代碼將通過類型檢查</p>
<pre><code class="language-typescript">class NormalMember {}
class VIPMember extends NormalMember {}

let vip_area: VIPMember[] = []
let normal_area: NormalMember[] = vip_area

normal_area.push(new NormalMember())
console.log(vip_area) # [NormalMember]
</code></pre>
<p>一個 NormalMember 已進入 vip_area。這是一個明顯的錯誤，但是出了什么問題?
原因是共享引用 <a href="type/advanced/./variance.html">denatured</a>。<code>normal_area</code> 是通過復制 <code>vip_area</code> 來創建的，但是這樣做的時候類型已經改變了
但是 <code>VIPMember</code> 繼承自 <code>NormalMember</code>，所以 <code>VIPMember[] &lt;: NormalMember[]</code>，這不是問題
關系 <code>VIPMember[] &lt;: NormalMember[]</code> 適用于不可變對象。但是，如果您執行上述破壞性操作，則會出現故障</p>
<p>在 Erg 中，由于所有權系統，此類代碼會被回放</p>
<pre><code class="language-python">NormalMember = Class()
VIPMember = Class()

vip_area = [].into [VIPMember; !_]
normal_area: [NormalMember; !_] = vip_area

normal_area.push!(NormalMember.new())
log vip_area # 所有權錯誤: `vip_room` 已移至 `normal_room`
</code></pre>
<p>然而，一個對象只屬于一個地方可能會很不方便
出于這個原因，Erg 有一個類型 <code>SharedCell!T!</code>，它代表一個共享狀態</p>
<pre><code class="language-python">$p1 = SharedCell!.new(!1)
$p2 = $p1.mirror!()
$p3 = SharedCell!.new(!1)
# 如果$p1 == $p2，比較內容類型Int！
assert $p1 == $p2
assert $p1 == $p3
# 檢查 $p1 和 $p2 是否用 `.addr!` 指向同一個東西
assert $p1.addr!() == $p2.addr!()
assert $p1.addr!() != $p3.addr!()
$p1.add! 1
assert $p1 == 2
assert $p2 == 2
assert $p3 == 1
</code></pre>
<p><code>SharedCell!</code> 類型的對象必須以<code>$</code> 為前綴。此外，就其性質而言，它們不可能是常數</p>
<p><code>SharedCell！ T!</code> 類型也是 <code>T!</code> 的子類型，可以調用 <code>T!</code> 類型的方法。<code>SharedCell!T!</code> 類型特有的唯一方法是 <code>.addr!</code>、<code>.mirror!</code> 和 <code>.try_take</code></p>
<p>一個重要的事實是<code>SharedCell! T!</code> 是非變體的，即沒有為不同類型的參數定義包含</p>
<pre><code class="language-python">$vip_area = SharedCell!.new([].into [VIPMember; !_])
$normal_area: SharedCell!([NormalMember; !_]) = $vip_area.mirror!() # 類型錯誤: 預期 SharedCell！([NormalMember；！_])，但得到 SharedCell！([VIPMember;!_])
# 提示: SharedCell!(T) 是非變體的，這意味著它不能有超類型或子類型
</code></pre>
<p>但是，下面的代碼沒有問題。在最后一行，它是 <code>VIPMember</code> 參數已被類型轉換</p>
<pre><code class="language-python">$normal_area = SharedCell!.new([].into [NormalMember; !_])
$normal_area.push!(NormalMember.new()) # OK
$normal_area.push!(VIPMember.new()) # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="迭代器"><a class="header" href="#迭代器">迭代器</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/16_iterator.md&amp;commit_hash=b07c17708b9141bbce788d2e5b3ad4f365d342fa"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/16_iterator.md%26commit_hash%3Db07c17708b9141bbce788d2e5b3ad4f365d342fa" alt="badge" /></a></p>
<p>迭代器是用于檢索容器元素的對象</p>
<pre><code class="language-python">for! 0..9, i =&gt;
    print! i
</code></pre>
<p>此代碼打印數字 0 到 9
每個數字(=Int 對象)都分配給<code>i</code>，并執行以下操作(=<code>print！i</code>)。這種重復執行稱為__iteration__</p>
<p>現在讓我們看看 <code>for!</code> 過程的類型簽名</p>
<pre><code class="language-python">for!: |T: Type, I &lt;: Iterable T| (I, T =&gt; None) =&gt; None
</code></pre>
<p>第一個參數似乎接受&quot;Iterable&quot;類型的對象</p>
<p><code>Iterable</code> 是一個具有<code>.Iterator</code> 屬性的類型，<code>.iter</code> 方法在request 方法中</p>
<pre><code class="language-python">Iterable T = Trait {
    .Iterator = {Iterator}
    .iter = (self: Self) -&gt; Self.Iterator T
}
</code></pre>
<p><code>.Iterator</code> 屬性的類型 <code>{Iterator}</code> 是所謂的 set-kind(kind 在 <a href="./type/advanced/kind.html">here</a> 中描述)</p>
<pre><code class="language-python">assert [1, 2, 3] in Iterable(Int)
assert 1..3 in Iterable(Int)
assert [1, 2, 3].Iterator == ArrayIterator
assert (1..3).Iterator == RangeIterator

log [1, 2, 3].iter() # &lt;數組迭代器對象&gt;
log (1..3).iter() # &lt;Range迭代器對象&gt;
</code></pre>
<p><code>ArrayIterator</code> 和 <code>RangeIterator</code> 都是實現 <code>Iterator</code> 的類，它們的存在只是為了提供 <code>Array</code> 和 <code>Range</code> 迭代函數
這種設計模式稱為伴生類 <a href="16_iterator.html#1"><sup id="f1">1</sup></a>
而&quot;IteratorImpl&quot;補丁是迭代功能的核心。<code>Iterator</code> 只需要一個<code>.next</code> 方法，<code>IteratorImpl</code> 確實提供了幾十種方法。<code>ArrayIterator</code>和<code>RangeIterator</code>只需實現<code>.next</code>方法就可以使用<code>IteratorImpl</code>的實現方法。為了方便起見，標準庫實現了許多迭代器</p>
<pre><code class="language-mermaid">classDiagram
    class Array~T~ {
        ...
        iter() ArrayIterator~T~
    }
    class Range~T~ {
        ...
        iter() RangeIterator~T~
    }
    class Iterable~T~ {
        &lt;&lt;trait&gt;&gt;
        iter() Iterator~T~
    }
    Iterable~T~ &lt;|.. Array~T~: Impl
    Iterable~T~ &lt;|.. Range~T~: Impl
    class ArrayIterator~T~ {
        array: Array~T~
        next() T
    }
    class RangeIterator~T~ {
        range: Range~T~
        next() T
    }
    class Iterator~T~ {
        &lt;&lt;trait&gt;&gt;
        next() T
    }
    Iterator~T~ &lt;|.. ArrayIterator~T~: Impl
    Iterator~T~ &lt;|.. RangeIterator~T~: Impl

    Array &lt;-- ArrayIterator
    Range &lt;-- RangeIterator
</code></pre>
<p>諸如 <code>Iterable</code> 之類的以靜態分派但統一的方式提供用于處理Trait(在本例中為 <code>Iterator</code>)的trait的類型稱為伴生類適配器</p>
<hr />
<p><span id="1" style="font-size:x-small"><sup>1</sup> 這個模式似乎沒有統一的名稱，但是在 Rust 中，有 [companion struct 模式]( https://gist.github.com/qnighy/be99c2ece6f3f4b1248608a04e104b38# :~:text=%E3%82%8F%E3%82%8C%E3%81%A6%E3%81%84%E3%82 %8B%E3%80%82-,companion%20struct,-%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89%E3%81%A8%E3%80% 81%E3 %81%9D%E3%81%AE)，并以此命名。<a href="16_iterator.html#f1">?</a> </span></p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可變性"><a class="header" href="#可變性">可變性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/17_mutability.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/17_mutability.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>正如我們已經看到的，所有 Erg 變量都是不可變的。但是，Erg 對象具有可變性的概念
以下面的代碼為例</p>
<pre><code class="language-python">a = [1, 2, 3]
a = a + [4, 5, 6]
print! a # [1, 2, 3, 4, 5, 6]
</code></pre>
<p>上面的代碼實際上不能被 Erg 執行。這是因為它不可重新分配</p>
<p>可以執行此代碼</p>
<pre><code class="language-python">b = ![1, 2, 3]
b.concat! [4, 5, 6]
print! b # [1, 2, 3, 4, 5, 6]
</code></pre>
<p><code>a, b</code> 的最終結果看起來一樣，但它們的含義卻大不相同
雖然 <code>a</code> 是表示 <code>Nat</code> 數組的變量，但第一行和第二行指向的對象是不同的。名稱<code>a</code>相同，但內容不同</p>
<pre><code class="language-python">a = [1, 2, 3]
print! id! a # 0x000002A798DFE940
_a = a + [4, 5, 6]
print! id! _a # 0x000002A798DFE980
</code></pre>
<p><code>id!</code> 過程返回對象駐留的內存地址</p>
<p><code>b</code> 是一個 <code>Nat</code> &quot;動態&quot; 數組。對象的內容發生了變化，但變量指向的是同一個東西</p>
<pre><code class="language-python">b = ![1, 2, 3]
print! id! b # 0x000002A798DFE220
b.concat! [4, 5, 6]
print! id! b # 0x000002A798DFE220
</code></pre>
<pre><code class="language-python">i = !0
if! True. do!
    do! i.inc!() # or i.add!(1)
    do pass
print! i # 1
</code></pre>
<p><code>!</code> 是一個特殊的運算符，稱為 <strong>mutation 運算符</strong>。它使不可變對象可變
標有&quot;！&quot;的對象的行為可以自定義</p>
<pre><code class="language-python">Point = Class {.x = Int; .y = Int}

# 在這種情況下 .x 是可變的，而 .y 保持不變
Point! = Class {.x = Int!; .y = Int}
Point!.
    inc_x! ref!(self) = self.x.update! x -&gt; x + 1

p = Point!.new {.x = !0; .y = 0}
p.inc_x!()
print! p.x # 1
</code></pre>
<h2 id="常量-1"><a class="header" href="#常量-1">常量</a></h2>
<p>與變量不同，常量在所有范圍內都指向同一事物
常量使用 <code>=</code> 運算符聲明</p>
<pre><code class="language-python">PI = 3.141592653589
match! x:
    PI =&gt; print! &quot;this is pi&quot;
</code></pre>
<p>常量在全局以下的所有范圍內都是相同的，并且不能被覆蓋。因此，它們不能被 <code>=</code> 重新定義。此限制允許它用于模式匹配
<code>True</code> 和 <code>False</code> 可以用于模式匹配的原因是因為它們是常量
此外，常量總是指向不可變對象。諸如 <code>Str!</code> 之類的類型不能是常量
所有內置類型都是常量，因為它們應該在編譯時確定。可以生成非常量的類型，但不能用于指定類型，只能像簡單記錄一樣使用。相反，類型是其內容在編譯時確定的記錄</p>
<h2 id="變量名稱標識符符號"><a class="header" href="#變量名稱標識符符號">變量、名稱、標識符、符號</a></h2>
<p>讓我們理清一些與 Erg 中的變量相關的術語</p>
<p>變量是一種為對象賦予名稱以便可以重用(或指向該名稱)的機制
標識符是指定變量的語法元素
符號是表示名稱的語法元素、記號</p>
<p>只有非符號字符是符號，符號不稱為符號，盡管它們可以作為運算符的標識符
例如，<code>x</code> 是一個標識符和一個符號。<code>x.y</code> 也是一個標識符，但它不是一個符號。<code>x</code> 和 <code>y</code> 是符號
即使 <code>x</code> 沒有綁定到任何對象，<code>x</code> 仍然是一個符號和一個標識符，但它不會被稱為變量
<code>x.y</code> 形式的標識符稱為字段訪問器
<code>x[y]</code> 形式的標識符稱為下標訪問器</p>
<p>變量和標識符之間的區別在于，如果我們在 Erg 的語法理論意義上談論變量，則兩者實際上是相同的
在 C 中，類型和函數不能分配給變量； int 和 main 是標識符，而不是變量(嚴格來說可以賦值，但有限制)
然而，在Erg語中，&quot;一切都是對象&quot;。不僅函數和類型，甚至運算符都可以分配給變量</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="所有權制度"><a class="header" href="#所有權制度">所有權制度</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/18_ownership.md&amp;commit_hash=00350f64a40b12f763a605bc16748d09379ab182"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/18_ownership.md%26commit_hash%3D00350f64a40b12f763a605bc16748d09379ab182" alt="badge" /></a></p>
<p>由于 Erg 是一種使用 Python 作為宿主語言的語言，因此內存管理的方法取決于 Python 的實現
但語義上 Erg 的內存管理與 Python 的不同。一個顯著的區別在于所有權制度和禁止循環引用</p>
<h2 id="所有權"><a class="header" href="#所有權">所有權</a></h2>
<p>Erg 有一個受 Rust 啟發的所有權系統
Rust 的所有權系統通常被認為是深奧的，但 Erg 的所有權系統被簡化為直觀
在 Erg 中，<strong>mutable objects</strong> 是擁有的，并且在所有權丟失后無法引用</p>
<pre><code class="language-python">v = [1, 2, 3].into [Int; !3]

push! vec, x =
    vec.push!(x)
    vec

# v ([1, 2, 3])的內容歸w所有
w = push! v, 4
print! v # 錯誤: v 被移動了
print!w # [1, 2, 3, 4]
</code></pre>
<p>例如，當一個對象被傳遞給一個子程序時，就會發生所有權轉移
如果您想在贈送后仍然擁有所有權，則需要克隆、凍結或借用
但是，如后所述，可以借用的情況有限</p>
<h2 id="復制"><a class="header" href="#復制">復制</a></h2>
<p>復制一個對象并轉移其所有權。它通過將 <code>.clone</code> 方法應用于實際參數來做到這一點
復制的對象與原始對象完全相同，但相互獨立，不受更改影響</p>
<p>復制相當于 Python 的深拷貝，由于它完全重新創建相同的對象，因此計算和內存成本通常高于凍結和借用
需要復制對象的子例程被稱為&quot;參數消耗&quot;子例程</p>
<pre><code class="language-python">capitalize s: Str!=
    s. capitalize!()
    s

s1 = !&quot;hello&quot;
s2 = capitalize s1.clone()
log s2, s1 # !&quot;HELLO hello&quot;
</code></pre>
<h2 id="凍結"><a class="header" href="#凍結">凍結</a></h2>
<p>我們利用了不可變對象可以從多個位置引用的事實，并將可變對象轉換為不可變對象
這稱為凍結。例如，在從可變數組創建迭代器時會使用凍結
由于您不能直接從可變數組創建迭代器，請將其轉換為不可變數組
如果您不想破壞數組，請使用 <a href="./type/18_mut.html"><code>.freeze_map</code> 方法</a></p>
<pre><code class="language-python"># 計算迭代器產生的值的總和
sum|T &lt;: Add + HasUnit| i: Iterator T = ...

x = [1, 2, 3].into [Int; !3]
x.push!(4)
i = x.iter() # 類型錯誤: [Int; !4] 沒有方法 `iter`
y = x.freeze()
i = y.iter()
assert sum(i) == 10
y # y 仍然可以被觸摸
</code></pre>
<h2 id="借"><a class="header" href="#借">借</a></h2>
<p>借用比復制或凍結便宜
可以在以下簡單情況下進行借款: </p>
<pre><code class="language-python">peek_str ref(s: Str!) =
    log s

s = !&quot;hello&quot;
peek_str s
</code></pre>
<p>借來的值稱為原始對象的 <strong>reference</strong>
您可以&quot;轉租&quot;對另一個子例程的引用，但您不能使用它，因為您只是借用它</p>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # 由于日志函數只借用參數，所以可以轉租
    log s
    # 錯誤，因為丟棄函數消耗了參數
    discard s # OwnershipError: 不能消費借來的值
    # 提示: 使用 `clone` 方法
</code></pre>
<pre><code class="language-python">steal_str ref(s: Str!) =
    # 這也不好(=消耗右邊)
     x = s # OwnershipError: 不能消費借來的值
    x
</code></pre>
<p>Erg 的引用比 Rust 的更嚴格。引用是語言中的一等對象，但不能顯式創建，它們只能指定為通過 <code>ref</code>/<code>ref!</code> 傳遞的參數
這意味著您不能將引用填充到數組中或創建將引用作為屬性的類</p>
<p>但是，這樣的限制是語言中的自然規范，一開始就沒有引用，而且它們并沒有那么不方便</p>
<h2 id="循環引用"><a class="header" href="#循環引用">循環引用</a></h2>
<p>Erg 旨在防止無意的內存泄漏，如果內存檢查器檢測到循環引用，則會發出錯誤。在大多數情況下，這個錯誤可以通過弱引用 <code>Weak</code> 來解決。但是，由于無法生成循環圖等具有循環結構的對象，因此我們計劃實現一個 API，可以將循環引用作為不安全操作生成</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="可見性"><a class="header" href="#可見性">可見性</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/19_visibility.md&amp;commit_hash=b07c17708b9141bbce788d2e5b3ad4f365d342fa"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/19_visibility.md%26commit_hash%3Db07c17708b9141bbce788d2e5b3ad4f365d342fa" alt="badge" /></a></p>
<p>Erg 變量具有 <strong>visibility</strong> 的概念
到目前為止，我們看到的所有變量都稱為 <strong>private variables</strong>。這是一個外部不可見的變量
例如，<code>foo</code> 模塊中定義的私有變量不能被另一個模塊引用</p>
<pre><code class="language-python"># foo.er
x = &quot;this is an invisible variable&quot;
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;
foo.x # AttributeError: 模塊 'foo' 沒有屬性 'x' ('x' 是私有的)
</code></pre>
<p>另一方面，也有__public variables__，可以從外部引用
公共變量用<code>.</code>定義</p>
<pre><code class="language-python"># foo.er
.x = &quot;this is a visible variable&quot;
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;
assert foo.x == &quot;this is a visible variable&quot;
</code></pre>
<p>您不需要向私有變量添加任何內容，但您也可以添加 <code>::</code> 或 <code>self::</code>(用于類型等的<code>Self::</code>)以表明它們是私有的。增加。如果它是一個模塊，它也可以是 <code>module::</code></p>
<pre><code class="language-python">::x = &quot;this is an invisible variable&quot;
assert ::x == x
assert self ::x == ::x
assert module::x == ::x
</code></pre>
<p>In the context of purely sequential execution, private variables are almost synonymous with local variables. It can be referenced from the inner scope.</p>
<pre><code class="language-python">::x = &quot;this is a private variable&quot;
y =
    x + 1 # 完全是 module::x
</code></pre>
<p>通過使用<code>::</code>，可以區分作用域內同名的變量
在左側指定要引用的變量的范圍。為頂層指定 <code>module</code>
如果未指定，則照常引用最里面的變量</p>
<pre><code class="language-python">::x = 0
assert x == 0
y =
    ::x = 1
    assert x == 1
    z =
        ::x = 2
        assert ::x == 2
        assert z::x == 2
        assert y::x == 1
        assert module::x == 0
</code></pre>
<p>在匿名子程序作用域中，<code>self</code> 指定了它自己的作用域</p>
<pre><code class="language-python">x = 0
f = x -&gt;
    log module::x, self::x
f1# 0 1
</code></pre>
<p><code>::</code> 還負責訪問私有實例屬性</p>
<pre><code class="language-python">x = 0
C = Class {x = Int}
C.
    # 頂級 x 被引用(警告使用 module::x)
    f1 self = x
    # 實例屬性 x 被引用
    f2 self = self::x
</code></pre>
<h2 id="外部模塊中的可見性"><a class="header" href="#外部模塊中的可見性">外部模塊中的可見性</a></h2>
<p>在一個模塊中定義的類實際上可以定義來自外部模塊的方法</p>
<pre><code class="language-python"># foo.er
.Foo = Class()
</code></pre>
<pre><code class="language-python"># bar.er
{Foo; ...} = import &quot;foo&quot;

Foo::
    private self = pass
Foo.
    public self = self::private()

.f() =
    foo = Foo.new()
    foo.public()
    foo::private() # 屬性錯誤
</code></pre>
<p>但是，這兩種方法都只在該模塊中可用
外部定義的私有方法對 Foo 類的方法僅在定義模塊內可見
公共方法暴露在類之外，但不在模塊之外</p>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;

foo = Foo.new()
foo.public() # 屬性錯誤: &quot;Foo&quot;沒有屬性&quot;public&quot;(&quot;public&quot;在模塊&quot;bar&quot;中定義)
</code></pre>
<p>此外，方法不能在要重新導出的類型中定義
這是為了避免混淆方法是否找到，具體取決于導入方法的模塊</p>
<pre><code class="language-python"># bar.er
{.Foo; ...} = import &quot;foo&quot;

.Foo::
    private self = pass # 錯誤
Foo.
    public self = self::private() # 錯誤
</code></pre>
<p>如果你想做這樣的事情，定義一個 <a href="./type/07_patch.html">patch</a></p>
<pre><code class="language-python"># bar.er
{Foo; ...} = import &quot;foo&quot;

FooImpl = Patch Foo
FooImpl :=:
    private self = pass
Foo Impl.
    public self = self::private()
</code></pre>
<pre><code class="language-python"># baz.er
{Foo; ...} = import &quot;foo&quot;
{FooImpl; ...} = import &quot;bar&quot;

foo = Foo.new()
foo.public()
</code></pre>
<h2 id="受限公共變量"><a class="header" href="#受限公共變量">受限公共變量</a></h2>
<p>可變可見性不限于完全公共/私有
您也可以有限制地發布</p>
<pre><code class="language-python"># foo.er
.record = {
    .a = {
        .(.record)x = 0
        .(module)y = 0
        .z = 0
    }
    _ = .a.x # OK
    _ = .a.y # OK
    _ = .a.z # OK
}

_ = .record.a.x # 可見性錯誤
_ = .record.a.y # OK
_ = .record.a.z # OK
</code></pre>
<pre><code class="language-python">foo = import &quot;foo&quot;
_ = foo.record.a.x # 可見性錯誤
_ = foo.record.a.y # 可見性錯誤
_ = foo.record.a.z # OK
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="命名約定"><a class="header" href="#命名約定">命名約定</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/20_naming_rule.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/20_naming_rule.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>如果要將變量用作常量表達式，請確保它以大寫字母開頭。兩個或多個字母可能是小寫的</p>
<pre><code class="language-python">i: Option Type = Int
match i:
    t: Type -&gt; log &quot;type&quot;
    None -&gt; log &quot;None&quot;
</code></pre>
<p>具有副作用的對象總是以 <code>!</code> 結尾。程序和程序方法，以及可變類型
然而，<code>Proc</code> 類型本身是不可變的</p>
<pre><code class="language-python"># Callable == Func or Proc
c: Callable = print!
match c:
    p! -&gt; log &quot;proc&quot; # `: Proc` 可以省略，因為它是不言自明的
    f -&gt; log &quot;func&quot;
</code></pre>
<p>如果您想向外界公開一個屬性，請在開頭使用 <code>.</code> 定義它。如果你不把<code>.</code>放在開頭，它將是私有的。為避免混淆，它們不能在同一范圍內共存</p>
<pre><code class="language-python">o = {x = 1; .x = 2} # 語法錯誤: 同名的私有變量和公共變量不能共存
</code></pre>
<h2 id="文字標識符"><a class="header" href="#文字標識符">文字標識符</a></h2>
<p>可以通過將字符串括在單引號 ('') 中來規避上述規則。也就是說，程序對象也可以在沒有 <code>!</code> 的情況下分配。但是，在這種情況下，即使該值是常量表達式，也不會被視為常量
像這樣用單引號括起來的字符串稱為文字標識符
這在調用Python等其他語言的API(FFI)時使用</p>
<pre><code class="language-python">bar! = pyimport(&quot;foo&quot;).'bar'
</code></pre>
<p>在 Erg 中也有效的標識符不需要用 '' 括起來</p>
<p>此外，文字標識符可以包含符號和空格，因此通常不能用作標識符的字符串可以用作標識符</p>
<pre><code class="language-python">'?/?t' y
'test 1: pass x to y'()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="匿名函數"><a class="header" href="#匿名函數">匿名函數</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/21_lambda.md&amp;commit_hash=304882f403ee8a6db8e19fae67b15ccf9747b6ff"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/21_lambda.md%26commit_hash%3D304882f403ee8a6db8e19fae67b15ccf9747b6ff" alt="badge" /></a></p>
<p>匿名函數是一種無需命名即可動態創建函數對象的語法</p>
<pre><code class="language-python"># `-&gt;` 是匿名函數操作符
# 同 `f x, y = x + y`
f = (x, y) -&gt; x + y
# same as `g(x, y: Int): Int = x + y`
g = (x, y: Int): Int -&gt; x + y
</code></pre>
<p>如果只有一個參數，您可以省略 <code>()</code></p>
<pre><code class="language-python">assert [1, 2, 3].map_collect(i -&gt; i + 1) == [2, 3, 4]
assert ((i, j) -&gt; [i, j])(1, 2) == [1, 2]
</code></pre>
<p>在下面的情況下，它是 <code>0..9, (i -&gt; ...)</code> 而不是 <code>(0..9, i) -&gt; ...</code>
<code>-&gt;</code> 在左側只接受一個參數。多個參數作為單個元組接收</p>
<pre><code class="language-python">for 0..9, i: Int -&gt;
    ...
</code></pre>
<p>在匿名函數中，由于空格，解析存在差異</p>
<pre><code class="language-python"># 在這種情況下，解釋為 `T(() -&gt; Int)`
i: T() -&gt; Int
# 在這種情況下，它被解釋為 (U()) -&gt; Int
k: U() -&gt; Int
</code></pre>
<p>匿名函數可以不帶參數使用</p>
<pre><code class="language-python"># `=&gt;` 是一個匿名過程操作符
p! = () =&gt; print! # `p!` 被調用
# `() -&gt;`, `() =&gt;` 有語法糖 `do`, `do!`
# p! = do! print! &quot;`p!` 被調用
p!() # `p!` 被調用
</code></pre>
<p>無參數函數可用于延遲初始化</p>
<pre><code class="language-python">time = import &quot;time&quot;
date = import &quot;datetime&quot;
now = if! True:
    do!:
        time. sleep! 1000
        date.now!()
    do date.new(&quot;1970&quot;, &quot;1&quot;, &quot;1&quot;, &quot;00&quot;, &quot;00&quot;)
</code></pre>
<p>您還可以鍵入和模式匹配。正因為如此，<code>match</code> 函數大多是借助匿名函數的力量來實現的
作為 <code>match</code> 函數的參數給出的匿名函數從頂部開始按順序嘗試。因此，您應該在頂部描述特殊情況，在底部描述更一般的情況。如果你弄錯了順序，編譯器會發出警告(如果可能的話)</p>
<pre><code class="language-python">n = (Complex or Ratio or Int).sample!()
i = matchn:
    PI -&gt; PI # 如果等于常數 PI
    For (i: 1..10) -&gt; i # 整數從 1 到 10
    (i: Int) -&gt; i # Int
    (c: Complex) -&gt; c.real() # 對于復雜。Int &lt; Complex，但可以回退
    _ -&gt; panic &quot;cannot convert to Int&quot; # 如果以上都不適用。match 必須涵蓋所有模式
</code></pre>
<p>錯誤處理通常也使用 <code>?</code> 或 <code>match</code> 完成</p>
<pre><code class="language-python">res: ParseResult Int
matchres:
    i: Int -&gt; i
    err: Error -&gt; panic err.msg

res2: Result Int, Error
match res2:
    ok: Not Error -&gt; log Type of ok
    err: Error -&gt; panic err.msg
</code></pre>
<h2 id="匿名多相關系數"><a class="header" href="#匿名多相關系數">匿名多相關系數</a></h2>
<pre><code class="language-python"># 與此相同 id|T|x: T = x
id = |T| x: T -&gt; x
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="子程序簽名"><a class="header" href="#子程序簽名">子程序簽名</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/22_subroutine.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/22_subroutine.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="函數"><a class="header" href="#函數">函數</a></h2>
<pre><code class="language-python">some_func(x: T, y: U) -&gt; V
some_func: (T, U) -&gt; V
</code></pre>
<h2 id="過程"><a class="header" href="#過程">過程</a></h2>
<pre><code class="language-python">some_proc!(x: T, y: U) =&gt; V
some_proc!: (T, U) =&gt; V
</code></pre>
<h2 id="函數方法"><a class="header" href="#函數方法">函數方法</a></h2>
<p>方法類型不能用<code>Self</code>在外部指定</p>
<pre><code class="language-python">.some_method(self, x: T, y: U) =&gt; ()
# (Self, T, U) =&gt; () 擁有 self 的所有權
.some_method: (Ref(Self), T, U) =&gt; ()
</code></pre>
<h2 id="過程方法依賴"><a class="header" href="#過程方法依賴">過程方法(依賴)</a></h2>
<p>在下文中，假設類型 <code>T!</code> 采用類型參數 <code>N: Nat</code>。要在外部指定它，請使用類型變量</p>
<pre><code class="language-python">T!: Nat -&gt; Type
# ~&gt; 表示應用前后類型參數的狀態(此時self必須是變量引用)
T!(N).some_method!: (Ref!(T! N ~&gt; N+X), X: Nat) =&gt; ()
</code></pre>
<p>注意，<code>.some_method</code> 的類型是 <code>| N，X: Nat| (Ref!(T! N ~&gt; N+X), {X}) =&gt; ()</code>
對于沒有 <code>ref!</code> 的方法，即在應用后被剝奪所有權，不能使用類型參數轉換(<code>~&gt;</code>)</p>
<p>如果取得所有權，則如下所示</p>
<pre><code class="language-python"># 如果不使用N，可以用_省略
# .some_method!: |N, X: Nat| (T!(N), {X}) =&gt; T!(N+X)
.some_method!|N, X: Nat| (self: T!(N), X: Nat) =&gt; T!(N+X)
</code></pre>
<h2 id="運算符-1"><a class="header" href="#運算符-1">運算符</a></h2>
<p>可以通過用 ` 括起來將其定義為普通函數</p>
<p>中性字母運算符，例如 <code>and</code> 和 <code>or</code> 可以通過用 ` 括起來定義為中性運算符</p>
<pre><code class="language-python">and(x, y, z) = x and y and z
`_+_`(x: Foo, y: Foo) = x.a + y.a
`-_`(x: Foo) = Foo.new(-x.a)
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="閉包"><a class="header" href="#閉包">閉包</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/23_closure.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/23_closure.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Erg 子例程有一個稱為&quot;閉包&quot;的功能，可以捕獲外部變量</p>
<pre><code class="language-python">outer = 1
f x = outer + x
assert f(1) == 2
</code></pre>
<p>與不可變對象一樣，可變對象也可以被捕獲</p>
<pre><code class="language-python">sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45

p!x=
    sum.add!x
p!(1)
assert sum == 46
</code></pre>
<p>但是請注意，函數不能捕獲可變對象
如果可以在函數中引用可變對象，則可以編寫如下代碼</p>
<pre><code class="language-python"># !!! 這段代碼實際上給出了一個錯誤！！！
i = !0
f x = i + x
assert f 1 == 1
i.add! 1
assert f 1 == 2
</code></pre>
<p>該函數應該為相同的參數返回相同的值，但假設被打破了
請注意，<code>i</code> 僅在調用時進行評估</p>
<p>如果您想在定義函數時獲取可變對象的內容，請調用<code>.clone</code></p>
<pre><code class="language-python">i = !0
immut_i = i.clone().freeze()
fx = immut_i + x
assert f 1 == 1
i.add! 1
assert f 1 == 1
</code></pre>
<h2 id="avoid-mutable-state-functional-programming"><a class="header" href="#avoid-mutable-state-functional-programming">avoid mutable state, functional programming</a></h2>
<pre><code class="language-python"># Erg
sum = !0
for! 1..10, i =&gt;
    sum.add!i
assert sum == 45
</code></pre>
<p>上面的等效程序可以用 Python 編寫如下: </p>
<pre><code class="language-python"># Python
sum = 0
for i in range(1, 10):
    sum += i
assert sum == 45
</code></pre>
<p>但是，Erg 建議使用更簡單的表示法
與其使用子例程和可變對象來傳遞狀態，不如使用一種使用函數來定位狀態的風格。這稱為函數式編程</p>
<pre><code class="language-python"># 功能風格
sum = (1..10).sum()
assert sum == 45
</code></pre>
<p>上面的代碼給出了與之前完全相同的結果，但是您可以看到這個代碼要簡單得多</p>
<p><code>fold</code> 函數可以用來做比 sum 更多的事情
<code>fold</code> 是一個迭代器方法，它為每次迭代執行參數 <code>f</code>
累加結果的計數器的初始值在 <code>init</code> 中指定，并在 <code>acc</code> 中累加</p>
<pre><code class="language-python"># 從0開始，結果會
sum = (1..10).fold(init: 0, f: (acc, i) -&gt; acc + i)
assert sum == 45
</code></pre>
<p>Erg 被設計為對使用不可變對象進行編程的自然簡潔描述</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模塊"><a class="header" href="#模塊">模塊</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/24_module.md&amp;commit_hash=48107a2d1719892be50588de764991cba6db39b4"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/24_module.md%26commit_hash%3D48107a2d1719892be50588de764991cba6db39b4" alt="badge" /></a></p>
<p>Erg允許您將文件本身視為單個記錄(Record)。這稱為模塊</p>
<pre><code class="language-python:foo.er"># foo.er
.i = 1
</code></pre>
<pre><code class="language-python"># 定義 foo 模塊與定義這條記錄幾乎相同
foo = {.i = 1}
</code></pre>
<pre><code class="language-python:bar.er"># bar.er
foo = import &quot;foo&quot;
print! foo # &lt;module 'foo'&gt;
assert foo.i == 1
</code></pre>
<p>由于模塊類型也是記錄類型，因此可以進行解構賦值</p>
<pre><code class="language-python">{sin; cos; ...} = import &quot;math&quot;
</code></pre>
<h2 id="模塊可見性"><a class="header" href="#模塊可見性">模塊可見性</a></h2>
<p>目錄和文件都可以是模塊
但是，在默認情況下，Erg不將目錄識別為Erg模塊。要讓它被識別，創建一個名為<code>__init__.er</code>的文件
<code>__init__.er</code>類似于Python中的<code>__init__.py</code></p>
<pre><code class="language-console">└─┬ bar
  └─ __init__.er
</code></pre>
<p>現在 <code>bar</code> 目錄被識別為一個模塊。如果 <code>bar</code> 中的唯一文件是 <code>__init__.er</code>，則目錄結構沒有多大意義，但如果您想將多個模塊捆綁到一個模塊中，它會很有用。例如: </p>
<pre><code class="language-console">└─┬ bar
  ├─ __init__.er
  ├─ baz.er
  └─ qux.er
</code></pre>
<p>在 <code>bar</code> 目錄之外，您可以像下面這樣使用</p>
<pre><code class="language-erg">bar = import &quot;bar&quot;
bar.baz.p!()
bar.qux.p!()
</code></pre>
<p><code>__init__.er</code> 不僅僅是一個將目錄作為模塊的標記，它還控制模塊的可見性</p>
<pre><code class="language-erg"># __init__.er
# `. /` 指向當前目錄。可以省略
.baz = import &quot;. /baz&quot;
qux = import &quot;. /qux&quot;
.f x =
    .baz.f ...
.g x =
    qux.f ...
</code></pre>
<p>當你從外部導入 <code>bar</code> 模塊時，<code>baz</code> 模塊可以訪問，但 <code>qux</code> 模塊不能。</p>
<h2 id="循環依賴"><a class="header" href="#循環依賴">循環依賴</a></h2>
<p>Erg 允許您定義模塊之間的循環依賴關系。</p>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;
print! bar.g 1
.f x = x
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;
print! foo.f 1
.g x = x
</code></pre>
<p>但是，由過程調用創建的變量不能在循環引用模塊中定義
這是因為 Erg 根據依賴關系重新排列定義的順序</p>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;
print! bar.x
.x = g!(1) # 模塊錯誤：由過程調用創建的變量不能在循環引用模塊中定義
</code></pre>
<pre><code class="language-python"># bar.er
foo = import &quot;foo&quot;
print! foo.x
.x = 0
</code></pre>
<p>此外，作為入口點的 Erg 模塊（即 <code>__name__ == &quot;__main__&quot;</code> 的模塊）不能成為循環引用的主題</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="對象系統"><a class="header" href="#對象系統">對象系統</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/25_object_system.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/25_object_system.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>可以分配給變量的所有數據。<code>Object</code> 類的屬性如下</p>
<ul>
<li><code>.__repr__</code>: 返回對象的(非豐富)字符串表示</li>
<li><code>.__sizeof__</code>: 返回對象的大小(包括堆分配)</li>
<li><code>.__dir__</code>: 返回對象屬性列表</li>
<li><code>.__hash__</code>: 返回對象的哈希值</li>
<li><code>.__getattribute__</code>: 獲取并返回對象的屬性</li>
<li><code>.clone</code>: 創建并返回一個對象的克隆(在內存中有一個獨立的實體)</li>
<li><code>.copy</code>: 返回對象的副本(指向內存中的同一事物)</li>
</ul>
<h2 id="記錄"><a class="header" href="#記錄">記錄</a></h2>
<p>由記錄文字(<code>{attr = value; ...}</code>)生成的對象
這個對象有基本的方法，比如<code>.clone</code>和<code>.__sizeof__</code></p>
<pre><code class="language-python">obj = {.x = 1}
assert obj.x == 1

obj2 = {...x; .y = 2}
assert obj2.x == 1 and obj2.y == 2
</code></pre>
<h2 id="屬性"><a class="header" href="#屬性">屬性</a></h2>
<p>與對象關聯的對象。特別是，將 self (<code>self</code>) 作為其隱式第一個參數的子例程屬性稱為方法</p>
<pre><code class="language-python"># 請注意，private_attr 中沒有`.`
record = {.public_attr = j; private_attr = 2; .method = self -&gt; self.i + 1}
record. public_attr == 2
record.private_attr # AttributeError: private_attr 是私有的
assert record.method() == 3
</code></pre>
<h2 id="元素"><a class="header" href="#元素">元素</a></h2>
<p>屬于特定類型的對象(例如，&quot;1&quot;是&quot;Int&quot;類型的元素)。所有對象至少是<code>{=}</code>類型的元素
類的元素有時稱為實例</p>
<h2 id="子程序"><a class="header" href="#子程序">子程序</a></h2>
<p>表示作為函數或過程(包括方法)實例的對象。代表子程序的類是&quot;子程序&quot;
實現 <code>.__call__</code> 的對象通常稱為 <code>Callable</code></p>
<h2 id="可調用"><a class="header" href="#可調用">可調用</a></h2>
<p>一個實現<code>.__call__</code>的對象。它也是 <code>Subroutine</code> 的超類</p>
<h2 id="類型-2"><a class="header" href="#類型-2">類型</a></h2>
<p>定義需求屬性并使對象通用化的對象
主要有兩種類型: 多態類型和單態類型。典型的單態類型有<code>Int</code>、<code>Str</code>等，多態類型有<code>Option Int</code>、<code>[Int; 3]</code>等
此外，定義改變對象狀態的方法的類型稱為 Mutable 類型，需要在變量屬性中添加 <code>!</code>(例如動態數組: <code>[T; !_]</code>)</p>
<h2 id="班級"><a class="header" href="#班級">班級</a></h2>
<p>具有 <code>.__new__</code>、<code>.__init__</code> 方法等的類型。實現基于類的面向對象</p>
<h2 id="功能-1"><a class="header" href="#功能-1">功能</a></h2>
<p>對外部變量(不包括靜態變量)有讀權限但對外部變量沒有讀/寫權限的子程序。換句話說，它沒有外部副作用
Erg 函數的定義與 Python 的不同，因為它們不允許副作用</p>
<h2 id="程序-1"><a class="header" href="#程序-1">程序</a></h2>
<p>它對外部變量具有讀取和&quot;自我&quot;權限，對靜態變量具有讀/寫權限，并允許使用所有子例程。它可能有外部副作用</p>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>隱式將&quot;self&quot;作為第一個參數的子例程。它與簡單的函數/過程是不同的類型</p>
<h2 id="實體"><a class="header" href="#實體">實體</a></h2>
<p>不是子例程和類型的對象
單態實體(<code>1</code>、<code>&quot;a&quot;</code> 等)也稱為值對象，多態實體(<code>[1, 2, 3], {&quot;a&quot;: 1}</code>)也稱為容器對象</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模式匹配"><a class="header" href="#模式匹配">模式匹配</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/26_pattern_matching.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/26_pattern_matching.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<h2 id="erg-中可用的模式"><a class="header" href="#erg-中可用的模式">Erg 中可用的模式</a></h2>
<h3 id="變量模式"><a class="header" href="#變量模式">變量模式</a></h3>
<pre><code class="language-python"># 基本任務
i = 1
# 有類型
i: Int = 1
# 匿名類型
i: {1, 2, 3} = 2

# 功能
fn x = x + 1
# 等于
fn x: Add(Int) = x + 1
# (匿名)函數
fn = x -&gt; x + 1
fn: Int -&gt; Int = x -&gt; x + 1

# 高階類型
a: [Int; 4] = [0, 1, 2, 3]
# or
a: Array Int, 4 = [0, 1, 2, 3]
</code></pre>
<h3 id="文字字面量"><a class="header" href="#文字字面量">文字字面量</a></h3>
<pre><code class="language-python"># 如果在編譯時無法確定 `i` 為 1，則引發 TypeError
# 省略 `_: {1} = i`
1 = i

# 簡單的模式匹配
match x:
    1 -&gt; &quot;1&quot;
    2 -&gt; &quot;2&quot;
    _ -&gt; &quot;other&quot;

# 斐波那契函數
fib0 = 0
fib1 = 1
fibn: Nat = fibn-1 + fibn-2
</code></pre>
<h3 id="常量模式"><a class="header" href="#常量模式">常量模式</a></h3>
<pre><code class="language-python">cond=False
match! cond:
    True =&gt; print! &quot;cond is True&quot;
    _ =&gt; print! &quot;cond is False&quot;

PI = 3.141592653589793
E = 2.718281828459045
num = PI
name = match num:
    PI -&gt; &quot;pi&quot;
    E -&gt; &quot;e&quot;
    _ -&gt; &quot;unnamed&quot;
</code></pre>
<h3 id="篩子圖案"><a class="header" href="#篩子圖案">篩子圖案</a></h3>
<pre><code class="language-python"># 這兩個是一樣的
Array(T, N: {N | N &gt;= 3})
Array(T, N | N &gt;= 3)

f M, N | M &gt;= 0, N &gt;= 1 = ...
f(1, 0) # 類型錯誤: N(第二個參數)必須為 1 或更多
</code></pre>
<h3 id="丟棄通配符模式"><a class="header" href="#丟棄通配符模式">丟棄(通配符)模式</a></h3>
<pre><code class="language-python">_ = 1
_: Int = 1
zero_ = 0
right(_, r) = r
</code></pre>
<h3 id="可變長度模式"><a class="header" href="#可變長度模式">可變長度模式</a></h3>
<p>它與稍后描述的元組/數組/記錄模式結合使用</p>
<pre><code class="language-python">[i,...j] = [1, 2, 3, 4]
assert j == [2, 3, 4]
first|T|(fst: T, ...rest: T) = fst
assert first(1, 2, 3) == 1
</code></pre>
<h3 id="元組模式"><a class="header" href="#元組模式">元組模式</a></h3>
<pre><code class="language-python">(i, j) = (1, 2)
((k, l), _) = ((1, 2), (3, 4))
# 如果不嵌套，() 可以省略(1, 2 被視為(1, 2))
m, n = 1, 2

f(x, y) = ...
</code></pre>
<h3 id="數組模式"><a class="header" href="#數組模式">數組模式</a></h3>
<pre><code class="language-python">[i, j] = [1, 2]
[[k, l], _] = [[1, 2], [3, 4]]

length[] = 0
length[_, ...rest] = 1 + lengthrest
</code></pre>
<h4 id="record-模式"><a class="header" href="#record-模式">record 模式</a></h4>
<pre><code class="language-python">record = {i = 1; j = 2; k = 3}
{j; ...} = record # i, k 將被釋放

{sin; cos; tan; ...} = import &quot;math&quot;
{*} = import &quot;math&quot; # import all

person = {name = &quot;John Smith&quot;; age = 20}
age = match person:
    {name = &quot;Alice&quot;; _} -&gt; 7
    {_; age} -&gt; age

f {x: Int; y: Int} = ...
</code></pre>
<h3 id="數據類模式"><a class="header" href="#數據類模式">數據類模式</a></h3>
<pre><code class="language-python">Point = Inherit {x = Int; y = Int}
p = Point::{x = 1; y = 2}
Point::{x; y} = p

Nil T = Class Impl := Phantom T
Cons T = Inherit {head = T; rest = List T}
List T = Enum Nil(T), Cons(T)
List T.
    first self =
        match self:
            Cons::{head; ...} -&gt; x
            _ -&gt; ...
    second self =
        match self:
            Cons::{rest=Cons::{head; ...}; ...} -&gt; head
            _ -&gt; ...
</code></pre>
<h3 id="枚舉模式"><a class="header" href="#枚舉模式">枚舉模式</a></h3>
<ul>
<li>其實只是枚舉類型</li>
</ul>
<pre><code class="language-python">match x:
    i: {1, 2} -&gt; &quot;one or two: {i}&quot;
    _ -&gt; &quot;other&quot;
</code></pre>
<h3 id="range-模式"><a class="header" href="#range-模式">Range 模式</a></h3>
<ul>
<li>實際上，它只是一個區間類型</li>
</ul>
<pre><code class="language-python"># 0 &lt; i &lt; 1
i: 0&lt;..&lt;1 = 0.5
# 1 &lt; j &lt;= 2
_: {[I, J] | I, J: 1&lt;..2} = [1, 2]
# 1 &lt;= i &lt;= 5
match i
    i: 1..5 -&gt; ...
</code></pre>
<h3 id="不是模式的東西不能被模式化的東西"><a class="header" href="#不是模式的東西不能被模式化的東西">不是模式的東西，不能被模式化的東西</a></h3>
<p>模式是可以唯一指定的東西。在這方面，模式匹配不同于普通的條件分支</p>
<p>條件規格不是唯一的。例如，要檢查數字 <code>n</code> 是否為偶數，正統是 <code>n % 2 == 0</code>，但也可以寫成 <code>(n / 2).round() == n / 2</code>
非唯一形式無論是正常工作還是等效于另一個條件都不是微不足道的</p>
<h4 id="set-1"><a class="header" href="#set-1">Set</a></h4>
<p>沒有固定的模式。因為集合沒有辦法唯一地檢索元素
您可以通過迭代器檢索它們，但不能保證順序</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="推導式"><a class="header" href="#推導式">推導式</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/27_comprehension.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/27_comprehension.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>Array 和 <code>[expr | (name &lt;- iterable)+ (predicate)*]</code>,
set 和 <code>{expr | (name &lt;- iterable)+ (predicate)*}</code>,
你可以創建一個字典 <code>{key: value | (name &lt;- iterable)+ (predicate)*}</code>.</p>
<p>由<code>|</code>分隔的子句的第一部分稱為布局子句(位置子句)，第二部分稱為綁定子句(綁定子句)，第三部分稱為保護子句(條件子句)
保護子句可以省略，但綁定子句不能省略，保護子句不能在綁定子句之前</p>
<p>理解示例</p>
<pre><code class="language-python"># 布局子句是 i
# 綁定子句是 i &lt;- [0, 1, 2]
assert [i | i &lt;- [0, 1, 2]] == [0, 1, 2]

# 布局子句是 i / 2
# 綁定子句是 i &lt;- 0..2
assert [i/2 | i &lt;- 0..2] == [0.0, 0.5, 1.0]

# 布局子句是 (i, j)
# 綁定子句 i &lt;- 0..2, j &lt;- 0..2
# 保護子句是 (i + j) % 2 == 0
assert [(i, j) | i &lt;- 0..2; j &lt;- 0..2; (i + j) % 2 == 0] == [(0, 0), (0, 2), (1, 1), (2, 0), (2, 2)]

assert {i % 2 | i &lt;- 0..9} == {0, 1}
assert {k: v | k &lt;- [&quot;a&quot;, &quot;b&quot;]; v &lt;- [1, 2]} == {&quot;a&quot;: 1, &quot;b&quot;: 2}
</code></pre>
<p>Erg推導式受到 Haskell 的啟發，但有一些不同
對于 Haskell 列表推導，變量的順序會對結果產生影響，但在 Erg 中這并不重要</p>
<pre><code class="language-haskell">-- Haskell
[(i, j) | i &lt;- [1..3], j &lt;- [3..5]] == [(1,3),(1,4),(1,5),(2 ,3),(2,4),(2,5),(3,3),(3,4),(3,5)]
[(i, j) | j &lt;- [3..5], i &lt;- [1..3]] == [(1,3),(2,3),(3,3),(1 ,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>
<pre><code class="language-python"># Erg
assert [(i, j) | i &lt;- 1..&lt;3; j &lt;- 3..&lt;5] == [(i, j) | j &lt;- 3..&lt;5; i &lt;- 1.. &lt;3]
</code></pre>
<p>該規范與 Python 的規范相同</p>
<pre><code class="language-python"># Python
assert [(i, j) for i in range(1, 3) for j in range(3, 5)] == [(i, j) for j in range(3, 5) for i in range(1, 3)]
</code></pre>
<h2 id="篩子類型"><a class="header" href="#篩子類型">篩子類型</a></h2>
<p>與推導類似的是篩類型。篩子類型是以<code>{Name: Type | Predicate}</code>創建的(枚舉類型)
sieve類型的情況下，只能指定一個Name，不能指定布局(但是如果是tuple類型可以處理多個值)，Predicate可以在編譯時計算，即 ，只能指定一個常量表達式</p>
<pre><code class="language-python">Nat = {I: Int | I &gt;= 0}
# 如果謂詞表達式只有and，可以替換為:
# Nat2D = {(I, J): (Int, Int) | I &gt;= 0; J &gt;= 0}
Nat2D = {(I, J): (Int, Int) | I &gt;= 0 and J &gt;= 0}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="擴展語法"><a class="header" href="#擴展語法">擴展語法</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/28_spread_syntax.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/28_spread_syntax.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>在分解賦值中，將 <code>...</code> 放在變量前面會將所有剩余元素展開到該變量中。這稱為展開賦值</p>
<pre><code class="language-python">[x,...y] = [1, 2, 3]
assert x == 1
assert y == [2, 3]
x, ...y = (1, 2, 3)
assert x == 1
assert y == (2, 3)
</code></pre>
<h2 id="提取賦值"><a class="header" href="#提取賦值">提取賦值</a></h2>
<p>如果在 <code>...</code> 之后沒有寫入任何內容，則忽略并分配剩余的元素。這種類型的賦值具體稱為提取賦值
提取分配是一種方便的語法，用于本地化模塊或記錄中的特定屬性</p>
<pre><code class="language-python">{sin; cos; tan; ..} = import &quot;math&quot;
</code></pre>
<p>之后，您可以在本地使用<code>sin，cos，tan</code></p>
<p>您可以對記錄執行相同的操作。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{x; y; ...} = record
</code></pre>
<p>如果要全部展開，請使用<code>{*}=record</code>。它在OCaml中是<code>open</code>。</p>
<pre><code class="language-python">record = {x = 1; y = 2}
{*} = records
assert x == 1 and y == 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="裝飾器修飾符"><a class="header" href="#裝飾器修飾符">裝飾器(修飾符)</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/29_decorator.md&amp;commit_hash=b07c17708b9141bbce788d2e5b3ad4f365d342fa"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/29_decorator.md%26commit_hash%3Db07c17708b9141bbce788d2e5b3ad4f365d342fa" alt="badge" /></a></p>
<p>裝飾器用于向類型或函數添加或演示特定狀態或行為
裝飾器的語法如下</p>
<pre><code class="language-python">@deco
X=...
</code></pre>
<p>你可以有多個裝飾器，只要它們不沖突</p>
<p>裝飾器不是一個特殊的對象，它只是一個單參數函數。裝飾器等價于下面的偽代碼</p>
<pre><code class="language-python">X=...
X = deco(X)
</code></pre>
<p>Erg 不允許重新分配變量，因此上面的代碼不起作用
對于簡單的變量，它與<code>X = deco(...)</code> 相同，但對于即時塊和子例程，你不能這樣做，所以你需要一個裝飾器</p>
<pre><code class="language-python">@deco
f x =
    y = ...
    x + y

# 還可以防止代碼變成水平的
@LongNameDeco1
@LongNameDeco2
C = Class...
</code></pre>
<p>下面是一些常用的內置裝飾器</p>
<h2 id="可繼承"><a class="header" href="#可繼承">可繼承</a></h2>
<p>指示定義類型是可繼承的類。如果為參數 <code>scope</code> 指定 <code>&quot;public&quot;</code>，甚至可以繼承外部模塊的類。默認情況下它是<code>&quot;private&quot;</code>，不能被外部繼承</p>
<h2 id="最后"><a class="header" href="#最后">最后</a></h2>
<p>使該方法不可覆蓋。將它添加到類中使其成為不可繼承的類，但由于它是默認值，因此沒有意義</p>
<h2 id="覆蓋-1"><a class="header" href="#覆蓋-1">覆蓋</a></h2>
<p>覆蓋屬性時使用。默認情況下，如果您嘗試定義與基類相同的屬性，Erg 將拋出錯誤</p>
<h2 id="實現"><a class="header" href="#實現">實現</a></h2>
<p>表示參數 trait 已實現</p>
<pre><code class="language-python">Add = Trait {
    .`_+_` = Self.(Self) -&gt; Self
}
Sub = Trait {
    .`_-_` = Self.(Self) -&gt; Self
}

C = Class({i = Int}, Impl := Add and Sub)
C.
    @Impl Add
    `_+_` self, other = C.new {i = self::i + other::i}
    @Impl Sub
    `_-_` self, other = C.new {i = self::i - other::}
</code></pre>
<h2 id="附"><a class="header" href="#附">附</a></h2>
<p>指定默認情況下隨 trait 附帶的附件補丁
這允許您重現與 Rust Trait相同的行為</p>
<pre><code class="language-python"># foo.er
Add R = Trait {
    .AddO = Type
    .`_+_` = Self.(R) -&gt; Self.AddO
}
@Attach AddForInt, AddForOdd
ClosedAdd = Subsume Add(Self)

AddForInt = Patch(Int, Impl := ClosedAdd)
AddForInt.AddO = Int
AddForOdd = Patch(Odd, Impl := ClosedAdd)
AddForOdd.AddO = Even
</code></pre>
<p>當從其他模塊導入Trait時，這將自動應用附件補丁</p>
<pre><code class="language-Python"># 本來應該同時導入IntIsBinAdd和OddIsBinAdd，但是如果是附件補丁可以省略
{BinAdd; ...} = import &quot;foo&quot;

assert Int. AddO == Int
assert Odd.AddO == Even
</code></pre>
<p>在內部，它只是使用 trait 的 .attach 方法附加的。可以使用 trait 的 <code>.detach</code> 方法消除沖突</p>
<pre><code class="language-python">@Attach X
T = Trait...
assert X in T. attaches
U = T.detach(X).attach(Y)
assert X not in U. attaches
assert Y in U. attaches
</code></pre>
<h2 id="已棄用"><a class="header" href="#已棄用">已棄用</a></h2>
<p>指示變量規范已過時且不推薦使用</p>
<h2 id="測試"><a class="header" href="#測試">測試</a></h2>
<p>表示這是一個測試子例程。測試子程序使用 <code>erg test</code> 命令運行</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="錯誤處理系統"><a class="header" href="#錯誤處理系統">錯誤處理系統</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/30_error_handling.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/30_error_handling.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>主要使用Result類型
在 Erg 中，如果您丟棄 Error 類型的對象(頂層不支持)，則會發生錯誤</p>
<h2 id="異常與-python-互操作"><a class="header" href="#異常與-python-互操作">異常，與 Python 互操作</a></h2>
<p>Erg 沒有異常機制(Exception)。導入 Python 函數時</p>
<ul>
<li>將返回值設置為 <code>T 或 Error</code> 類型</li>
<li><code>T or Panic</code> 類型(可能導致運行時錯誤)</li>
</ul>
<p>有兩個選項，<code>pyimport</code> 默認為后者。如果要作為前者導入，請使用
在 <code>pyimport</code> <code>exception_type</code> 中指定 <code>Error</code> (<code>exception_type: {Error, Panic}</code>)</p>
<h2 id="異常和結果類型"><a class="header" href="#異常和結果類型">異常和結果類型</a></h2>
<p><code>Result</code> 類型表示可能是錯誤的值。<code>Result</code> 的錯誤處理在幾個方面優于異常機制
首先，從類型定義中可以看出子程序可能會報錯，實際使用時也很明顯</p>
<pre><code class="language-python"># Python
try:
    x = foo().bar()
    y = baz()
    qux()
except e:
    print(e)
</code></pre>
<p>在上面的示例中，僅憑此代碼無法判斷哪個函數引發了異常。即使回到函數定義，也很難判斷函數是否拋出異常</p>
<pre><code class="language-python"># Erg
try!:
    do!:
        x = foo!()?.bar()
        y = baz!()
        qux!()?
    e =&gt;
        print! e
</code></pre>
<p>另一方面，在這個例子中，我們可以看到 <code>foo!</code> 和 <code>qux!</code> 會引發錯誤
確切地說，<code>y</code> 也可能是 <code>Result</code> 類型，但您最終必須處理它才能使用里面的值</p>
<p>使用 <code>Result</code> 類型的好處不止于此。<code>Result</code> 類型也是線程安全的。這意味著錯誤信息可以(輕松)在并行執行之間傳遞</p>
<h2 id="語境"><a class="header" href="#語境">語境</a></h2>
<p>由于 <code>Error</code>/<code>Result</code> 類型本身不會產生副作用，不像異常，它不能有發送位置(Context)等信息，但是如果使用 <code>.context</code> 方法，可以將信息放在 <code>錯誤</code>對象。可以添加。<code>.context</code> 方法是一種使用 <code>Error</code> 對象本身并創建新的 <code>Error</code> 對象的方法。它們是可鏈接的，并且可以包含多個上下文</p>
<pre><code class="language-python">f() =
    todo() \
        .context &quot;to be implemented in ver 1.2&quot; \
        .context &quot;and more hints ...&quot;

f()
# Error: not implemented yet
# hint: to be implemented in ver 1.2
# hint: and more hints ...
</code></pre>
<p>請注意，諸如 <code>.msg</code> 和 <code>.kind</code> 之類的 <code>Error</code> 屬性不是次要的，因此它們不是上下文，并且不能像最初創建時那樣被覆蓋</p>
<h2 id="堆棧跟蹤"><a class="header" href="#堆棧跟蹤">堆棧跟蹤</a></h2>
<p><code>Result</code> 類型由于其方便性在其他語言中經常使用，但與異常機制相比，它的缺點是難以理解錯誤的來源
因此，在 Erg 中，<code>Error</code> 對象具有名為 <code>.stack</code> 的屬性，并再現了類似偽異常機制的堆棧跟蹤
<code>.stack</code> 是調用者對象的數組。每次 Error 對象被<code>return</code>(包括通過<code>?</code>)時，它都會將它的調用子例程推送到<code>.stack</code>
如果它是 <code>?</code>ed 或 <code>.unwrap</code>ed 在一個不可能 <code>return</code> 的上下文中，它會因為回溯而恐慌</p>
<pre><code class="language-python">f x =
    ...
    y = foo.try_some(x)?
    ...

g x =
    y = f(x)?
    ...

i = g(1)?
# Traceback (most recent call first):
# ...
# Foo.try_some, line 10, file &quot;foo.er&quot;
# 10 | y = foo.try_some(x)?
# module::f, line 23, file &quot;foo.er&quot;
# 23 | y = f(x)?
# module::g, line 40, file &quot;foo.er&quot;
# 40 | i = g(1)?
# Error: ...
</code></pre>
<h2 id="恐慌"><a class="header" href="#恐慌">恐慌</a></h2>
<p>Erg 還有一種處理不可恢復錯誤的機制，稱為 <strong>panicing</strong>
不可恢復的錯誤是由外部因素引起的錯誤，例如軟件/硬件故障、嚴重到無法繼續執行代碼的錯誤或程序員未預料到的錯誤。等如果發生這種情況，程序將立即終止，因為程序員的努力無法恢復正常運行。這被稱為&quot;恐慌&quot;</p>
<p>恐慌是通過 <code>panic</code> 功能完成的</p>
<pre><code class="language-python">panic &quot;something went wrong!&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="管道運算符"><a class="header" href="#管道運算符">管道運算符</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/31_pipeline.md&amp;commit_hash=06f8edc9e2c0cee34f6396fd7c64ec834ffb5352"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/31_pipeline.md%26commit_hash%3D06f8edc9e2c0cee34f6396fd7c64ec834ffb5352" alt="badge" /></a></p>
<p>管道運算符的使用方式如下: </p>
<pre><code class="language-python">assert f(g(x)) == (x |&gt; g |&gt; f)
assert f(g(x, y)) == ((x, y) |&gt; g |&gt; f)
</code></pre>
<p>換句話說，<code>Callable(object)</code> 的順序可以更改為 <code>object |&gt; Callable</code>
管道運算符也可用于方法。對于方法，<code>object.method(args)</code> 更改為 <code>object |&gt;.method(args)</code>
它看起來只是更多的<code>|&gt;</code>，但由于粘合強度較低，您可以減少<code>()</code>的數量</p>
<pre><code class="language-python">rand = -1.0..1.0 |&gt;.sample!()
log rand # 0.2597...

1+1*2 |&gt;.times do log(&quot;a&quot;, end := &quot;&quot;) # aaa

evens = 1..100 |&gt;.iter |&gt;.filter i -&gt; i % 2 == 0 |&gt;.collect Array
# 在沒有管道操作符的情況下實現，
_evens = (1..100).iter().filter(i -&gt; i % 2 == 0).collect(Array)
# or
__evens = 1..100 \
    .iter() \
    .filter i -&gt; i % 2 == 0 \
    .collect Array
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="與-python-集成"><a class="header" href="#與-python-集成">與 Python 集成</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/32_integration_with_Python.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/32_integration_with_Python.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<h2 id="導出到-python"><a class="header" href="#導出到-python">導出到 Python</a></h2>
<p>編譯 Erg 腳本時，會生成一個 .pyc 文件，可以簡單地將其作為 Python 模塊導入
但是，無法從 Python 訪問在 Erg 端設置為私有的變量</p>
<pre><code class="language-python"># foo.er
.public = &quot;this is a public variable&quot;
private = &quot;this is a private variable&quot;
</code></pre>
<pre><code class="language-console">erg --compile foo.er
</code></pre>
<pre><code class="language-python">import foo

print(foo.public)
print(foo.private) # 屬性錯誤: 
</code></pre>
<h2 id="從-python-導入"><a class="header" href="#從-python-導入">從 Python 導入</a></h2>
<p>默認情況下，從 Python 導入的所有對象都是&quot;Object&quot;類型。由于此時無法進行比較，因此有必要細化類型</p>
<h2 id="標準庫中的類型規范"><a class="header" href="#標準庫中的類型規范">標準庫中的類型規范</a></h2>
<p>Python 標準庫中的所有 API 都是由 Erg 開發團隊指定的類型</p>
<pre><code class="language-python">time = pyimport &quot;time&quot;
time.sleep! 1
</code></pre>
<h2 id="用戶腳本的類型規范"><a class="header" href="#用戶腳本的類型規范">用戶腳本的類型規范</a></h2>
<p>創建一個類型為 Python <code>foo</code> 模塊的 <code>foo.d.er</code> 文件
Python 端的類型提示被忽略，因為它們不是 100% 保證的</p>
<pre><code class="language-python"># foo.py
X = ...
def bar(x):
    ...
def baz():
    ...
...
</code></pre>
<pre><code class="language-python"># foo.d.er
foo = pyimport &quot;foo&quot;
.X = declare foo.'X', Int
.bar = declare foo.'bar', Int -&gt; Int
.baz! = declare foo.'baz', () =&gt; Int
</code></pre>
<pre><code class="language-python">foo = pyimport &quot;foo&quot;
assert foo.bar(1) in Int
</code></pre>
<p>這通過在運行時執行類型檢查來確保類型安全。<code>declare</code> 函數大致如下工作</p>
<pre><code class="language-python">declare|S: Subroutine| sub!: S, T =
    # 實際上，=&gt; 可以強制轉換為沒有塊副作用的函數
    x =&gt;
        assert x in T.Input
        y = sub!(x)
        assert y in T.Output
        y
</code></pre>
<p>由于這是運行時開銷，因此計劃使用 Erg 的類型系統對 Python 腳本進行靜態類型分析</p>

<div style="break-before: page; page-break-before: always;"></div><h1 id="包系統"><a class="header" href="#包系統">包系統</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/33_package_system.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/33_package_system.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>Erg包大致可以分為app包，即應用程序，以及lib包，即庫
應用包的入口點是<code>src/app.er</code>。<code>app.er</code> 中定義的<code>main</code> 函數被執行
lib 包的入口點是<code>src/lib.er</code>。導入包相當于導入 <code>lib.er</code></p>
<p>一個包有一個稱為模塊的子結構，在 Erg 中是一個 Erg 文件或由 Erg 文件組成的目錄。外部 Erg 文件/目錄是作為模塊對象的可操作對象</p>
<p>為了將目錄識別為模塊，有必要在目錄中放置一個&quot;(目錄名稱).er&quot;文件
這類似于 Python 的 <code>__init__.py</code>，但與 <code>__init__.py</code> 不同的是，它放在目錄之外</p>
<p>例如，考慮以下目錄結構</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.er
    └─ qux.er
</code></pre>
<p>您可以在 <code>app.er</code> 中導入 <code>foo</code> 和 <code>bar</code> 模塊。由于 <code>bar.er</code> 文件，<code>bar</code> 目錄可以被識別為一個模塊
<code>foo</code> 模塊是由文件組成的模塊，<code>bar</code> 模塊是由目錄組成的模塊。<code>bar</code> 模塊還包含 <code>baz</code> 和 <code>qux</code> 模塊
該模塊只是 <code>bar</code> 模塊的一個屬性，可以從 <code>app.er</code> 訪問，如下所示</p>
<pre><code class="language-python"># app.er
foo = import &quot;foo&quot;
bar = import &quot;bar&quot;
baz = bar.baz
# or `baz = import &quot;bar/baz&quot;`

main args =
    ...
</code></pre>
<p>請注意用于訪問子模塊的 <code>/</code> 分隔符。這是因為可以有諸如 <code>bar.baz.er</code> 之類的文件名
不鼓勵使用此類文件名，因為 <code>.er</code> 前綴在 Erg 中是有意義的
例如，用于測試的模塊。以 <code>.test.er</code> 結尾的文件是一個(白盒)測試模塊，它在運行測試時執行一個用 <code>@Test</code> 修飾的子例程</p>
<pre><code class="language-console">└─┬ ./src
  ├─ app.er
  ├─ foo.er
  └─ foo.test.er
./src

```python
# app.er
foo = import &quot;foo&quot;

main args =
    ...
</code></pre>
<p>此外，以 .private.er 結尾的文件是私有模塊，只能由同一目錄中的模塊訪問</p>
<pre><code class="language-console">└─┬
  ├─ foo.er
  ├─ bar.er
  └─┬ bar
    ├─ baz.private.er
    └─ qux.er
</code></pre>
<pre><code class="language-python"># foo.er
bar = import &quot;bar&quot;
bar.qux
bar.baz # AttributeError: module 'baz' is private
</code></pre>
<pre><code class="language-python"># qux.er
baz = import &quot;baz&quot;
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="生成器"><a class="header" href="#生成器">生成器</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/34_generator.md&amp;commit_hash=51de3c9d5a9074241f55c043b9951b384836b258"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/34_generator.md%26commit_hash%3D51de3c9d5a9074241f55c043b9951b384836b258" alt="badge" /></a></p>
<p>生成器是在塊中使用 <code>yield!</code> 過程的特殊過程</p>
<pre><code class="language-python">g!() =
    yield! 1
    yield! 2
    yield! 3
</code></pre>
<p><code>yield!</code> 是在調用<code>self!.yield!</code> 的子程序塊中定義的過程。和<code>return</code>一樣，它把傳遞給它的值作為返回值返回，但它具有保存block當前執行狀態，再次調用時從頭開始執行的特性
生成器既是過程又是迭代器； Python 生成器是一個創建迭代器的函數，而 Erg 直接迭代。過程本身通常不是可變對象(沒有<code>！</code>)，但生成器是可變對象，因為它自己的內容可以隨著每次執行而改變</p>
<pre><code class="language-python"># Generator!
g!: Generator!((), Int)
assert g!() == 1
assert g!() == 2
assert g!() == 3
</code></pre>
<p>Python 風格的生成器可以定義如下</p>
<pre><code class="language-python">make_g() = () =&gt;
    yield! 1
    yield! 2
    yield! 3
make_g: () =&gt; Generator!
</code></pre>

<div style="break-before: page; page-break-before: always;"></div><h1 id="指數"><a class="header" href="#指數">指數</a></h1>
<p><a href="https://gezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com/default/source_up_to_date?owner=erg-lang&amp;repos=erg&amp;ref=main&amp;path=doc/EN/syntax/indexes.md&amp;commit_hash=d8472ec748aac5371571da81a161255fe60679b7"><img src="https://img.shields.io/endpoint.svg?url=https%3A%2F%2Fgezf7g7pd5.execute-api.ap-northeast-1.amazonaws.com%2Fdefault%2Fsource_up_to_date%3Fowner%3Derg-lang%26repos%3Derg%26ref%3Dmain%26path%3Ddoc/EN/syntax/indexes.md%26commit_hash%3Dd8472ec748aac5371571da81a161255fe60679b7" alt="badge" /></a></p>
<p>有關不在此索引中的 API，請參閱 <a href="../API/index.html">此處</a></p>
<p>有關術語，請參見 <a href="../terms.html">此處</a></p>
<h2 id="符號"><a class="header" href="#符號">符號</a></h2>
<ul>
<li>! → <a href="./07_side_effect.html">side effect</a>
<ul>
<li>!-type → <a href="./type/18_mut.html">mutable type</a></li>
</ul>
</li>
<li>? → <a href="./30_error_handling.html">error handling</a></li>
<li># → <a href="./00_basic.html">Str</a></li>
<li>$ → <a href="./type/advanced/shared.html">shared</a></li>
<li>%</li>
<li>&amp;
<ul>
<li>&amp;&amp;</li>
</ul>
</li>
<li><a href="./20_naming_rule.html">′ (single quote)</a></li>
<li><a href="./01_literal.html">&quot; (double quote)</a></li>
<li>() → <a href="./11_tuple.html">Tuple</a></li>
<li>*
<ul>
<li>* → <a href="./01_literal.html">*-less multiplication</a></li>
</ul>
</li>
<li>+ (前置) → <a href="./06_operator.html">operator</a>
<ul>
<li>+_ → + (前置)</li>
</ul>
</li>
<li>+ (中置) → <a href="./06_operator.html">operator</a></li>
<li>+ (中置) → <a href="./type/03_trait.html">Trait</a></li>
<li>,</li>
<li>− (前置)
<ul>
<li>−_ → − (前置)</li>
</ul>
</li>
<li>− (中置) → <a href="./06_operator.html">operator</a></li>
<li>− (中置) → <a href="./type/03_trait.html">Trait</a>
<ul>
<li>−&gt; → <a href="./21_lambda.html">anonymous function</a></li>
</ul>
</li>
<li>. → <a href="./19_visibility.html">Visibility</a>
<ul>
<li><a href="./28_spread_syntax.html">... assignment</a></li>
<li><a href="./28_spread_syntax.html">... Extract assignment</a></li>
<li><a href="./04_function.html">... function</a></li>
</ul>
</li>
<li>/</li>
<li>:
<ul>
<li>: → <a href="./04_function.html">Colon application style</a></li>
<li>: → <a href="./03_declaration.html">Declaration</a></li>
<li>: → <a href="./04_function.html">Keyword Arguments</a></li>
<li>:: → <a href="./19_visibility.html">visibility</a></li>
<li>:= → <a href="./04_function.html">default parameters</a></li>
</ul>
</li>
<li>;</li>
<li>&lt;
<ul>
<li>&lt;: → <a href="./type/02_basic.html">Subtype specification</a></li>
<li>&lt;&lt;</li>
<li>&lt;=</li>
</ul>
</li>
<li>= → <a href="./19_visibility.html">Variable</a>
<ul>
<li>==</li>
<li>=&gt; → <a href="./08_procedure.html">procedure</a></li>
</ul>
</li>
<li>&gt;
<ul>
<li>&gt;&gt;</li>
<li>&gt;=</li>
</ul>
</li>
<li>@ → <a href="./29_decorator.html">decorator</a></li>
<li>[] → <a href="./10_array.html">Array</a></li>
<li>\ → <a href="./00_basic.html">Indention</a></li>
<li>\ → <a href="./01_literal.html">Str</a></li>
<li>^
<ul>
<li>^^</li>
</ul>
</li>
<li>_ → <a href="./type/advanced/erasure.html">Type erasure</a>
<ul>
<li>_+_ → + (infix)</li>
<li>_-_ → − (infix)</li>
</ul>
</li>
<li><a href="./22_subroutine.html">`` (back quote)</a></li>
<li>{}
<ul>
<li><a href="./type/01_type_system.html">{} type</a></li>
</ul>
</li>
<li>{:}</li>
<li>{=} → <a href="./type/01_type_system.html">Type System</a>
<ul>
<li><a href="./13_record.html">{=} type</a></li>
</ul>
</li>
<li>|
<ul>
<li>|| → <a href="./type/advanced/">Type variable list</a></li>
</ul>
</li>
<li>~</li>
</ul>
<h2 id="拉丁字母"><a class="header" href="#拉丁字母">拉丁字母</a></h2>
<h3 id="a"><a class="header" href="#a">A</a></h3>
<ul>
<li>[Add]</li>
<li><a href="type/02_basic.html">alias</a></li>
<li><a href="./type/02_basic.html">Aliasing</a></li>
<li><a href="./type/15_quantified.html">All symmetric types</a></li>
<li><a href="./type/13_algebraic.html">algebraic type</a></li>
<li>[And]</li>
<li>[and]</li>
<li><a href="./21_lambda.html">anonymous function</a></li>
<li><a href="./21_lambda.html">Anonymous polycorrelation coefficient</a></li>
<li>anonymous type → <a href="./type/01_type_system.html">Type System</a></li>
<li><a href="./10_array.html">Array</a></li>
<li>[assert]</li>
<li><a href="./29_decorator.html">Attach</a></li>
<li><a href="type/09_attributive.html">attribute</a></li>
<li><a href="./type/02_basic.html">Attribute definitions</a></li>
<li><a href="./type/09_attributive.html">Attribute Type</a></li>
</ul>
<h3 id="b"><a class="header" href="#b">B</a></h3>
<ul>
<li><a href="./01_literal.html">Bool, Boolean</a></li>
<li><a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./18_ownership.html">borrow</a></li>
</ul>
<h3 id="c"><a class="header" href="#c">C</a></h3>
<ul>
<li><a href="./type/17_type_casting.html">Cast</a></li>
<li><a href="./00_basic.html">Comments</a></li>
<li><a href="./01_literal.html">Complex Object</a></li>
<li><a href="./04_function.html">Compile-time functions</a></li>
<li><a href="./18_ownership.html">circular references</a></li>
<li><a href="./type/04_class.html">Class</a></li>
<li><a href="./type/04_class.html">Class Relationship</a></li>
<li><a href="./type/16_subtyping.html">Class upcasting</a></li>
<li><a href="./04_function.html">Colon application style</a></li>
<li><a href="./23_closure.html">Closure</a></li>
<li><a href="./01_literal.html">Compound Literals</a></li>
<li><a href="./type/13_algebraic.html">Complement</a></li>
<li><a href="./27_comprehension.html">Comprehension</a></li>
<li><a href="./17_mutability.html">constant</a></li>
<li><a href="./02_name.html">Constants</a></li>
<li><a href="./30_error_handling.html">Context</a></li>
</ul>
<h3 id="d"><a class="header" href="#d">D</a></h3>
<ul>
<li><a href="./type/01_type_system.html">Data type</a></li>
<li><a href="./03_declaration.html">Declaration</a></li>
<li><a href="./29_decorator.html">decorator</a></li>
<li><a href="./04_function.html">Default parameters</a></li>
<li><a href="./02_name.html">Del</a></li>
<li><a href="./type/14_dependent.html">Dependent Type</a></li>
<li><a href="13_record.html">Deconstructing a record</a></li>
<li>Deprecated</li>
<li><a href="./12_dict.html">Dict</a></li>
<li><a href="./type/13_algebraic.html">Diff</a></li>
<li><a href="./type/04_class.html">Difference from Data Class</a></li>
<li><a href="type/04_class.html">Difference from structural types</a></li>
<li>distinct</li>
<li><a href="./type/17_type_casting.html">Downcasting</a></li>
</ul>
<h3 id="e"><a class="header" href="#e">E</a></h3>
<ul>
<li><a href="./13_record.html">Empty Record</a></li>
<li><a href="./type/04_class.html">Enum Class</a></li>
<li><a href="./type/11_enum.html">Enum type</a></li>
<li><a href="./type/12_refinement.html">Enumerated, Interval and Refinement Types</a></li>
<li><a href="./30_error_handling.html">error handling</a></li>
<li><a href="./type/advanced/existential.html">Existential type</a></li>
<li><a href="./01_literal.html">Exponential Literal</a></li>
<li><a href="./28_spread_syntax.html">Extract assignment</a></li>
</ul>
<h3 id="f"><a class="header" href="#f">F</a></h3>
<ul>
<li>False → <a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./01_literal.html">Float&amp;sbsp;Object</a></li>
<li><a href="./05_builtin_funcs.html">for</a></li>
<li><a href="./type/07_patch.html">For-All Patch</a></li>
<li><a href="./18_ownership.html">freeze</a></li>
<li><a href="./04_function.html">Function</a></li>
<li><a href="./04_function.html">Function definition with multiple patterns</a></li>
</ul>
<h3 id="g"><a class="header" href="#g">G</a></h3>
<ul>
<li><a href="./type/advanced/GADTs.html">GADTs(Generalized Algebraic Data Types)</a></li>
<li><a href="./34_generator.html">Generator</a></li>
<li><a href="./type/07_patch.html">Glue Patch</a></li>
</ul>
<h3 id="h"><a class="header" href="#h">H</a></h3>
<h3 id="i"><a class="header" href="#i">I</a></h3>
<ul>
<li><a href="./09_builtin_procs.html">id</a></li>
<li><a href="./05_builtin_funcs.html">if</a></li>
<li><a href="./33_package_system.html">import</a></li>
<li><a href="./29_decorator.html">impl</a></li>
<li>[in]</li>
<li><a href="./00_basic.html">Indention</a></li>
<li><a href="./13_record.html">Instant Block</a></li>
<li><a href="./type/04_class.html">Instance and class attributes</a></li>
<li><a href="type/03_trait.html">Implementing and resolving duplicate traits in the API</a></li>
<li><a href="./29_decorator.html">inheritable</a></li>
<li><a href="./type/05_inheritance.html">inheritance</a></li>
<li><a href="./type/05_inheritance.html">Inheritance of Enumerated Classes</a></li>
<li><a href="./01_literal.html">Int</a></li>
<li><a href="./32_integration_with_Python.html">Integration with Python</a></li>
<li><a href="./type/10_interval.html">Interval Type</a></li>
<li><a href="./type/13_algebraic.html">Intersection</a></li>
<li><a href="./16_iterator.html">Iterator</a></li>
</ul>
<h3 id="j"><a class="header" href="#j">J</a></h3>
<h3 id="k"><a class="header" href="#k">K</a></h3>
<ul>
<li><a href="./04_function.html">Keyword arguments</a></li>
<li><a href="./type/advanced/kind.html">Kind</a></li>
</ul>
<h3 id="l"><a class="header" href="#l">L</a></h3>
<ul>
<li>lambda → <a href="./21_lambda.html">anonymous function</a></li>
<li>let-polymorphism → [rank 1 polymorphism]</li>
<li><a href="./20_naming_rule.html">Literal Identifiers</a></li>
<li>log → <a href="./07_side_effect.html">side effect</a></li>
</ul>
<h3 id="m"><a class="header" href="#m">M</a></h3>
<ul>
<li>[match]</li>
<li><a href="./type/advanced/marker_trait.html">Marker Trait</a></li>
<li><a href="./07_side_effect.html">Method</a></li>
<li>Modifier → <a href="./29_decorator.html">decorator</a></li>
<li><a href="./24_module.html">module</a></li>
<li><a href="type/05_inheritance.html">Multiple Inheritance</a></li>
<li><a href="type/05_inheritance.html">Multi-layer (multi-level) Inheritance</a></li>
<li><a href="./type/18_mut.html">Mutable Type</a></li>
<li><a href="./type/advanced/mut_struct.html">Mutable Structure Type</a></li>
<li><a href="./17_mutability.html">Mutability</a></li>
</ul>
<h3 id="n"><a class="header" href="#n">N</a></h3>
<ul>
<li><a href="./01_literal.html">Nat</a></li>
<li>[Never]</li>
<li><a href="./type/advanced/newtype.html">New type</a></li>
<li><a href="./12_dict.html">Heterogeneous Dict</a></li>
<li>None → [None Object]</li>
<li>[None Object]</li>
<li>Nominal Subtyping → <a href="./type/04_class.html">Class</a></li>
<li>[Not]</li>
<li>[not]</li>
</ul>
<h3 id="o"><a class="header" href="#o">O</a></h3>
<ul>
<li><a href="./25_object_system.html">Object</a></li>
<li>[Option]</li>
<li>[Or]</li>
<li>[or]</li>
<li>[Ord]</li>
<li><a href="./18_ownership.html">ownership system</a></li>
<li><a href="./type/advanced/overloading.html">Overloading</a></li>
<li><a href="./type/05_inheritance.html">Overriding</a></li>
<li><a href="./type/03_trait.html">Override in Trait</a></li>
</ul>
<h3 id="p"><a class="header" href="#p">P</a></h3>
<ul>
<li><a href="./30_error_handling.html">Panic</a></li>
<li><a href="./type/07_patch.html">Patch</a></li>
<li><a href="./26_pattern_matching.html">Pattern match</a></li>
<li><a href="./type/advanced/phantom.html">Phantom class</a></li>
<li><a href="./31_pipeline.html">pipeline operator</a></li>
<li><a href="./type/19_bound.html">Predicate</a></li>
<li>[print!]</li>
<li><a href="./08_procedure.html">Procedures</a></li>
<li><a href="./type/advanced/projection.html">Projection Type</a></li>
<li>Python → <a href="./32_integration_with_Python.html">Integration with Python</a></li>
</ul>
<h3 id="q"><a class="header" href="#q">Q</a></h3>
<ul>
<li><a href="./type/15_quantified.html">Quantified Type</a></li>
<li><a href="./type/advanced/quantified_dependent.html">Quantified Dependent Type</a></li>
<li><a href="./type/15_quantified.html">Quantified Types and Dependent Types</a></li>
</ul>
<h3 id="r"><a class="header" href="#r">R</a></h3>
<ul>
<li><a href="./01_literal.html">Range Object</a></li>
<li>[ref]</li>
<li>[ref!]</li>
<li><a href="./13_record.html">Record</a></li>
<li><a href="./type/09_attributive.mda12_refinement.html">Record Type Composite</a></li>
<li><a href="./04_function.html">Recursive functions</a></li>
<li><a href="./type/12_refinement.html">Refinement pattern</a></li>
<li><a href="./type/12_refinement.html">Refinement Type</a></li>
<li><a href="./18_ownership.html">replication</a></li>
<li><a href="./type/05_inheritance.html">Replacing Traits</a></li>
<li>Result → <a href="./30_error_handling.html">error handling</a></li>
<li><a href="./type/05_inheritance.html">Rewriting Inherited Attributes</a></li>
<li>rootobj</li>
</ul>
<h3 id="s"><a class="header" href="#s">S</a></h3>
<ul>
<li><a href="./00_basic.html">Script</a></li>
<li><a href="./type/07_patch.html">Selecting Patches</a></li>
<li>self</li>
<li><a href="./type/advanced/special.html">Self</a></li>
<li><a href="./type/advanced/shared.html">Shared Reference</a></li>
<li><a href="./07_side_effect.html">side-effect</a></li>
<li><a href="./type/12_refinement.html">Smart Cast</a></li>
<li><a href="./28_spread_syntax.html">Spread assignment</a></li>
<li><a href="./type/advanced/special.html">special type variables</a></li>
<li><a href="30_error_handling.html">Stack trace</a></li>
<li><a href="./type/01_type_system.html">Structure type</a></li>
<li><a href="./type/07_patch.html">Structural Patch</a></li>
<li><a href="./type/03_trait.html">Structural Trait</a></li>
<li><a href="./type/01_type_system.html">Structural Subtyping</a></li>
<li><a href="./type/16_subtyping.html">Structural types and class type relationships</a></li>
<li><a href="./01_literal.html">Str</a></li>
<li><a href="./type/16_subtyping.html">Subtyping</a></li>
<li><a href="./type/16_subtyping.html">Subtyping of subroutines</a></li>
<li><a href="./type/02_basic.html">Subtype specification</a></li>
<li><a href="./type/15_quantified.html">Subtyping of Polymorphic Function Types</a></li>
<li><a href="./22_subroutine.html">Subroutine Signatures</a></li>
</ul>
<h3 id="t"><a class="header" href="#t">T</a></h3>
<ul>
<li><a href="./29_decorator.html">Test</a></li>
<li><a href="./type/03_trait.html">Traits</a></li>
<li><a href="./type/03_trait.html">Trait inclusion</a></li>
<li>True → <a href="./01_literal.html">Boolean Object</a></li>
<li><a href="./type/13_algebraic.html">True Algebraic type</a></li>
<li>[Type]</li>
<li><a href="./15_type.html">type</a></li>
<li><a href="./type/15_quantified.html">Type arguments in method definitions</a></li>
<li><a href="./type/19_bound.html">Type Bound</a></li>
<li><a href="./type/01_type_system.html">Type Definitions</a></li>
<li><a href="./type/advanced/erasure.html">Type erasure</a></li>
<li><a href="./type/01_type_system.html">Type Inference System</a></li>
<li><a href="./type/02_basic.html">Type specification</a></li>
<li><a href="./type/01_type_system.html">Type System</a></li>
<li><a href="./type/advanced/widening.html">Type Widening</a></li>
<li><a href="./11_tuple.html">Tuple</a></li>
</ul>
<h3 id="u"><a class="header" href="#u">U</a></h3>
<ul>
<li><a href="type/13_algebraic.html">union</a></li>
<li><a href="./11_tuple.html">Unit</a></li>
<li><a href="type/17_type_casting.html">Upcasting</a></li>
<li><a href="./type/05_inheritance.html">Usage of Inheritance</a></li>
</ul>
<h3 id="v"><a class="header" href="#v">V</a></h3>
<ul>
<li><a href="./type/08_value.html">Value Type</a></li>
<li><a href="./02_name.html">Variable</a></li>
<li><a href="./04_function.html">variable-length arguments</a></li>
</ul>
<h3 id="w"><a class="header" href="#w">W</a></h3>
<ul>
<li>[while]</li>
</ul>
<h3 id="x"><a class="header" href="#x">X</a></h3>
<h3 id="y"><a class="header" href="#y">Y</a></h3>
<h3 id="z"><a class="header" href="#z">Z</a></h3>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
